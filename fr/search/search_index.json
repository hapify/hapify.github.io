{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Accueil"},{"location":"code-samples/hapify/","text":"Ce document pr\u00e9sente des exemples de code afin de vous aider \u00e0 jouer avec les templates Hapify. Pr\u00e9-requis Avant de lire cet article, nous vous recommandons de lire la documentation sur les templates Hapify . Cr\u00e9ation d'une classe TypeScript Hapify (long) <<# Import dependencies >> <<for Dependencies not ( hidden and internal ) dep >> import { <<dep pascal>> } from './ <<dep pascal>> '; <<endfor>> <<# Declare interfaces for enum fields >> <<for Fields enum field >> export type <<Model pascal>><<field pascal>> Enum = <<for field . enum e >> | '<<e snake >> '<<endfor >> ; <<endfor>> export class <<Model pascal>> { <<for Fields not primary field >> <<if field entity >> private <<field camel>> : number <<if field multiple >> []<<endif >> ; <<elseif field enum >> public <<field camel>> : <<Model pascal>><<field pascal>> Enum; <<elseif field datetime >> public <<field camel>> : Date; <<else>> public <<field camel>> : <<=field.type>> ; <<endif>> <<endfor>> constructor(private <<PrimaryField camel>> : number) {} <<# Getter for primary field >> getId(): number { return this. <<PrimaryField camel>> } getLabel(): string { <<if Fields label >> return ` <<=labels()>> `; <<else>> return this.getId().toString(); <<endif>> } <<# Getter for each entity >> <<for Fields entity field >> get <<field pascal>> (): <<field.model pascal>> <<if field multiple >> []<<endif >> { <<if field multiple >> return this. <<field camel>> .map(id => new <<field.model pascal>> (id)); <<else>> return new <<field.model pascal>> (this. <<field camel>> ); <<endif>> } <<endfor>> } <<< function labels() { return root.fields.label .map(label => \"${this.\"+label.names.snake+\"}\") .join(' '); } >>> Sortie 1 import { PlaceCategory } from './PlaceCategory' ; import { Service } from './Service' ; import { User } from './User' ; export class Place { public name : string ; public description : string ; private categories : number []; public address1 : string ; public address2 : string ; public latitude : number ; public longitude : number ; public phone : string ; public websiteUrl : string ; private services : number []; public timetable : string ; private owner : number ; public disabled : boolean ; constructor ( private id : number ) {} getId () : number { return this . id } getLabel () : string { return ` ${ this . name } ` ; } getCategories () : PlaceCategory [] { return this . categories . map ( id => new PlaceCategory ( id )); } getServices () : Service [] { return this . services . map ( id => new Service ( id )); } getOwner () : User { return new User ( this . owner ); } } Sortie 2 export type UserRoleEnum = | 'admin' | 'user' ; export class User { public name : string ; public email : string ; public password : string ; public role : UserRoleEnum ; public banned : boolean ; public lastConnectedAt : Date ; constructor ( private id : number ) {} getId () : number { return this . id } getLabel () : string { return ` ${ this . name } ` ; } }","title":"Hapify"},{"location":"code-samples/hapify/#pre-requis","text":"Avant de lire cet article, nous vous recommandons de lire la documentation sur les templates Hapify .","title":"Pr\u00e9-requis"},{"location":"code-samples/hapify/#creation-dune-classe-typescript","text":"Hapify (long) <<# Import dependencies >> <<for Dependencies not ( hidden and internal ) dep >> import { <<dep pascal>> } from './ <<dep pascal>> '; <<endfor>> <<# Declare interfaces for enum fields >> <<for Fields enum field >> export type <<Model pascal>><<field pascal>> Enum = <<for field . enum e >> | '<<e snake >> '<<endfor >> ; <<endfor>> export class <<Model pascal>> { <<for Fields not primary field >> <<if field entity >> private <<field camel>> : number <<if field multiple >> []<<endif >> ; <<elseif field enum >> public <<field camel>> : <<Model pascal>><<field pascal>> Enum; <<elseif field datetime >> public <<field camel>> : Date; <<else>> public <<field camel>> : <<=field.type>> ; <<endif>> <<endfor>> constructor(private <<PrimaryField camel>> : number) {} <<# Getter for primary field >> getId(): number { return this. <<PrimaryField camel>> } getLabel(): string { <<if Fields label >> return ` <<=labels()>> `; <<else>> return this.getId().toString(); <<endif>> } <<# Getter for each entity >> <<for Fields entity field >> get <<field pascal>> (): <<field.model pascal>> <<if field multiple >> []<<endif >> { <<if field multiple >> return this. <<field camel>> .map(id => new <<field.model pascal>> (id)); <<else>> return new <<field.model pascal>> (this. <<field camel>> ); <<endif>> } <<endfor>> } <<< function labels() { return root.fields.label .map(label => \"${this.\"+label.names.snake+\"}\") .join(' '); } >>> Sortie 1 import { PlaceCategory } from './PlaceCategory' ; import { Service } from './Service' ; import { User } from './User' ; export class Place { public name : string ; public description : string ; private categories : number []; public address1 : string ; public address2 : string ; public latitude : number ; public longitude : number ; public phone : string ; public websiteUrl : string ; private services : number []; public timetable : string ; private owner : number ; public disabled : boolean ; constructor ( private id : number ) {} getId () : number { return this . id } getLabel () : string { return ` ${ this . name } ` ; } getCategories () : PlaceCategory [] { return this . categories . map ( id => new PlaceCategory ( id )); } getServices () : Service [] { return this . services . map ( id => new Service ( id )); } getOwner () : User { return new User ( this . owner ); } } Sortie 2 export type UserRoleEnum = | 'admin' | 'user' ; export class User { public name : string ; public email : string ; public password : string ; public role : UserRoleEnum ; public banned : boolean ; public lastConnectedAt : Date ; constructor ( private id : number ) {} getId () : number { return this . id } getLabel () : string { return ` ${ this . name } ` ; } }","title":"Cr\u00e9ation d'une classe TypeScript"},{"location":"code-samples/javascript/","text":"Ce document pr\u00e9sente des exemples de code afin de vous aider \u00e0 jouer avec les templates JavaScript. Pr\u00e9-requis Avant de lire cet article, nous vous recommandons de lire la documentation sur les templates JavaScript . Cr\u00e9er des index pour MongoDB Ce template produira un JSON contenant tous les index qui doivent \u00eatre cr\u00e9\u00e9s dans MongoDB en fonction des attributs du champ. Il cr\u00e9e un index pour les champs recherchables, triables ou les r\u00e9f\u00e9rences. Il cr\u00e9e \u00e9galement un index unique pour les champs uniques et un index texte pour les champs de type string recherchable. JavaScript /** Generate indexes for a model */ function _model ( out , model ) { const modelName = model . names . snake ; const strings = { fields : {} }; const uniques = { fields : {}, options : { unique : true } }; // Even if no fields have indexes, Include this collection // Get fields objects out [ modelName ] = model . fields . list . reduce (( p , field ) => { // Non primary fields if ( field . primary ) { return p ; } // Only if the field is searchable, sortable a reference or is unique if ( ! ( field . sortable || field . searchable || field . type === 'entity' || field . unique )) { return p ; } const fieldName = field . names . snake ; // Special text index for strings if ( field . type === 'string' && field . searchable ) { strings . fields [ fieldName ] = 'text' ; } // Normal indexes p [ ` ${ modelName } _ ${ fieldName } ` ] = { fields : { [ fieldName ] : 1 } }; if ( field . unique ) { p [ ` ${ modelName } _ ${ fieldName } ` ]. options = { unique : true }; uniques . fields [ fieldName ] = 1 ; } return p ; }, {}); // Add labels if ( Object . keys ( strings . fields ). length > 0 ) { out [ modelName ][ ` ${ modelName } __text` ] = strings ; } // Optimize unique indexes if ( Object . keys ( uniques . fields ). length > 1 ) { // Remove unique from other indexes model . fields . unique . map ( field => { const fieldName = field . names . snake ; if ( out [ modelName ][ ` ${ modelName } _ ${ fieldName } ` ]) { delete out [ modelName ][ ` ${ modelName } _ ${ fieldName } ` ]. options ; } }); // Add unique out [ modelName ][ ` ${ modelName } __uniques` ] = uniques ; } return out ; } const _output = models . reduce ( _model , {}); return JSON . stringify ( _output , null , 2 ); Sortie { \"service\" : { \"service_created_at\" : { \"fields\" : { \"created_at\" : 1 } }, \"service_name\" : { \"fields\" : { \"name\" : 1 }, \"options\" : { \"unique\" : true } }, \"service__text\" : { \"fields\" : { \"name\" : \"text\" } } }, \"user\" : { \"user_created_at\" : { \"fields\" : { \"created_at\" : 1 } }, \"user_name\" : { \"fields\" : { \"name\" : 1 } }, \"user_email\" : { \"fields\" : { \"email\" : 1 }, \"options\" : { \"unique\" : true } }, \"user_role\" : { \"fields\" : { \"role\" : 1 } }, \"user_banned\" : { \"fields\" : { \"banned\" : 1 } }, \"user__text\" : { \"fields\" : { \"name\" : \"text\" , \"email\" : \"text\" , \"role\" : \"text\" } } } } G\u00e9n\u00e9rer une description du mod\u00e8le de donn\u00e9es en JSON Ce template produira un JSON qui liste les champs et r\u00e9sout les d\u00e9pendances entre les mod\u00e8les. JavaScript const _output = models . map (( m ) => { return { collection : m . names . snake , dependencies : m . dependencies . list . map (( d ) => { return d . names . snake }), fields : m . fields . list . map (( f ) => { const out = { name : f . names . snake , notes : f . notes , type : f . type , subtype : f . subtype , properties : [] }; // Convert boolean properties to list for ( const prop of Object . keys ( f )) { if ( typeof f [ prop ] === 'boolean' && f [ prop ]) { out . properties . push ( prop ) } } // Append model reference if any if ( f . model ) { out . reference = f . model . names . snake ; } return out ; }) }; }); return JSON . stringify ( _output , null , 4 ); Sortie [ { \"collection\" : \"bookmark\" , \"dependencies\" : [ \"user\" , \"place\" ], \"fields\" : [ { \"name\" : \"_id\" , \"notes\" : null , \"type\" : \"string\" , \"subtype\" : null , \"properties\" : [ \"primary\" , \"internal\" ] }, { \"name\" : \"created_at\" , \"notes\" : null , \"type\" : \"datetime\" , \"subtype\" : null , \"properties\" : [ \"sortable\" , \"internal\" ] }, { \"name\" : \"owner\" , \"notes\" : \"Current user when creating the bookmark\" , \"type\" : \"entity\" , \"subtype\" : null , \"properties\" : [ \"unique\" , \"searchable\" , \"internal\" , \"ownership\" ], \"reference\" : \"user\" }, { \"name\" : \"place\" , \"notes\" : null , \"type\" : \"entity\" , \"subtype\" : null , \"properties\" : [ \"unique\" , \"searchable\" ], \"reference\" : \"place\" } ] } ]","title":"JavaScript"},{"location":"code-samples/javascript/#pre-requis","text":"Avant de lire cet article, nous vous recommandons de lire la documentation sur les templates JavaScript .","title":"Pr\u00e9-requis"},{"location":"code-samples/javascript/#creer-des-index-pour-mongodb","text":"Ce template produira un JSON contenant tous les index qui doivent \u00eatre cr\u00e9\u00e9s dans MongoDB en fonction des attributs du champ. Il cr\u00e9e un index pour les champs recherchables, triables ou les r\u00e9f\u00e9rences. Il cr\u00e9e \u00e9galement un index unique pour les champs uniques et un index texte pour les champs de type string recherchable. JavaScript /** Generate indexes for a model */ function _model ( out , model ) { const modelName = model . names . snake ; const strings = { fields : {} }; const uniques = { fields : {}, options : { unique : true } }; // Even if no fields have indexes, Include this collection // Get fields objects out [ modelName ] = model . fields . list . reduce (( p , field ) => { // Non primary fields if ( field . primary ) { return p ; } // Only if the field is searchable, sortable a reference or is unique if ( ! ( field . sortable || field . searchable || field . type === 'entity' || field . unique )) { return p ; } const fieldName = field . names . snake ; // Special text index for strings if ( field . type === 'string' && field . searchable ) { strings . fields [ fieldName ] = 'text' ; } // Normal indexes p [ ` ${ modelName } _ ${ fieldName } ` ] = { fields : { [ fieldName ] : 1 } }; if ( field . unique ) { p [ ` ${ modelName } _ ${ fieldName } ` ]. options = { unique : true }; uniques . fields [ fieldName ] = 1 ; } return p ; }, {}); // Add labels if ( Object . keys ( strings . fields ). length > 0 ) { out [ modelName ][ ` ${ modelName } __text` ] = strings ; } // Optimize unique indexes if ( Object . keys ( uniques . fields ). length > 1 ) { // Remove unique from other indexes model . fields . unique . map ( field => { const fieldName = field . names . snake ; if ( out [ modelName ][ ` ${ modelName } _ ${ fieldName } ` ]) { delete out [ modelName ][ ` ${ modelName } _ ${ fieldName } ` ]. options ; } }); // Add unique out [ modelName ][ ` ${ modelName } __uniques` ] = uniques ; } return out ; } const _output = models . reduce ( _model , {}); return JSON . stringify ( _output , null , 2 ); Sortie { \"service\" : { \"service_created_at\" : { \"fields\" : { \"created_at\" : 1 } }, \"service_name\" : { \"fields\" : { \"name\" : 1 }, \"options\" : { \"unique\" : true } }, \"service__text\" : { \"fields\" : { \"name\" : \"text\" } } }, \"user\" : { \"user_created_at\" : { \"fields\" : { \"created_at\" : 1 } }, \"user_name\" : { \"fields\" : { \"name\" : 1 } }, \"user_email\" : { \"fields\" : { \"email\" : 1 }, \"options\" : { \"unique\" : true } }, \"user_role\" : { \"fields\" : { \"role\" : 1 } }, \"user_banned\" : { \"fields\" : { \"banned\" : 1 } }, \"user__text\" : { \"fields\" : { \"name\" : \"text\" , \"email\" : \"text\" , \"role\" : \"text\" } } } }","title":"Cr\u00e9er des index pour MongoDB"},{"location":"code-samples/javascript/#generer-une-description-du-modele-de-donnees-en-json","text":"Ce template produira un JSON qui liste les champs et r\u00e9sout les d\u00e9pendances entre les mod\u00e8les. JavaScript const _output = models . map (( m ) => { return { collection : m . names . snake , dependencies : m . dependencies . list . map (( d ) => { return d . names . snake }), fields : m . fields . list . map (( f ) => { const out = { name : f . names . snake , notes : f . notes , type : f . type , subtype : f . subtype , properties : [] }; // Convert boolean properties to list for ( const prop of Object . keys ( f )) { if ( typeof f [ prop ] === 'boolean' && f [ prop ]) { out . properties . push ( prop ) } } // Append model reference if any if ( f . model ) { out . reference = f . model . names . snake ; } return out ; }) }; }); return JSON . stringify ( _output , null , 4 ); Sortie [ { \"collection\" : \"bookmark\" , \"dependencies\" : [ \"user\" , \"place\" ], \"fields\" : [ { \"name\" : \"_id\" , \"notes\" : null , \"type\" : \"string\" , \"subtype\" : null , \"properties\" : [ \"primary\" , \"internal\" ] }, { \"name\" : \"created_at\" , \"notes\" : null , \"type\" : \"datetime\" , \"subtype\" : null , \"properties\" : [ \"sortable\" , \"internal\" ] }, { \"name\" : \"owner\" , \"notes\" : \"Current user when creating the bookmark\" , \"type\" : \"entity\" , \"subtype\" : null , \"properties\" : [ \"unique\" , \"searchable\" , \"internal\" , \"ownership\" ], \"reference\" : \"user\" }, { \"name\" : \"place\" , \"notes\" : null , \"type\" : \"entity\" , \"subtype\" : null , \"properties\" : [ \"unique\" , \"searchable\" ], \"reference\" : \"place\" } ] } ]","title":"G\u00e9n\u00e9rer une description du mod\u00e8le de donn\u00e9es en JSON"},{"location":"getting-started/installation/","text":"Installer le CLI La premi\u00e8re \u00e9tape consiste \u00e0 installer le CLI en utilisant NPM : npm install -g @hapify/cli Vous pouvez \u00e9galement v\u00e9rifier si le paquet est install\u00e9 en ex\u00e9cutant : hpf --version . Facultatif : Connecter le CLI \u00e0 Hapify Cloud Le CLI Hapify peut interagir avec Hapify Cloud afin de stocker vos projets et leurs mod\u00e8les. Pour cela, vous devez obtenir une cl\u00e9 API de Hapify Cloud. 1. S'inscrire sur Hapify Cloud Si vous n'avez pas encore de compte, veuillez consulter le site hapify.io/sign-up . 2. Obtenez votre cl\u00e9 API Une fois inscrit, ou si vous avez d\u00e9j\u00e0 un compte, allez sur hapify.io/mykey et copiez votre cl\u00e9 API. 3. Configurer le CLI Ex\u00e9cutez cette commande avec votre propre cl\u00e9 API pour connecter le CLI \u00e0 Hapify Cloud. hpf key XXXXXXXXXXXX Votre CLI peut maintenant interagir avec Hapify Cloud.","title":"Installation"},{"location":"getting-started/installation/#installer-le-cli","text":"La premi\u00e8re \u00e9tape consiste \u00e0 installer le CLI en utilisant NPM : npm install -g @hapify/cli Vous pouvez \u00e9galement v\u00e9rifier si le paquet est install\u00e9 en ex\u00e9cutant : hpf --version .","title":"Installer le CLI"},{"location":"getting-started/installation/#facultatif-connecter-le-cli-a-hapify-cloud","text":"Le CLI Hapify peut interagir avec Hapify Cloud afin de stocker vos projets et leurs mod\u00e8les. Pour cela, vous devez obtenir une cl\u00e9 API de Hapify Cloud.","title":"Facultatif : Connecter le CLI \u00e0 Hapify Cloud"},{"location":"getting-started/installation/#1-sinscrire-sur-hapify-cloud","text":"Si vous n'avez pas encore de compte, veuillez consulter le site hapify.io/sign-up .","title":"1. S'inscrire sur Hapify Cloud"},{"location":"getting-started/installation/#2-obtenez-votre-cle-api","text":"Une fois inscrit, ou si vous avez d\u00e9j\u00e0 un compte, allez sur hapify.io/mykey et copiez votre cl\u00e9 API.","title":"2. Obtenez votre cl\u00e9 API"},{"location":"getting-started/installation/#3-configurer-le-cli","text":"Ex\u00e9cutez cette commande avec votre propre cl\u00e9 API pour connecter le CLI \u00e0 Hapify Cloud. hpf key XXXXXXXXXXXX Votre CLI peut maintenant interagir avec Hapify Cloud.","title":"3. Configurer le CLI"},{"location":"getting-started/terminology/","text":"Hapify utilise des termes sp\u00e9cifiques pour d\u00e9crire ses concepts. boilerplate : Un boilerplate est une base d'application. C'est en partant de celui-ci que vous allez b\u00e2tir une nouvelle application. Il est compos\u00e9 de fichiers statiques et de fichiers dynamiques. fichier dynamique : Fichier qui est g\u00e9n\u00e9r\u00e9 par Hapify via un template et des mod\u00e8les de donn\u00e9es. fichier statique : Tout autre fichier qui n'est pas g\u00e9n\u00e9r\u00e9 : Exemple: fichiers Docker, fichiers CSS, biblioth\u00e8ques, plugins, etc. template : Fichier contenant un m\u00e9ta-code permettant de g\u00e9n\u00e9rer du code cible. Il existe plusieurs moteurs de templates, chacun pouvant interpr\u00e9ter un m\u00e9ta-code diff\u00e9rent. channel : Ensemble de templates. La plupart des boilerplates n'ont qu'un seul channel. Cependant, un boilerplate full-stack peut contenir deux channels, un pour les templates du front-end et un pour ceux du back-end. mod\u00e8le : Mod\u00e8le de donn\u00e9e relationnel d\u00e9crivant les sp\u00e9cifications d'un projet. champ : Entr\u00e9e d'un mod\u00e8le de donn\u00e9es. type de champ : Propri\u00e9t\u00e9 d'un champ d\u00e9crivant son type de donn\u00e9es. Exemple: texte, bool\u00e9en, nombre, etc. attribut de champ : Propri\u00e9t\u00e9 d'un champ d\u00e9crivant son comportement. Exemple: recherchable, masqu\u00e9, etc. projet : Application d\u00e9finie par une liste de mod\u00e8les de donn\u00e9es. code cible : Code source g\u00e9n\u00e9r\u00e9 par la rencontre d'un template et d'un ou plusieurs mod\u00e8les de donn\u00e9es. C'est le code source utilis\u00e9 par l'application finale. m\u00e9ta-code : Code source du template. Ce code va d\u00e9crire comment g\u00e9n\u00e9rer le code cible \u00e0 partir d'un ou plusieurs mod\u00e8les de donn\u00e9es. presets : Collections de mod\u00e8les de donn\u00e9es pr\u00e9d\u00e9finies pouvant \u00eatre import\u00e9es au d\u00e9marrage d'un projet.","title":"Terminologie"},{"location":"getting-started/troubleshooting/","text":"Lors de l'utilisation du CLI/GUI Hapify, vous pouvez rencontrer certaines erreurs lors de la g\u00e9n\u00e9ration du code, de l'\u00e9dition des templates ou des mod\u00e8les et de la gestion des projets. Ce guide \u00e9num\u00e8re toutes les erreurs connues afin de vous aider \u00e0 les r\u00e9soudre. Si vous trouvez une erreur inconnue, veuillez nous contacter : hapify.io/contact . Erreurs envoy\u00e9es par la syntaxe Hapify Plage d'erreurs : 1000 \u00e0 1999 1001 (SyntaxInternalError) : \u00c9mise lorsqu'une erreur inattendue est d\u00e9clench\u00e9e. 1002 (SyntaxArgumentsError) : \u00c9mise lorsque la fonction \"run\" est appel\u00e9e avec des arguments erron\u00e9s. 1003 (SyntaxParsingError) : \u00c9mise lorsque le template Hpf comporte une erreur de syntaxe. 1004 (SyntaxEvaluationError) : \u00c9mise lorsque l'\u00e9valuation du template Hpf provoque une erreur. 1005 (SyntaxTimeoutError) : \u00c9mise lorsque le template Hpf est trop long \u00e0 traiter. Erreurs envoy\u00e9es par le g\u00e9n\u00e9rateur Hapify Fourchette d'erreurs : 2000 \u00e0 2999 2001 (GeneratorInternalError) : \u00c9mise lorsqu'une erreur inattendue est d\u00e9clench\u00e9e. 2002 (GeneratorRequestError) : \u00c9mise lorsque les routes sont appel\u00e9es avec des arguments erron\u00e9s. 2003 (GeneratorRouteError) : \u00c9mise lorsqu'une erreur se produit pendant le traitement d'une requ\u00eate (statut >= 401). 2004 (GeneratorEvaluationError) : \u00c9mise lorsque l'\u00e9valuation du template JS provoque une erreur. 2005 (GeneratorTimeoutError) : \u00c9mise lorsque le template JS est trop long \u00e0 traiter. Erreurs envoy\u00e9es par l'API Hapify Plage d'erreurs : 3000 \u00e0 3999 Erreurs g\u00e9n\u00e9riques 3001 (ApiInternalError) : \u00c9mise lorsqu'une erreur inattendue est d\u00e9clench\u00e9e. 3002 (ApiError) : \u00c9mise lorsqu'une route d\u00e9clenche une erreur qui ne peut \u00eatre sp\u00e9cifi\u00e9e. 3003 (ApiRequestError) : \u00c9mise lorsqu'une route est appel\u00e9e avec des arguments erron\u00e9s. 3010 (ApiAuthenticationError) : \u00c9mise lorsqu'il y a eu un probl\u00e8me d'authentification. 3020 (ApiPlanError) : \u00c9mise lorsque la ressource a atteint la limite de l'abonnement. 3030 (ApiForbiddenError) : \u00c9mise lorsque l'acc\u00e8s \u00e0 la ressource est interdit. 3040 (ApiNotFoundError) : \u00c9mise lorsque la ressource n'est pas trouv\u00e9e. 3090 (ApiDuplicateError) : \u00c9mise lorsque la ressource existe d\u00e9j\u00e0. 3220 (ApiDataError) : \u00c9mise lorsque les donn\u00e9es \u00e0 traiter sont malform\u00e9es. 3290 (ApiRateError) : \u00c9mise lorsque trop de requ\u00eates ont \u00e9t\u00e9 effectu\u00e9es. Erreurs du g\u00e9n\u00e9rateur 3021 (ApiGeneratorPlanError) : \u00c9mise lorsqu'une limite sur les mod\u00e8les, les champs ou les templates est atteinte. 3031 (ApiGeneratorForbiddenError) : \u00c9mise lorsque l'acc\u00e8s \u00e0 un projet ou \u00e0 un mod\u00e8le est interdit. 3041 (ApiGeneratorNotFoundError) : \u00c9mise lorsqu'un projet ou un mod\u00e8le n'existe pas. 3221 (ApiGeneratorDataError) : \u00c9mise lorsqu'il n'y a pas de mod\u00e8le attach\u00e9 \u00e0 ce projet. 3291 (ApiGeneratorRateError) : \u00c9mise lorsque trop de demandes ont \u00e9t\u00e9 faites au g\u00e9n\u00e9rateur. Erreurs de mod\u00e8le 3032 (ApiModelForbiddenError) : \u00c9mise lorsque l'acc\u00e8s au mod\u00e8le est interdit. 3042 (ApiModelNotFoundError) : \u00c9mise lorsque le projet ou le mod\u00e8le n'existe pas. Erreurs de projet 3023 (ApiProjectPlanError) : \u00c9mise lorsque l'utilisateur a d\u00e9j\u00e0 atteint la limite de son projet. 3033 (ApiProjectForbiddenError) : \u00c9mise lorsque l'acc\u00e8s au projet est interdit. 3043 (ApiProjectNotFoundError) : \u00c9mise lorsque le projet n'existe pas. Erreurs envoy\u00e9es par le CLI Hapify Plage d'erreurs : 4000 \u00e0 4999 4001 (CliInternalError) : \u00c9mise lorsqu'une erreur inattendue est d\u00e9clench\u00e9e. 4002 (CliMessageValidationError) : \u00c9mise lorsqu'un message entrant provenant de la console web est malform\u00e9. 4003 (CliDataValidationError) : \u00c9mise lorsque les donn\u00e9es envoy\u00e9es par la console web sont malform\u00e9es. 4004 (CliUnknownMessageError) : \u00c9mise lorsque l'ID du message entrant est inconnu. 4005 (CliValidatorEvaluationError) : \u00c9mise lorsque l'\u00e9valuation du validateur JS provoque une erreur. 4006 (CliValidatorTimeoutError) : \u00c9mise lorsque le validateur JS est trop long \u00e0 traiter. 4007 (CliValidatorOutputError) : \u00c9mise lorsque le validateur JS renvoie des donn\u00e9es malform\u00e9es. Erreurs envoy\u00e9es par l'interface graphique de Hapify Plage d'erreurs : 5000 \u00e0 5999 5001 (ConsoleInternalError) : \u00c9mise lorsqu'une erreur inattendue est d\u00e9clench\u00e9e. 5002 (ConsoleWebSocketError) : \u00c9mise lorsqu'une erreur est survenue avec le client WebSocket. 5003 (ConsoleWebSocketTimeoutError) : \u00c9mise lorsqu'un d\u00e9lai d'attente est d\u00e9clench\u00e9 lors d'un appel au serveur WebSocket. 5004 (ConsoleWebSocketFetchError) : \u00c9mise lorsqu'il est impossible d'obtenir des informations de connexion pour le serveur WebSocket. 5005 (ConsoleWebSocketConnectionError) : \u00c9mise lorsque la connexion au serveur WebSocket est perdue. 5006 (ConsoleWebSocketResponseError) : \u00c9mise lorsqu'une erreur inconnue est renvoy\u00e9e par le client WebSocket. Erreurs envoy\u00e9es par la VM Hapify Plage d'erreurs : 6000 \u00e0 6999 6001 (VmOutputError) : \u00c9mise lorsque le script ne renvoie pas de cha\u00eene de caract\u00e8res ou est ind\u00e9fini. 6002 (VmEvaluationError) : \u00c9mise lorsque l'\u00e9valuation du script JS provoque une erreur. 6003 (VmTimeoutError) : \u00c9mise lorsque le script JS est trop long \u00e0 traiter. 6004 (VmIntegrityError) : \u00c9mise lorsque le script lance une erreur modifi\u00e9e. Erreurs envoy\u00e9es par le g\u00e9n\u00e9rateur EJS Plage d'erreurs : 7000 \u00e0 7999 7001 (EjsEvaluationError) : \u00c9mise lorsque l'\u00e9valuation du template EJS provoque une erreur.","title":"D\u00e9pannage"},{"location":"getting-started/troubleshooting/#erreurs-envoyees-par-la-syntaxe-hapify","text":"Plage d'erreurs : 1000 \u00e0 1999 1001 (SyntaxInternalError) : \u00c9mise lorsqu'une erreur inattendue est d\u00e9clench\u00e9e. 1002 (SyntaxArgumentsError) : \u00c9mise lorsque la fonction \"run\" est appel\u00e9e avec des arguments erron\u00e9s. 1003 (SyntaxParsingError) : \u00c9mise lorsque le template Hpf comporte une erreur de syntaxe. 1004 (SyntaxEvaluationError) : \u00c9mise lorsque l'\u00e9valuation du template Hpf provoque une erreur. 1005 (SyntaxTimeoutError) : \u00c9mise lorsque le template Hpf est trop long \u00e0 traiter.","title":"Erreurs envoy\u00e9es par la syntaxe Hapify"},{"location":"getting-started/troubleshooting/#erreurs-envoyees-par-le-generateur-hapify","text":"Fourchette d'erreurs : 2000 \u00e0 2999 2001 (GeneratorInternalError) : \u00c9mise lorsqu'une erreur inattendue est d\u00e9clench\u00e9e. 2002 (GeneratorRequestError) : \u00c9mise lorsque les routes sont appel\u00e9es avec des arguments erron\u00e9s. 2003 (GeneratorRouteError) : \u00c9mise lorsqu'une erreur se produit pendant le traitement d'une requ\u00eate (statut >= 401). 2004 (GeneratorEvaluationError) : \u00c9mise lorsque l'\u00e9valuation du template JS provoque une erreur. 2005 (GeneratorTimeoutError) : \u00c9mise lorsque le template JS est trop long \u00e0 traiter.","title":"Erreurs envoy\u00e9es par le g\u00e9n\u00e9rateur Hapify"},{"location":"getting-started/troubleshooting/#erreurs-envoyees-par-lapi-hapify","text":"Plage d'erreurs : 3000 \u00e0 3999","title":"Erreurs envoy\u00e9es par l'API Hapify"},{"location":"getting-started/troubleshooting/#erreurs-generiques","text":"3001 (ApiInternalError) : \u00c9mise lorsqu'une erreur inattendue est d\u00e9clench\u00e9e. 3002 (ApiError) : \u00c9mise lorsqu'une route d\u00e9clenche une erreur qui ne peut \u00eatre sp\u00e9cifi\u00e9e. 3003 (ApiRequestError) : \u00c9mise lorsqu'une route est appel\u00e9e avec des arguments erron\u00e9s. 3010 (ApiAuthenticationError) : \u00c9mise lorsqu'il y a eu un probl\u00e8me d'authentification. 3020 (ApiPlanError) : \u00c9mise lorsque la ressource a atteint la limite de l'abonnement. 3030 (ApiForbiddenError) : \u00c9mise lorsque l'acc\u00e8s \u00e0 la ressource est interdit. 3040 (ApiNotFoundError) : \u00c9mise lorsque la ressource n'est pas trouv\u00e9e. 3090 (ApiDuplicateError) : \u00c9mise lorsque la ressource existe d\u00e9j\u00e0. 3220 (ApiDataError) : \u00c9mise lorsque les donn\u00e9es \u00e0 traiter sont malform\u00e9es. 3290 (ApiRateError) : \u00c9mise lorsque trop de requ\u00eates ont \u00e9t\u00e9 effectu\u00e9es.","title":"Erreurs g\u00e9n\u00e9riques"},{"location":"getting-started/troubleshooting/#erreurs-du-generateur","text":"3021 (ApiGeneratorPlanError) : \u00c9mise lorsqu'une limite sur les mod\u00e8les, les champs ou les templates est atteinte. 3031 (ApiGeneratorForbiddenError) : \u00c9mise lorsque l'acc\u00e8s \u00e0 un projet ou \u00e0 un mod\u00e8le est interdit. 3041 (ApiGeneratorNotFoundError) : \u00c9mise lorsqu'un projet ou un mod\u00e8le n'existe pas. 3221 (ApiGeneratorDataError) : \u00c9mise lorsqu'il n'y a pas de mod\u00e8le attach\u00e9 \u00e0 ce projet. 3291 (ApiGeneratorRateError) : \u00c9mise lorsque trop de demandes ont \u00e9t\u00e9 faites au g\u00e9n\u00e9rateur.","title":"Erreurs du g\u00e9n\u00e9rateur"},{"location":"getting-started/troubleshooting/#erreurs-de-modele","text":"3032 (ApiModelForbiddenError) : \u00c9mise lorsque l'acc\u00e8s au mod\u00e8le est interdit. 3042 (ApiModelNotFoundError) : \u00c9mise lorsque le projet ou le mod\u00e8le n'existe pas.","title":"Erreurs de mod\u00e8le"},{"location":"getting-started/troubleshooting/#erreurs-de-projet","text":"3023 (ApiProjectPlanError) : \u00c9mise lorsque l'utilisateur a d\u00e9j\u00e0 atteint la limite de son projet. 3033 (ApiProjectForbiddenError) : \u00c9mise lorsque l'acc\u00e8s au projet est interdit. 3043 (ApiProjectNotFoundError) : \u00c9mise lorsque le projet n'existe pas.","title":"Erreurs de projet"},{"location":"getting-started/troubleshooting/#erreurs-envoyees-par-le-cli-hapify","text":"Plage d'erreurs : 4000 \u00e0 4999 4001 (CliInternalError) : \u00c9mise lorsqu'une erreur inattendue est d\u00e9clench\u00e9e. 4002 (CliMessageValidationError) : \u00c9mise lorsqu'un message entrant provenant de la console web est malform\u00e9. 4003 (CliDataValidationError) : \u00c9mise lorsque les donn\u00e9es envoy\u00e9es par la console web sont malform\u00e9es. 4004 (CliUnknownMessageError) : \u00c9mise lorsque l'ID du message entrant est inconnu. 4005 (CliValidatorEvaluationError) : \u00c9mise lorsque l'\u00e9valuation du validateur JS provoque une erreur. 4006 (CliValidatorTimeoutError) : \u00c9mise lorsque le validateur JS est trop long \u00e0 traiter. 4007 (CliValidatorOutputError) : \u00c9mise lorsque le validateur JS renvoie des donn\u00e9es malform\u00e9es.","title":"Erreurs envoy\u00e9es par le CLI Hapify"},{"location":"getting-started/troubleshooting/#erreurs-envoyees-par-linterface-graphique-de-hapify","text":"Plage d'erreurs : 5000 \u00e0 5999 5001 (ConsoleInternalError) : \u00c9mise lorsqu'une erreur inattendue est d\u00e9clench\u00e9e. 5002 (ConsoleWebSocketError) : \u00c9mise lorsqu'une erreur est survenue avec le client WebSocket. 5003 (ConsoleWebSocketTimeoutError) : \u00c9mise lorsqu'un d\u00e9lai d'attente est d\u00e9clench\u00e9 lors d'un appel au serveur WebSocket. 5004 (ConsoleWebSocketFetchError) : \u00c9mise lorsqu'il est impossible d'obtenir des informations de connexion pour le serveur WebSocket. 5005 (ConsoleWebSocketConnectionError) : \u00c9mise lorsque la connexion au serveur WebSocket est perdue. 5006 (ConsoleWebSocketResponseError) : \u00c9mise lorsqu'une erreur inconnue est renvoy\u00e9e par le client WebSocket.","title":"Erreurs envoy\u00e9es par l'interface graphique de Hapify"},{"location":"getting-started/troubleshooting/#erreurs-envoyees-par-la-vm-hapify","text":"Plage d'erreurs : 6000 \u00e0 6999 6001 (VmOutputError) : \u00c9mise lorsque le script ne renvoie pas de cha\u00eene de caract\u00e8res ou est ind\u00e9fini. 6002 (VmEvaluationError) : \u00c9mise lorsque l'\u00e9valuation du script JS provoque une erreur. 6003 (VmTimeoutError) : \u00c9mise lorsque le script JS est trop long \u00e0 traiter. 6004 (VmIntegrityError) : \u00c9mise lorsque le script lance une erreur modifi\u00e9e.","title":"Erreurs envoy\u00e9es par la VM Hapify"},{"location":"getting-started/troubleshooting/#erreurs-envoyees-par-le-generateur-ejs","text":"Plage d'erreurs : 7000 \u00e0 7999 7001 (EjsEvaluationError) : \u00c9mise lorsque l'\u00e9valuation du template EJS provoque une erreur.","title":"Erreurs envoy\u00e9es par le g\u00e9n\u00e9rateur EJS"},{"location":"getting-started/concepts/key-concepts/","text":"Hapify automatise l'\u00e9criture des op\u00e9rations CRUD, tant pour le d\u00e9veloppement back-end que front-end. Concentrez-vous uniquement sur les fonctionnalit\u00e9s m\u00e9tiers au lieu de faire du travail r\u00e9p\u00e9titif ! Hapify est un g\u00e9n\u00e9rateur de code agnostique permettant la cr\u00e9ation de tout type d'application manipulant des mod\u00e8les de donn\u00e9es, dans n'importe quel langage. Hapify n'impose aucun paradigme ou structure de code. Vous pouvez \u00e9crire vos propres templates de code ou utiliser ceux fournis par la communaut\u00e9. Hapify utilise deux entr\u00e9es : mod\u00e8les de donn\u00e9es et les templates de code . Templates Hapify fournit une syntaxe simple mais puissante pour vous aider \u00e0 cr\u00e9er des templates dynamiques. Avec Hapify, vous pouvez soit : Convertir vos propres boilerplates en boilerplates dynamiques. Utilisez des boilerplates fournis par la communaut\u00e9 Voir aussi Pour plus d'informations sur les moteurs de template, vous pouvez consulter la documentation de la syntaxe Hapify et celle des templates EJS et JavaScript . Mod\u00e9lisation Hapify vous permet de d\u00e9finir les mod\u00e8les de donn\u00e9es qui correspondent aux sp\u00e9cifications de votre projet. La d\u00e9finition du mod\u00e8le dans Hapify est agnostique et comportementales , ce qui signifie que Hapify d\u00e9finit ce que le mod\u00e8le de donn\u00e9es doit faire , et non pas comment il le fera . Les mod\u00e8les de donn\u00e9es sont g\u00e9r\u00e9s dans une console Web locale. \u00c0 savoir Vous pouvez importer des mod\u00e8les de donn\u00e9es fournis dans Hapify Hub . Voir aussi Pour plus d'informations sur les mod\u00e8les de donn\u00e9es, vous pouvez vous r\u00e9f\u00e9rer ici . Hapify Boilerplate Un boilerplate Hapify typique est divis\u00e9e en deux parties : Les fichiers dynamiques : Fichiers des templates Hapify, compatibles avec les mod\u00e8les de donn\u00e9es Hapify et le moteur Hapify. Fichiers statiques : Tous les autres fichiers, qui ne sont pas li\u00e9s aux mod\u00e8les de donn\u00e9es : Fichiers Docker, fichiers CSS, biblioth\u00e8ques, plugins, etc. Channel Un channel est un ensemble de templates. La plupart des boilerplates n'ont qu'un seul channel. Cependant, un boilerplate full-stack peut contenir deux channels, un pour les templates du front-end et un pour ceux du back-end par exemple.","title":"Concepts cl\u00e9s"},{"location":"getting-started/concepts/key-concepts/#templates","text":"Hapify fournit une syntaxe simple mais puissante pour vous aider \u00e0 cr\u00e9er des templates dynamiques. Avec Hapify, vous pouvez soit : Convertir vos propres boilerplates en boilerplates dynamiques. Utilisez des boilerplates fournis par la communaut\u00e9 Voir aussi Pour plus d'informations sur les moteurs de template, vous pouvez consulter la documentation de la syntaxe Hapify et celle des templates EJS et JavaScript .","title":"Templates"},{"location":"getting-started/concepts/key-concepts/#modelisation","text":"Hapify vous permet de d\u00e9finir les mod\u00e8les de donn\u00e9es qui correspondent aux sp\u00e9cifications de votre projet. La d\u00e9finition du mod\u00e8le dans Hapify est agnostique et comportementales , ce qui signifie que Hapify d\u00e9finit ce que le mod\u00e8le de donn\u00e9es doit faire , et non pas comment il le fera . Les mod\u00e8les de donn\u00e9es sont g\u00e9r\u00e9s dans une console Web locale. \u00c0 savoir Vous pouvez importer des mod\u00e8les de donn\u00e9es fournis dans Hapify Hub . Voir aussi Pour plus d'informations sur les mod\u00e8les de donn\u00e9es, vous pouvez vous r\u00e9f\u00e9rer ici .","title":"Mod\u00e9lisation"},{"location":"getting-started/concepts/key-concepts/#hapify-boilerplate","text":"Un boilerplate Hapify typique est divis\u00e9e en deux parties : Les fichiers dynamiques : Fichiers des templates Hapify, compatibles avec les mod\u00e8les de donn\u00e9es Hapify et le moteur Hapify. Fichiers statiques : Tous les autres fichiers, qui ne sont pas li\u00e9s aux mod\u00e8les de donn\u00e9es : Fichiers Docker, fichiers CSS, biblioth\u00e8ques, plugins, etc.","title":"Hapify Boilerplate"},{"location":"getting-started/concepts/key-concepts/#channel","text":"Un channel est un ensemble de templates. La plupart des boilerplates n'ont qu'un seul channel. Cependant, un boilerplate full-stack peut contenir deux channels, un pour les templates du front-end et un pour ceux du back-end par exemple.","title":"Channel"},{"location":"getting-started/concepts/models/","text":"Approche de mod\u00e9lisation La d\u00e9finition du mod\u00e8le dans Hapify est agnostique et comportementales . Ce qui signifie que Hapify d\u00e9finit ce que le mod\u00e8le doit faire , et non pas comment il le fera . Gestion des acc\u00e8s Hapify prend en charge ces 6 actions de base : Create Read Update Delete Search Count Pour chacune de ces op\u00e9rations, Hapify vous permet de d\u00e9finir les restrictions d'acc\u00e8s suivantes : Guest : utilisateur qui n'est pas connect\u00e9. Authenticated : utilisateur connect\u00e9. Owner : utilisateur connect\u00e9 qui est propri\u00e9taire de l'entit\u00e9 (voir Attributs de champ pour plus de d\u00e9tails). Admin : utilisateur super-admin connect\u00e9. Les acc\u00e8s sont inclusifs, ce qui signifie que la restriction Authenticated inclut n\u00e9cessairement Owner et Admin . Guest est le plus permissif et Admin le moins permissif. Par cons\u00e9quent Admin < Owner < Authenticated < Guest . Champs Un mod\u00e8le contient une liste de champs. Chaque champ est d\u00e9fini par : un nom un type un sous-type (facultatif) un ensemble d'attributs (comportementaux). Types et sous-types Les types et sous-types disponibles sont : string email , password , url , text , rich number integer , float , latitude , longitude boolean datetime date , time enum entity (r\u00e9f\u00e9rence \u00e0 un autre mod\u00e8le) oneOne , oneMany , manyOne , manyMany object file image , video , audio , document Attributs de champ Primary : le champ est la cl\u00e9 primaire. Unique : le champ contient des valeurs uniques, n\u00e9cessaires pour \u00e9viter les doublons. Un mod\u00e8le peut avoir plusieurs cl\u00e9s uniques. (par exemple : le courriel de l'utilisateur ou le code du coupon). Label : le champ est un identifiant lisible. (par exemple : nom et pr\u00e9nom de l'utilisateur, un titre de film). Nullable : le champ peut contenir une valeur vide. En d'autres termes, il n'est pas obligatoire. Multiple : ce champ contiendra une liste de valeurs ou de r\u00e9f\u00e9rences. Embedded : possibilit\u00e9 d'imbriquer des donn\u00e9es provenant d'une entit\u00e9 li\u00e9e. Cela peut \u00eatre utilis\u00e9 pour imbriquer les formulaires par exemple. Searchable : possibilit\u00e9 d'effectuer des recherches via ce champ. Sortable : possibilit\u00e9 de trier les r\u00e9sultats de recherche en fonction de ce champ. Hidden : ce champ ne doit jamais \u00eatre envoy\u00e9 \u00e0 l'utilisateur final. (par exemple : le mot de passe de l'utilisateur). Internal : valeur d\u00e9finie en interne par le syst\u00e8me, que l'utilisateur final ne peut pas d\u00e9finir (ex. : date de cr\u00e9ation de l'entit\u00e9, cl\u00e9 primaire, etc.). Restricted : d\u00e9fini si l'acc\u00e8s aux donn\u00e9es (lecture et/ou \u00e9criture) est limit\u00e9 \u00e0 des utilisateurs sp\u00e9cifiques (par exemple : le statut validated peut \u00eatre d\u00e9fini par un administrateur uniquement). Ownership : d\u00e9finit l'identit\u00e9 du ou des propri\u00e9taires de l'entit\u00e9 (par exemple : le champ owner d'un \u00e9tablissement contenant l'ID de l'utilisateur). Voir aussi Pour conna\u00eetre la structure compl\u00e8te des mod\u00e8les de donn\u00e9es, vous pouvez vous r\u00e9f\u00e9rer \u00e0 cette documentation .","title":"Mod\u00e8les de donn\u00e9es"},{"location":"getting-started/concepts/models/#approche-de-modelisation","text":"La d\u00e9finition du mod\u00e8le dans Hapify est agnostique et comportementales . Ce qui signifie que Hapify d\u00e9finit ce que le mod\u00e8le doit faire , et non pas comment il le fera .","title":"Approche de mod\u00e9lisation"},{"location":"getting-started/concepts/models/#gestion-des-acces","text":"Hapify prend en charge ces 6 actions de base : Create Read Update Delete Search Count Pour chacune de ces op\u00e9rations, Hapify vous permet de d\u00e9finir les restrictions d'acc\u00e8s suivantes : Guest : utilisateur qui n'est pas connect\u00e9. Authenticated : utilisateur connect\u00e9. Owner : utilisateur connect\u00e9 qui est propri\u00e9taire de l'entit\u00e9 (voir Attributs de champ pour plus de d\u00e9tails). Admin : utilisateur super-admin connect\u00e9. Les acc\u00e8s sont inclusifs, ce qui signifie que la restriction Authenticated inclut n\u00e9cessairement Owner et Admin . Guest est le plus permissif et Admin le moins permissif. Par cons\u00e9quent Admin < Owner < Authenticated < Guest .","title":"Gestion des acc\u00e8s"},{"location":"getting-started/concepts/models/#champs","text":"Un mod\u00e8le contient une liste de champs. Chaque champ est d\u00e9fini par : un nom un type un sous-type (facultatif) un ensemble d'attributs (comportementaux).","title":"Champs"},{"location":"getting-started/concepts/models/#types-et-sous-types","text":"Les types et sous-types disponibles sont : string email , password , url , text , rich number integer , float , latitude , longitude boolean datetime date , time enum entity (r\u00e9f\u00e9rence \u00e0 un autre mod\u00e8le) oneOne , oneMany , manyOne , manyMany object file image , video , audio , document","title":"Types et sous-types"},{"location":"getting-started/concepts/models/#attributs-de-champ","text":"Primary : le champ est la cl\u00e9 primaire. Unique : le champ contient des valeurs uniques, n\u00e9cessaires pour \u00e9viter les doublons. Un mod\u00e8le peut avoir plusieurs cl\u00e9s uniques. (par exemple : le courriel de l'utilisateur ou le code du coupon). Label : le champ est un identifiant lisible. (par exemple : nom et pr\u00e9nom de l'utilisateur, un titre de film). Nullable : le champ peut contenir une valeur vide. En d'autres termes, il n'est pas obligatoire. Multiple : ce champ contiendra une liste de valeurs ou de r\u00e9f\u00e9rences. Embedded : possibilit\u00e9 d'imbriquer des donn\u00e9es provenant d'une entit\u00e9 li\u00e9e. Cela peut \u00eatre utilis\u00e9 pour imbriquer les formulaires par exemple. Searchable : possibilit\u00e9 d'effectuer des recherches via ce champ. Sortable : possibilit\u00e9 de trier les r\u00e9sultats de recherche en fonction de ce champ. Hidden : ce champ ne doit jamais \u00eatre envoy\u00e9 \u00e0 l'utilisateur final. (par exemple : le mot de passe de l'utilisateur). Internal : valeur d\u00e9finie en interne par le syst\u00e8me, que l'utilisateur final ne peut pas d\u00e9finir (ex. : date de cr\u00e9ation de l'entit\u00e9, cl\u00e9 primaire, etc.). Restricted : d\u00e9fini si l'acc\u00e8s aux donn\u00e9es (lecture et/ou \u00e9criture) est limit\u00e9 \u00e0 des utilisateurs sp\u00e9cifiques (par exemple : le statut validated peut \u00eatre d\u00e9fini par un administrateur uniquement). Ownership : d\u00e9finit l'identit\u00e9 du ou des propri\u00e9taires de l'entit\u00e9 (par exemple : le champ owner d'un \u00e9tablissement contenant l'ID de l'utilisateur). Voir aussi Pour conna\u00eetre la structure compl\u00e8te des mod\u00e8les de donn\u00e9es, vous pouvez vous r\u00e9f\u00e9rer \u00e0 cette documentation .","title":"Attributs de champ"},{"location":"getting-started/create-boilerplate/introduction/","text":"R\u00e9sum\u00e9 Dans cette section, vous apprendrez comment cr\u00e9er votre propre boilerplate avec Hapify. Vous pouvez d\u00e9marrer un boilerplate \u00e0 partir de z\u00e9ro ou utiliser un boilerplate pr\u00e9-existant. Cette section se concentre sur l'\u00e9criture de templates de code. Comme Hapify est un moteur agnostique et n'est pas limit\u00e9 \u00e0 un cadre sp\u00e9cifique, nous ne nous concentrerons pas sur la structure du boilerplate elle-m\u00eame. Nous \u00e9tudierons des exemples de templates courants. \u00c0 savoir Si votre boilerplate utilise npm ou yarn comme gestionnaire de paquets, vous pouvez ajouter le CLI comme d\u00e9pendance de d\u00e9veloppement : npm install --save-dev @hapify/cli . Ajoutez \u00e9galement un script dans package.json : \"hpf\": \"hpf\" . Ainsi vous pourrez d\u00e9finir une version d'Hapify pour votre boilerplate et l'utiliser avec npm run hpf . Moteurs de templates Hapify propose trois moteurs de templates. Un boilerplate peut utiliser plusieurs moteurs simultan\u00e9ment. Ces moteurs ont acc\u00e8s \u00e0 l' objet mod\u00e8le . Cet objet, inject\u00e9 dans les templates, explicite le mod\u00e8le de donn\u00e9es ainsi que toutes ses propri\u00e9t\u00e9s et relations, de sorte qu'elles soient facilement accessibles depuis le template. Moteur de template Hapify Cette syntaxe est optimis\u00e9e pour jouer avec l' objet mod\u00e8le et ses propri\u00e9t\u00e9s en utilisant des mots courts. Cela vous permet de g\u00e9rer des id\u00e9es complexes avec des phrases simples. Cette syntaxe a deux variantes : long : facile \u00e0 lire short : bas\u00e9 sur des abr\u00e9viations Les deux variantes peuvent \u00eatre utilis\u00e9es dans le m\u00eame template. Exemple Cette boucle en JavaScript : for ( let f of model . fields . list . filter ( f => f . searchable && f . type === 'entity' )) { out += 'Field name: ' + f . names . camel ; } Sera \u00e9crite comme ceci avec la syntaxe Hapify : Syntaxe longue <<for Fields searchable and entity f >> Field name: <<f camel>> <<endfor>> Syntaxe courte <<@ F se * tE f >> Field name: <<f aA>> <<@>> Pour Un m\u00e9ta-code facile \u00e0 lire Un m\u00e9ta-code plus court, rendant le code cible plus lisible Encore plus court avec la variante courte Contre Une autre syntaxe \u00e0 apprendre, bien qu'elle soit simple La syntaxe peut ne pas traiter certaines conditions sp\u00e9cifiques Moteur EJS Vous pouvez utiliser EJS comme moteur de template. Toutes les fonctionnalit\u00e9s d'EJS sont disponibles, sauf la fonctionnalit\u00e9 include . Cette fonction est volontairement d\u00e9sactiv\u00e9e afin que les templates n'aient pas acc\u00e8s \u00e0 votre syst\u00e8me de fichiers. Exemple Cette boucle en JavaScript : for ( let f of model . fields . list . filter ( f => f . searchable ) { out += 'Field name: ' + f . names . camel ; } Sera \u00e9crite comme ceci avec EJS : <% for ( let f of model . fields . list . filter ( f => f . searchable ) { %> Field name : <%= f . names . camel %> <% } %> Pour Un moteur de template connu G\u00e8re bien les conditions complexes et l'interpolation Plus de flexibilit\u00e9 Contre M\u00e9ta-code long, rendant le code cible moins lisible Moteur JavaScript Vous pouvez \u00e9crire des templates en JavaScript pur. Ce moteur est tr\u00e8s utile pour g\u00e9n\u00e9rer des fichiers JSON. Exemple const output = models . map (( model ) => model . names . snake ); return JSON . stringify ( output , null , 2 ); const property = ( field ) => `private ${ field . names . camel } ;` ; return `class ${ model . names . pascal } { ${ model . fields . list . map ( property ). join ( '\\n ' ) } }` ; Pour Puissant lors de la g\u00e9n\u00e9ration de fichiers de configuration tels que le JSON Tr\u00e8s flexible Contre Difficile de diff\u00e9rencier le m\u00e9ta-code du code cible.","title":"Introduction"},{"location":"getting-started/create-boilerplate/introduction/#resume","text":"Dans cette section, vous apprendrez comment cr\u00e9er votre propre boilerplate avec Hapify. Vous pouvez d\u00e9marrer un boilerplate \u00e0 partir de z\u00e9ro ou utiliser un boilerplate pr\u00e9-existant. Cette section se concentre sur l'\u00e9criture de templates de code. Comme Hapify est un moteur agnostique et n'est pas limit\u00e9 \u00e0 un cadre sp\u00e9cifique, nous ne nous concentrerons pas sur la structure du boilerplate elle-m\u00eame. Nous \u00e9tudierons des exemples de templates courants. \u00c0 savoir Si votre boilerplate utilise npm ou yarn comme gestionnaire de paquets, vous pouvez ajouter le CLI comme d\u00e9pendance de d\u00e9veloppement : npm install --save-dev @hapify/cli . Ajoutez \u00e9galement un script dans package.json : \"hpf\": \"hpf\" . Ainsi vous pourrez d\u00e9finir une version d'Hapify pour votre boilerplate et l'utiliser avec npm run hpf .","title":"R\u00e9sum\u00e9"},{"location":"getting-started/create-boilerplate/introduction/#moteurs-de-templates","text":"Hapify propose trois moteurs de templates. Un boilerplate peut utiliser plusieurs moteurs simultan\u00e9ment. Ces moteurs ont acc\u00e8s \u00e0 l' objet mod\u00e8le . Cet objet, inject\u00e9 dans les templates, explicite le mod\u00e8le de donn\u00e9es ainsi que toutes ses propri\u00e9t\u00e9s et relations, de sorte qu'elles soient facilement accessibles depuis le template.","title":"Moteurs de templates"},{"location":"getting-started/create-boilerplate/introduction/#moteur-de-template-hapify","text":"Cette syntaxe est optimis\u00e9e pour jouer avec l' objet mod\u00e8le et ses propri\u00e9t\u00e9s en utilisant des mots courts. Cela vous permet de g\u00e9rer des id\u00e9es complexes avec des phrases simples. Cette syntaxe a deux variantes : long : facile \u00e0 lire short : bas\u00e9 sur des abr\u00e9viations Les deux variantes peuvent \u00eatre utilis\u00e9es dans le m\u00eame template.","title":"Moteur de template Hapify"},{"location":"getting-started/create-boilerplate/introduction/#exemple","text":"Cette boucle en JavaScript : for ( let f of model . fields . list . filter ( f => f . searchable && f . type === 'entity' )) { out += 'Field name: ' + f . names . camel ; } Sera \u00e9crite comme ceci avec la syntaxe Hapify : Syntaxe longue <<for Fields searchable and entity f >> Field name: <<f camel>> <<endfor>> Syntaxe courte <<@ F se * tE f >> Field name: <<f aA>> <<@>> Pour Un m\u00e9ta-code facile \u00e0 lire Un m\u00e9ta-code plus court, rendant le code cible plus lisible Encore plus court avec la variante courte Contre Une autre syntaxe \u00e0 apprendre, bien qu'elle soit simple La syntaxe peut ne pas traiter certaines conditions sp\u00e9cifiques","title":"Exemple"},{"location":"getting-started/create-boilerplate/introduction/#moteur-ejs","text":"Vous pouvez utiliser EJS comme moteur de template. Toutes les fonctionnalit\u00e9s d'EJS sont disponibles, sauf la fonctionnalit\u00e9 include . Cette fonction est volontairement d\u00e9sactiv\u00e9e afin que les templates n'aient pas acc\u00e8s \u00e0 votre syst\u00e8me de fichiers.","title":"Moteur EJS"},{"location":"getting-started/create-boilerplate/introduction/#exemple_1","text":"Cette boucle en JavaScript : for ( let f of model . fields . list . filter ( f => f . searchable ) { out += 'Field name: ' + f . names . camel ; } Sera \u00e9crite comme ceci avec EJS : <% for ( let f of model . fields . list . filter ( f => f . searchable ) { %> Field name : <%= f . names . camel %> <% } %> Pour Un moteur de template connu G\u00e8re bien les conditions complexes et l'interpolation Plus de flexibilit\u00e9 Contre M\u00e9ta-code long, rendant le code cible moins lisible","title":"Exemple"},{"location":"getting-started/create-boilerplate/introduction/#moteur-javascript","text":"Vous pouvez \u00e9crire des templates en JavaScript pur. Ce moteur est tr\u00e8s utile pour g\u00e9n\u00e9rer des fichiers JSON.","title":"Moteur JavaScript"},{"location":"getting-started/create-boilerplate/introduction/#exemple_2","text":"const output = models . map (( model ) => model . names . snake ); return JSON . stringify ( output , null , 2 ); const property = ( field ) => `private ${ field . names . camel } ;` ; return `class ${ model . names . pascal } { ${ model . fields . list . map ( property ). join ( '\\n ' ) } }` ; Pour Puissant lors de la g\u00e9n\u00e9ration de fichiers de configuration tels que le JSON Tr\u00e8s flexible Contre Difficile de diff\u00e9rencier le m\u00e9ta-code du code cible.","title":"Exemple"},{"location":"getting-started/create-boilerplate/step-1-new-channel/","text":"Channel vs boilerplate ? Un channel est un ensemble de templates. La plupart des boilerplates n'ont qu'un seul channel. Cependant, un boilerplate full-stack peut contenir deux channels, un pour les templates du front-end et un pour ceux du back-end. Ex\u00e9cutez la commande init . Cr\u00e9ez un nouveau dossier pour votre projet et allez dans ce dossier : mkdir my-project && cd my-project \u00c0 savoir Vous pouvez \u00e9galement d\u00e9marrer un channel dans un boilerplate pr\u00e9-existant. Utilisez la commande init pour initialiser un channel dans ce dossier. hpf init Cr\u00e9er un projet Vous devez cr\u00e9er un nouveau projet afin de cr\u00e9er un nouveau channel. \u00c0 l'invite, entrez le nom et la description. ? Enter a project name First project ? Enter a project description My first project with Hapify Cr\u00e9er le channel Une fois le projet d\u00e9fini, entrez les d\u00e9tails du channel. ? Enter the channel name Typescript Backend ? Enter a description API for my app ? Enter a logo URL https://cdn.worldvectorlogo.com/logos/typescript.svg \u2713 Initialized a channel in /Users/edouard/workspace/hapify/my-project. Run hpf use to connect a remote project (optional) Voici la hi\u00e9rarchie des fichiers cr\u00e9\u00e9s : ~/my-project \u251c\u2500\u2500 .hapify | \u251c\u2500\u2500 models | | \u2514\u2500\u2500 __kebab__ | | \u2514\u2500\u2500 hello.js.hpf | \u2514\u2500\u2500 validator.js \u251c\u2500\u2500 hapify-models.json \u2514\u2500\u2500 hapify.json hapify.json est le fichier de configuration. Il contient les m\u00e9ta-donn\u00e9es du channel et la liste des templates. Le fichier hapify-models.json contient les mod\u00e8les de donn\u00e9es de votre projet. Il est r\u00e9f\u00e9renc\u00e9 par le fichier de configuration ( hapify.json ). Vous pouvez d\u00e9placer ou renommer ce fichier tant que vous changez le chemin dans le fichier de configuration. Le dossier .hapify (peut aussi \u00eatre nomm\u00e9 hapify ) contient tous les templates du channel.","title":"\u00c9tape 1: Nouveau channel"},{"location":"getting-started/create-boilerplate/step-1-new-channel/#executez-la-commande-init","text":"Cr\u00e9ez un nouveau dossier pour votre projet et allez dans ce dossier : mkdir my-project && cd my-project \u00c0 savoir Vous pouvez \u00e9galement d\u00e9marrer un channel dans un boilerplate pr\u00e9-existant. Utilisez la commande init pour initialiser un channel dans ce dossier. hpf init","title":"Ex\u00e9cutez la commande init."},{"location":"getting-started/create-boilerplate/step-1-new-channel/#creer-un-projet","text":"Vous devez cr\u00e9er un nouveau projet afin de cr\u00e9er un nouveau channel. \u00c0 l'invite, entrez le nom et la description. ? Enter a project name First project ? Enter a project description My first project with Hapify","title":"Cr\u00e9er un projet"},{"location":"getting-started/create-boilerplate/step-1-new-channel/#creer-le-channel","text":"Une fois le projet d\u00e9fini, entrez les d\u00e9tails du channel. ? Enter the channel name Typescript Backend ? Enter a description API for my app ? Enter a logo URL https://cdn.worldvectorlogo.com/logos/typescript.svg \u2713 Initialized a channel in /Users/edouard/workspace/hapify/my-project. Run hpf use to connect a remote project (optional) Voici la hi\u00e9rarchie des fichiers cr\u00e9\u00e9s : ~/my-project \u251c\u2500\u2500 .hapify | \u251c\u2500\u2500 models | | \u2514\u2500\u2500 __kebab__ | | \u2514\u2500\u2500 hello.js.hpf | \u2514\u2500\u2500 validator.js \u251c\u2500\u2500 hapify-models.json \u2514\u2500\u2500 hapify.json hapify.json est le fichier de configuration. Il contient les m\u00e9ta-donn\u00e9es du channel et la liste des templates. Le fichier hapify-models.json contient les mod\u00e8les de donn\u00e9es de votre projet. Il est r\u00e9f\u00e9renc\u00e9 par le fichier de configuration ( hapify.json ). Vous pouvez d\u00e9placer ou renommer ce fichier tant que vous changez le chemin dans le fichier de configuration. Le dossier .hapify (peut aussi \u00eatre nomm\u00e9 hapify ) contient tous les templates du channel.","title":"Cr\u00e9er le channel"},{"location":"getting-started/create-boilerplate/step-2-add-models/","text":"Ex\u00e9cutez la commande serve . \u00c0 ce stade, vous avez un channel vide et aucun mod\u00e8le de donn\u00e9es dans votre projet. Afin de cr\u00e9er un nouveau template, vous devez d'abord cr\u00e9er quelques mod\u00e8les de donn\u00e9es. Ex\u00e9cutez cette commande : hpf serve Ajouter des mod\u00e8les de donn\u00e9es Cr\u00e9ez ou importez des templates pour votre projet. Cette \u00e9tape est obligatoire pour l'\u00e9tape suivante afin de valider que vos templates fonctionnent. Nous vous recommandons d'ajouter les templates qui couvriront les cas d'utilisation que vous souhaitez traiter. Par exemple, si vous pr\u00e9voyez de traiter la latitude et la longitude dans vos templates, ajoutez alors au moins un mod\u00e8le de donn\u00e9es qui comporte ces champs. Un autre cas fr\u00e9quent est celui des relations entre les mod\u00e8les de donn\u00e9es. Nous vous recommandons d'ajouter plusieurs relations entre vos mod\u00e8les de donn\u00e9es, m\u00eame une relation d'auto-r\u00e9f\u00e9rence. Voir aussi Pour en savoir plus sur la gestion des mod\u00e8les de donn\u00e9es, veuillez vous r\u00e9f\u00e9rer \u00e0 \u00e9dition des mod\u00e8les de donn\u00e9es .","title":"\u00c9tape 2: Ajouter des mod\u00e8les de donn\u00e9es"},{"location":"getting-started/create-boilerplate/step-2-add-models/#executez-la-commande-serve","text":"\u00c0 ce stade, vous avez un channel vide et aucun mod\u00e8le de donn\u00e9es dans votre projet. Afin de cr\u00e9er un nouveau template, vous devez d'abord cr\u00e9er quelques mod\u00e8les de donn\u00e9es. Ex\u00e9cutez cette commande : hpf serve","title":"Ex\u00e9cutez la commande serve."},{"location":"getting-started/create-boilerplate/step-2-add-models/#ajouter-des-modeles-de-donnees","text":"Cr\u00e9ez ou importez des templates pour votre projet. Cette \u00e9tape est obligatoire pour l'\u00e9tape suivante afin de valider que vos templates fonctionnent. Nous vous recommandons d'ajouter les templates qui couvriront les cas d'utilisation que vous souhaitez traiter. Par exemple, si vous pr\u00e9voyez de traiter la latitude et la longitude dans vos templates, ajoutez alors au moins un mod\u00e8le de donn\u00e9es qui comporte ces champs. Un autre cas fr\u00e9quent est celui des relations entre les mod\u00e8les de donn\u00e9es. Nous vous recommandons d'ajouter plusieurs relations entre vos mod\u00e8les de donn\u00e9es, m\u00eame une relation d'auto-r\u00e9f\u00e9rence. Voir aussi Pour en savoir plus sur la gestion des mod\u00e8les de donn\u00e9es, veuillez vous r\u00e9f\u00e9rer \u00e0 \u00e9dition des mod\u00e8les de donn\u00e9es .","title":"Ajouter des mod\u00e8les de donn\u00e9es"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/","text":"Maintenant que vous avez ajout\u00e9 quelques mod\u00e8les de donn\u00e9es pour servir de guide au d\u00e9veloppement des templates, vous pouvez commencer \u00e0 \u00e9crire des templates. S\u00e9lection du boilerplate/channel Rendez-vous dans l'interface graphique (commande hpf serve ). Cliquez sur l'onglet Boilerplates et s\u00e9lectionnez le boilerplate pr\u00e9c\u00e9demment cr\u00e9\u00e9. Cliquez sur Edit boilerplate . Liste des templates Vous arrivez maintenant sur cette page: La barre lat\u00e9rale gauche expose tous les templates pr\u00e9sents dans votre channel en les organisant par dossiers. A droite, un aper\u00e7u des templates disponibles dans le dossier s\u00e9lectionn\u00e9 \u00e0 gauche. Ajout d'un template Cliquez sur New path en dessous d'un dossier puis entrez un chemin de fichier pour cr\u00e9er un nouveau template. \u00c0 savoir Vous pouvez ajouter des / dans le nom du template pour cr\u00e9er ses dossiers parents: path/to/template.ts Nom de template dynamique Vous pouvez cr\u00e9er un nom de template dynamique en fonction du nom du mod\u00e8le: path/to/{camel}.ts . Si vous avez trois mod\u00e8les: user , user profile et listing , alors ce template donnera naissance \u00e0 trois fichiers: path/to/user.ts , path/to/userProfile.ts et path/to/listing.ts . Les casses disponible sont: {camel} exemple : userProfile {pascal} exemple : UserProfile {lower} exemple : user profile {capital} exemple : User Profile {kebab} exemple : user-profile {header} exemple : User-Profile {snake} exemple : user_profile {constant} exemple : USER_PROFILE {compact} exemple : userprofile {raw} exemple : User profile (le nom original) Attention Les noms dynamiques ne fonctionnent que pour les templates de type one model Modifier le nom d'un template Cliquez sur le nom dans la partie gauche et modifiez-le. Supprimer un template Survoler le nom dans la barre de gauche et cliquez sur l'ic\u00f4ne \"supprimer\". Choisir le moteur de template Plusieurs moteurs de template sont disponibles. Choisir le type d'entr\u00e9e Un template peut recevoir en entr\u00e9e un mod\u00e8le de donn\u00e9es ou alors tous les mod\u00e8les de donn\u00e9es. Au cours de la g\u00e9n\u00e9ration, s'il est d\u00e9fini comme one model , le template sera appel\u00e9 une fois pour chaque mod\u00e8le de donn\u00e9es. Par cons\u00e9quent, il engendrera un fichier pour chaque mod\u00e8le de donn\u00e9es. S'il est d\u00e9fini comme all models , le template sera appel\u00e9 une seule fois pour tous les mod\u00e8les de donn\u00e9es. Il engendrera alors un unique fichier. \u00c9diteur de template Pour acc\u00e9der \u00e0 l'\u00e9diteur de template, survoler un template dans la liste de droite et cliquez sur Open editor . Sur la partie gauche se trouve le code du template, que vous pouvez modifier. \u00c0 droite, un aper\u00e7u du rendu du template pour le mod\u00e8le de donn\u00e9es s\u00e9lectionn\u00e9. De m\u00eame, dans la barre de navigation se trouve le chemin du template et le chemin du fichier g\u00e9n\u00e9r\u00e9. \u00c0 savoir Vous pouvez modifier directement le chemin du template dans la barre de navigation. \u00c0 savoir Il est possible de g\u00e9n\u00e9rer automatiquement les fichiers cibles lorsque vous sauvegardez votre template en cliquant sur l'ic\u00f4ne du marteau. Attention La s\u00e9lection des mod\u00e8les de donn\u00e9es n'est pr\u00e9sente que pour les templates de type one model .","title":"\u00c9tape 3: Ajouter des templates"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#selection-du-boilerplatechannel","text":"Rendez-vous dans l'interface graphique (commande hpf serve ). Cliquez sur l'onglet Boilerplates et s\u00e9lectionnez le boilerplate pr\u00e9c\u00e9demment cr\u00e9\u00e9. Cliquez sur Edit boilerplate .","title":"S\u00e9lection du boilerplate/channel"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#liste-des-templates","text":"Vous arrivez maintenant sur cette page: La barre lat\u00e9rale gauche expose tous les templates pr\u00e9sents dans votre channel en les organisant par dossiers. A droite, un aper\u00e7u des templates disponibles dans le dossier s\u00e9lectionn\u00e9 \u00e0 gauche.","title":"Liste des templates"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#ajout-dun-template","text":"Cliquez sur New path en dessous d'un dossier puis entrez un chemin de fichier pour cr\u00e9er un nouveau template. \u00c0 savoir Vous pouvez ajouter des / dans le nom du template pour cr\u00e9er ses dossiers parents: path/to/template.ts","title":"Ajout d'un template"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#nom-de-template-dynamique","text":"Vous pouvez cr\u00e9er un nom de template dynamique en fonction du nom du mod\u00e8le: path/to/{camel}.ts . Si vous avez trois mod\u00e8les: user , user profile et listing , alors ce template donnera naissance \u00e0 trois fichiers: path/to/user.ts , path/to/userProfile.ts et path/to/listing.ts . Les casses disponible sont: {camel} exemple : userProfile {pascal} exemple : UserProfile {lower} exemple : user profile {capital} exemple : User Profile {kebab} exemple : user-profile {header} exemple : User-Profile {snake} exemple : user_profile {constant} exemple : USER_PROFILE {compact} exemple : userprofile {raw} exemple : User profile (le nom original) Attention Les noms dynamiques ne fonctionnent que pour les templates de type one model","title":"Nom de template dynamique"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#modifier-le-nom-dun-template","text":"Cliquez sur le nom dans la partie gauche et modifiez-le.","title":"Modifier le nom d'un template"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#supprimer-un-template","text":"Survoler le nom dans la barre de gauche et cliquez sur l'ic\u00f4ne \"supprimer\".","title":"Supprimer un template"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#choisir-le-moteur-de-template","text":"Plusieurs moteurs de template sont disponibles.","title":"Choisir le moteur de template"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#choisir-le-type-dentree","text":"Un template peut recevoir en entr\u00e9e un mod\u00e8le de donn\u00e9es ou alors tous les mod\u00e8les de donn\u00e9es. Au cours de la g\u00e9n\u00e9ration, s'il est d\u00e9fini comme one model , le template sera appel\u00e9 une fois pour chaque mod\u00e8le de donn\u00e9es. Par cons\u00e9quent, il engendrera un fichier pour chaque mod\u00e8le de donn\u00e9es. S'il est d\u00e9fini comme all models , le template sera appel\u00e9 une seule fois pour tous les mod\u00e8les de donn\u00e9es. Il engendrera alors un unique fichier.","title":"Choisir le type d'entr\u00e9e"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#editeur-de-template","text":"Pour acc\u00e9der \u00e0 l'\u00e9diteur de template, survoler un template dans la liste de droite et cliquez sur Open editor . Sur la partie gauche se trouve le code du template, que vous pouvez modifier. \u00c0 droite, un aper\u00e7u du rendu du template pour le mod\u00e8le de donn\u00e9es s\u00e9lectionn\u00e9. De m\u00eame, dans la barre de navigation se trouve le chemin du template et le chemin du fichier g\u00e9n\u00e9r\u00e9. \u00c0 savoir Vous pouvez modifier directement le chemin du template dans la barre de navigation. \u00c0 savoir Il est possible de g\u00e9n\u00e9rer automatiquement les fichiers cibles lorsque vous sauvegardez votre template en cliquant sur l'ic\u00f4ne du marteau. Attention La s\u00e9lection des mod\u00e8les de donn\u00e9es n'est pr\u00e9sente que pour les templates de type one model .","title":"\u00c9diteur de template"},{"location":"getting-started/create-boilerplate/step-4-template-writing/","text":"Introduction Cette section aborde des cas d'utilisation typiques des templates. Chaque exemple de code est fourni avec les moteurs de templates suivants: Hapify (Syntaxes longue et courte) EJS JavaScript Pour connaitre tous les d\u00e9tails de la syntaxe Hapify, veuillez vous r\u00e9f\u00e9rer ici . Pour vous renseigner sur la syntaxe EJS, veuillez vous r\u00e9f\u00e9rer \u00e0 la documentation officielle . Attention Toutes les fonctionnalit\u00e9s d'EJS sont disponibles, sauf la fonctionnalit\u00e9 include . Cette fonction est volontairement d\u00e9sactiv\u00e9e afin que les templates n'aient pas acc\u00e8s \u00e0 votre syst\u00e8me de fichiers. Manipulation du mod\u00e8le de donn\u00e9es Les templates re\u00e7oivent en entr\u00e9e l' objet mod\u00e8le . Cet objet, inject\u00e9 dans les templates, explicite le mod\u00e8le de donn\u00e9es ainsi que toutes ses propri\u00e9t\u00e9s et relations, de sorte qu'elles soient facilement accessibles depuis le template. Nous vous recommandons de conna\u00eetre sa structure avant de vous lancer dans l'\u00e9criture de templates. Exemples de code Noms Cr\u00e9er une classe pour le mod\u00e8le de donn\u00e9es courant Ce bloc cr\u00e9e une classe pour le mod\u00e8le de donn\u00e9es (en casse pascal ) et d\u00e9fini le nom de la cl\u00e9 primaire, en casse snake . Hapify (long) class <<Model pascal>> { private primaryKey = ' <<PrimaryField snake>> '; } Hapify (short) class <<M AA>> { private primaryKey = ' <<P a_a>> '; } EJS class <%= model . names . pascal %> { private primaryKey = '<%= model.fields.primary.names.snake %>' ; } JavaScript return `class ${ model . names . pascal } { private primaryKey = ' ${ model . fields . primary . names . snake } '; }` ; Sortie class Place { private primaryKey = '_id' ; } Conditions Inclure les d\u00e9pendances en fonction des attributs du champ Dans un template de type one model , ce bloc importe le pilote MongoDB si le mod\u00e8le de donn\u00e9es a une relation avec un autre. Hapify (long) <<if Fields entity >> const mongoDb = require('mongodb'); <<endif>> Hapify (short) <<? F tE >> const mongoDb = require('mongodb'); <<?>> EJS <% if ( model . fields . filter ( f => f . type === 'entity' ). length > 0 ) { -%> const mongoDb = require ( 'mongodb' ); <% } -%> JavaScript let output = '' ; if ( model . fields . filter ( f => f . type === 'entity' ). length > 0 ) { output += `const mongoDb = require('mongodb');` } return output ; Sortie const mongoDb = require ( 'mongodb' ); Valider la session si l'op\u00e9ration n\u00e9cessite une authentification Dans un template de type one model , si l'action create requiert au plus un utilisateur authentifi\u00e9, ce bloc r\u00e9cup\u00e8re l'utilisateur connect\u00e9. Rappel guest est l'acc\u00e8s le plus permissif et admin le moins permissif. Par cons\u00e9quent admin < owner < authenticated < guest . Hapify (long) <<if CreateAccess lteAuth >> const user = Session.getCurrent(); <<endif>> Hapify (short) <<? Ac au] >> const user = Session.getCurrent(); <<?>> EJS <% if ( model . accesses . create . lteAuth ) { -%> const user = Session . getCurrent (); <% } -%> JavaScript let output = '' ; if ( model . accesses . create . lteAuth ) { output += `const user = Session.getCurrent();` } return output ; Sortie const user = Session . getCurrent (); Tester si le mod\u00e8le de donn\u00e9es est g\u00e9o-localis\u00e9 Dans un template de type one model , si le mod\u00e8le de donn\u00e9es a la propri\u00e9t\u00e9 isGeolocated (c'est-\u00e0-dire si le mod\u00e8le de donn\u00e9es contient au moins un champ latitude et un champ longitude), ce bloc importe le composant de s\u00e9lection de la position sur la carte. Hapify (long) <<if Model isGeolocated >> <app-map-position-picker [model]=\" <<Model camel>> \"></app-map-position-picker> <<endif>> Hapify (short) <<? M pGeo >> <app-map-position-picker [model]=\" <<M aA>> \"></app-map-position-picker> <<?>> EJS <% if ( model . properties . isGeolocated ) { -%> < app - map - position - picker [ model ] = \"<%= model.names.camel %>\" >< /app-map-position-picker> <% } -%> JavaScript let output = '' ; if ( model . properties . isGeolocated ) { output += `<app-map-position-picker [model]=\" ${ model . names . camel } \"></app-map-position-picker>` } return output ; Sortie < app-map-position-picker [ model ]=\" place \" ></ app-map-position-picker > Obtenir des relations bas\u00e9es sur la cardinalit\u00e9 Cet exemple cr\u00e9e une m\u00e9thode r\u00e9cup\u00e9rant des entit\u00e9s dans un magasin, selon le type de relation : one-to-one , one-to-many ou many-to-many Hapify (long) class <<Model pascal>> extends BaseModel { <<for Fields entity field >> get <<field pascal>> () { <<if field oneOne or oneMany >> return this. <<field.model camel>> Store.findOne(this.properties. <<field camel>> ); <<elseif field manyMany >> return this. <<field.model camel>> Store.findMany(this.properties. <<field camel>> ); <<endif>> } <<endfor>> } Hapify (short) class <<M AA>> extends BaseModel { <<@ F tE f >> get <<f AA>> () { <<? f tEoo + tEom >> return this. <<f.m aA>> Store.findOne(this.properties. <<f aA>> ); <<?? f tEmm >> return this. <<f.m aA>> Store.findMany(this.properties. <<f aA>> ); <<?>> } <<@>> } EJS class <%= model . names . pascal %> extends BaseModel { <% for ( let field of model . fields . filter ( f => f . type === 'entity' )) { -%> get <%= field . names . pascal %> () { <% if ( field . subtype === 'oneOne' || field . subtype === 'oneMany' ) { -%> return this . <%= field . model . names . camel %> Store . findOne ( this . properties . <%= field . names . camel %> ); <% } else if ( field . subtype === 'manyMany' ) { -%> return this . <%= field . model . names . camel %> Store . findMany ( this . properties . <%= field . names . camel %> ); <% } -%> } <% } -%> } JavaScript let output = '' ; output += `class ${ model . names . pascal } extends BaseModel { ${ getRelations () } }` ; function getRelations () { return model . fields . filter ( f => f . type === 'entity' ). reduce (( acc , field ) => { return acc + getRelation ( field ) + '\\n\\t' ; }, '' ); } function getRelation ( field ) { let method = '' ; if ( field . subtype === 'oneOne' || field . subtype === 'oneMany' ) { method = 'findOne' ; } else if ( field . subtype === 'manyMany' ) { method = 'findMany' ; } else { return '' ; } return `get ${ field . names . pascal } () { return this. ${ field . model . names . camel } Store. ${ method } (this.properties. ${ field . names . camel } ); }` ; } return output ; Sortie class User extends BaseModel { getAvatar() { return this . avatarStore . findOne ( this . properties . avatar ); } getBookmarks() { return this . placeStore . findMany ( this . properties . bookmarks ); } } It\u00e9rations Remplir un tableau avec tous les noms de champs cach\u00e9s Dans un template de type one model , ce bloc cr\u00e9e un tableau (en JavaScript) qui contient les noms des champs hidden (en casse camel ). Hapify (long) const hiddenFields = [ <<for Fields hidden field >> ' <<field camel>> ', <<endfor>> ]; Hapify (short) const hiddenFields = [ <<@ F hd f >> ' <<f aA>> ', <<@>> ]; EJS const hiddenFields = [ <% for ( let field of model . fields . filter ( f => f . hidden )) { -%> '<%= field.names.camel %>' , <% } -%> ]; JavaScript let output = '' ; const hiddenFieldsNames = model . fields . filter ( f => f . hidden ) . map ( f => `' ${ f . names . camel } '` ); output += `const hiddenFields = [ ${ hiddenFieldsNames . join ( \",\\n\\t\" ) } ];` ; return output ; Sortie const hiddenFields = [ 'password' , 'token' , ]; Cr\u00e9er un tableau contenant toutes les valeurs possibles d'une \u00e9num\u00e9ration Dans un template de type one model , ce bloc d\u00e9finit les valeurs d'\u00e9num\u00e9ration sous forme de tableaux (en casse constant ) : Hapify (long) <<for Fields enum field >> const <<field camel>> Values = [ <<for field . enum e >> ' <<e constant>> ', <<endfor>> ]; <<endfor>> Hapify (short) <<@ F tU f >> const <<f aA>> Values = [ <<@ f . e e >> ' <<e A_A>> ', <<@>> ]; <<@>> EJS <% for ( let field of model . fields . filter ( f => f . type === 'enum' )) { -%> const <%= field . names . camel %> Values = [ <% for ( let e of field . enum ) { -%> '<%= e.names.constant %>' , <% } -%> ]; <% } -%> JavaScript let output = '' ; for ( let field of model . fields . filter ( f => f . type === 'enum' )) { const enums = field . enum . map ( e => `' ${ e . names . constant } '` ); output += `const ${ field . names . camel } Values = [ ${ enums . join ( ',\\n\\t' ) } ];` ; } return output ; Sortie const roleValues = [ 'ADMIN' , 'USER' , 'CUSTOMER' , ]; const statusValues = [ 'BUSY' , 'AVAILABLE' , 'OUT_OF_OFFICE' , ]; Cr\u00e9er un fichier d'index comprenant tous les mod\u00e8les de donn\u00e9es Dans un template de type all models , ceci appellera les fichiers de tous les mod\u00e8les. Hapify (long) <<for Models model >> require_once('./ <<model kebab>> .php'); <<endfor>> Hapify (short) <<@ M m >> require_once('./ <<m a-a>> .php'); <<@>> EJS <% for ( let model of models ) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models ) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Sortie require_once('./user.php'); require_once('./place.php'); require_once('./service.php'); require_once('./place-category.php'); Cr\u00e9er un fichier d'index comprenant des mod\u00e8les accessibles uniquement par les administrateurs Si vous voulez restreindre la boucle pr\u00e9c\u00e9dente pour les mod\u00e8les qui ne contiennent que des op\u00e9rations de type admin : Hapify (long) <<for Models onlyAdmin model >> require_once('./ <<model kebab>> .php'); <<endfor>> Hapify (short) <<@ M pOAd m >> require_once('./ <<m a-a>> .php'); <<@>> EJS <% for ( let model of models . filter ( m => m . accesses . properties . onlyAdmin )) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models . filter ( m => m . accesses . properties . onlyAdmin )) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Sortie require_once('./menu.php'); require_once('./menu-part.php'); require_once('./menu-item.php'); require_once('./order.php'); D\u00e9finir une valeur par d\u00e9faut en fonction du type de donn\u00e9es Dans un template de type one model , ce bloc attribue une valeur au champ en fonction de son type pour tous les champs internal . Si le type du champ est boolean , il attribue la valeur false , si le type est string , il attribue la valeur '' , si le type est number , il attribue la valeur 0 , sinon il attribue la valeur NULL . Ce template g\u00e9n\u00e8re du PHP. Hapify (long) <<for Fields internal field >> <<if field boolean >> $default <<field pascal>> = false; <<elseif field string >> $default <<field pascal>> = ''; <<elseif field number >> $default <<field pascal>> = 0; <<else>> $default <<field pascal>> = NULL; <<endif>> <<endfor>> Hapify (short) <<@ F in f >> <<? f tB >> $default <<f AA>> = false; <<?? f tS >> $default <<f AA>> = ''; <<?? f tN >> $default <<f AA>> = 0; <<??>> $default <<f AA>> = NULL; <<?>> <<@>> EJS <% for ( let field of model . fields . filter ( f => f . internal )) { -%> <% if ( field . type === 'boolean' ) { -%> $default <%= field . names . pascal %> = false ; <% } else if ( field . type === 'string' ) { -%> $default <%= field . names . pascal %> = '' ; <% } else if ( field . type === 'number' ) { -%> $default <%= field . names . pascal %> = 0 ; <% } else { -%> $default <%= field . names . pascal %> = NULL ; <% } -%> <% } -%> JavaScript let output = '' ; for ( let field of model . fields . filter ( f => f . internal )) { output += `$default ${ field . names . pascal } = ${ getDefaultValue ( field ) } ; \\ n` } return output ; function getDefaultValue ( field ) { switch ( field . type ) { case 'boolean' : return 'false' ; case 'string' : return \"''\" ; case 'number' : return '0' ; default : return 'NULL' ; } } Sortie $defaultId = ''; $defaultCreatedAt = NULL; $defaultStock = 0; Importer toutes les d\u00e9pendances Dans un template de type one model , ce bloc importe d'autres mod\u00e8les de donn\u00e9es point\u00e9s par des champs de type entit\u00e9. Si le mod\u00e8le a une auto-d\u00e9pendance, il ne sera pas inclus dans la boucle. Hapify (long) <<for Dependencies dep >> import { <<dep pascal>> } from '../ <<dep kebab>> '; <<endfor>> Hapify (short) <<@ D d >> import { <<d AA>> } from '../ <<d a-a>> '; <<@>> EJS <% for ( let dep of model . dependencies . list ) { -%> import { <%= dep . names . pascal %> } from '../<%= dep.names.kebab %>' ; <% } -%> JavaScript let output = '' ; for ( let dep of model . dependencies . list ) { output += `import { ${ dep . names . pascal } } from '../ ${ dep . names . kebab } '; \\ n` ; } return output ; Sortie import { Restaurant } from '../restaurant' ; import { User } from '../user' ; import { MenuPart } from '../menu-part' ; import { MenuItem } from '../menu-item' ; Vous pouvez \u00e9galement filtrer par attributs de champ r\u00e9f\u00e9rent. Ce bloc exclut les mod\u00e8les dont les champs r\u00e9f\u00e9rents sont cach\u00e9s : Hapify (long) <<for Dependencies not hidden dep >> import { <<dep pascal>> } from '../ <<dep kebab>> '; <<endfor>> Hapify (short) <<@ D !hd d >> import { <<d AA>> } from '../ <<d a-a>> '; <<@>> EJS <% for ( let dep of model . dependencies . filter ( f => ! f . hidden )) { -%> import { <%= dep . names . pascal %> } from '../<%= dep.names.kebab %>' ; <% } -%> JavaScript let output = '' ; for ( let dep of model . dependencies . filter ( f => ! f . hidden )) { output += `import { ${ dep . names . pascal } } from '../ ${ dep . names . kebab } '; \\ n` ; } return output ; Sortie import { PlaceCategory } from '../place-category' ; import { Service } from '../service' ; import { User } from '../user' ; Suppression en cascade Dans un template de type one model , ce bloc \u00e9num\u00e8re tous les mod\u00e8les de donn\u00e9es qui se r\u00e9f\u00e8rent au mod\u00e8le de donn\u00e9es courant et les supprime. La premi\u00e8re it\u00e9ration boucle sur tous les mod\u00e8les de donn\u00e9es qui ont une d\u00e9pendance \u00e0 celui-ci. La deuxi\u00e8me it\u00e9ration boucle sur toutes les relations d'entit\u00e9s contenues dans ces mod\u00e8les de donn\u00e9es d\u00e9pendants. Notes Le tableau ReferencedIn contient tous les mod\u00e8les de donn\u00e9es qui se r\u00e9f\u00e8rent au mod\u00e8le de donn\u00e9es courant \u00e0 travers des champs de type entit\u00e9. Seuls les champs de type entit\u00e9 faisant r\u00e9f\u00e9rence sont d\u00e9finis dans ces mod\u00e8les de donn\u00e9es r\u00e9f\u00e9rents. Par cons\u00e9quent, si vous bouclez sur les champs des mod\u00e8les de donn\u00e9es r\u00e9f\u00e9rents, vous ne serez pas brouill\u00e9s par d'autres champs. Hapify (long) <<for ReferencedIn referrer >> <<for referrer . fields field >> await db.collection(' <<referrer pascal>> ').deleteMany({ <<field snake>> : id }); <<endfor>> <<endfor>> Hapify (short) <<@ R m >> <<@ m . f f >> await db.collection(' <<m AA>> ').deleteMany({ <<f a_a>> : id }); <<@>> <<@>> EJS <% for ( let referrer of model . referencedIn ) { -%> <% for ( let field of referrer . fields ) { -%> await db . collection ( '<%= referrer.names.pascal %>' ). deleteMany ({ <%= field . names . snake %>: id }); <% } -%> <% } -%> JavaScript let output = '' ; for ( let referrer of model . referencedIn ) { for ( let field of referrer . fields ) { output += `await db.collection(' ${ referrer . names . pascal } ').deleteMany({ ${ field . names . snake } : id }); \\ n` ; } } return output ; Sortie await db . collection ( 'Place' ). deleteMany ({ owner : id }); await db . collection ( 'Bookmark' ). deleteMany ({ owner : id }); await db . collection ( 'Message' ). deleteMany ({ sender : id }); await db . collection ( 'Message' ). deleteMany ({ recipient : id }); await db . collection ( 'Conversation' ). deleteMany ({ participants : id }); await db . collection ( 'Conversation' ). deleteMany ({ closed_by : id }); await db . collection ( 'ConversationReport' ). deleteMany ({ complainant : id }); await db . collection ( 'ConversationReport' ). deleteMany ({ defendant : id }); Exclusion de fichiers g\u00e9n\u00e9r\u00e9s Lors de la g\u00e9n\u00e9ration il est possible d'exclure certain fichier de la g\u00e9n\u00e9ration. Si le template retourne une chaine vide ou ne contenant que des espaces, alors aucun fichier ne sera g\u00e9n\u00e9r\u00e9 pour ce couple template/mod\u00e8le de donn\u00e9es.","title":"\u00c9tape 4: R\u00e9diger les templates"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#introduction","text":"Cette section aborde des cas d'utilisation typiques des templates. Chaque exemple de code est fourni avec les moteurs de templates suivants: Hapify (Syntaxes longue et courte) EJS JavaScript Pour connaitre tous les d\u00e9tails de la syntaxe Hapify, veuillez vous r\u00e9f\u00e9rer ici . Pour vous renseigner sur la syntaxe EJS, veuillez vous r\u00e9f\u00e9rer \u00e0 la documentation officielle . Attention Toutes les fonctionnalit\u00e9s d'EJS sont disponibles, sauf la fonctionnalit\u00e9 include . Cette fonction est volontairement d\u00e9sactiv\u00e9e afin que les templates n'aient pas acc\u00e8s \u00e0 votre syst\u00e8me de fichiers.","title":"Introduction"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#manipulation-du-modele-de-donnees","text":"Les templates re\u00e7oivent en entr\u00e9e l' objet mod\u00e8le . Cet objet, inject\u00e9 dans les templates, explicite le mod\u00e8le de donn\u00e9es ainsi que toutes ses propri\u00e9t\u00e9s et relations, de sorte qu'elles soient facilement accessibles depuis le template. Nous vous recommandons de conna\u00eetre sa structure avant de vous lancer dans l'\u00e9criture de templates.","title":"Manipulation du mod\u00e8le de donn\u00e9es"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#exemples-de-code","text":"","title":"Exemples de code"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#noms","text":"","title":"Noms"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#creer-une-classe-pour-le-modele-de-donnees-courant","text":"Ce bloc cr\u00e9e une classe pour le mod\u00e8le de donn\u00e9es (en casse pascal ) et d\u00e9fini le nom de la cl\u00e9 primaire, en casse snake . Hapify (long) class <<Model pascal>> { private primaryKey = ' <<PrimaryField snake>> '; } Hapify (short) class <<M AA>> { private primaryKey = ' <<P a_a>> '; } EJS class <%= model . names . pascal %> { private primaryKey = '<%= model.fields.primary.names.snake %>' ; } JavaScript return `class ${ model . names . pascal } { private primaryKey = ' ${ model . fields . primary . names . snake } '; }` ; Sortie class Place { private primaryKey = '_id' ; }","title":"Cr\u00e9er une classe pour le mod\u00e8le de donn\u00e9es courant"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#conditions","text":"","title":"Conditions"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#inclure-les-dependances-en-fonction-des-attributs-du-champ","text":"Dans un template de type one model , ce bloc importe le pilote MongoDB si le mod\u00e8le de donn\u00e9es a une relation avec un autre. Hapify (long) <<if Fields entity >> const mongoDb = require('mongodb'); <<endif>> Hapify (short) <<? F tE >> const mongoDb = require('mongodb'); <<?>> EJS <% if ( model . fields . filter ( f => f . type === 'entity' ). length > 0 ) { -%> const mongoDb = require ( 'mongodb' ); <% } -%> JavaScript let output = '' ; if ( model . fields . filter ( f => f . type === 'entity' ). length > 0 ) { output += `const mongoDb = require('mongodb');` } return output ; Sortie const mongoDb = require ( 'mongodb' );","title":"Inclure les d\u00e9pendances en fonction des attributs du champ"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#valider-la-session-si-loperation-necessite-une-authentification","text":"Dans un template de type one model , si l'action create requiert au plus un utilisateur authentifi\u00e9, ce bloc r\u00e9cup\u00e8re l'utilisateur connect\u00e9. Rappel guest est l'acc\u00e8s le plus permissif et admin le moins permissif. Par cons\u00e9quent admin < owner < authenticated < guest . Hapify (long) <<if CreateAccess lteAuth >> const user = Session.getCurrent(); <<endif>> Hapify (short) <<? Ac au] >> const user = Session.getCurrent(); <<?>> EJS <% if ( model . accesses . create . lteAuth ) { -%> const user = Session . getCurrent (); <% } -%> JavaScript let output = '' ; if ( model . accesses . create . lteAuth ) { output += `const user = Session.getCurrent();` } return output ; Sortie const user = Session . getCurrent ();","title":"Valider la session si l'op\u00e9ration n\u00e9cessite une authentification"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#tester-si-le-modele-de-donnees-est-geo-localise","text":"Dans un template de type one model , si le mod\u00e8le de donn\u00e9es a la propri\u00e9t\u00e9 isGeolocated (c'est-\u00e0-dire si le mod\u00e8le de donn\u00e9es contient au moins un champ latitude et un champ longitude), ce bloc importe le composant de s\u00e9lection de la position sur la carte. Hapify (long) <<if Model isGeolocated >> <app-map-position-picker [model]=\" <<Model camel>> \"></app-map-position-picker> <<endif>> Hapify (short) <<? M pGeo >> <app-map-position-picker [model]=\" <<M aA>> \"></app-map-position-picker> <<?>> EJS <% if ( model . properties . isGeolocated ) { -%> < app - map - position - picker [ model ] = \"<%= model.names.camel %>\" >< /app-map-position-picker> <% } -%> JavaScript let output = '' ; if ( model . properties . isGeolocated ) { output += `<app-map-position-picker [model]=\" ${ model . names . camel } \"></app-map-position-picker>` } return output ; Sortie < app-map-position-picker [ model ]=\" place \" ></ app-map-position-picker >","title":"Tester si le mod\u00e8le de donn\u00e9es est g\u00e9o-localis\u00e9"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#obtenir-des-relations-basees-sur-la-cardinalite","text":"Cet exemple cr\u00e9e une m\u00e9thode r\u00e9cup\u00e9rant des entit\u00e9s dans un magasin, selon le type de relation : one-to-one , one-to-many ou many-to-many Hapify (long) class <<Model pascal>> extends BaseModel { <<for Fields entity field >> get <<field pascal>> () { <<if field oneOne or oneMany >> return this. <<field.model camel>> Store.findOne(this.properties. <<field camel>> ); <<elseif field manyMany >> return this. <<field.model camel>> Store.findMany(this.properties. <<field camel>> ); <<endif>> } <<endfor>> } Hapify (short) class <<M AA>> extends BaseModel { <<@ F tE f >> get <<f AA>> () { <<? f tEoo + tEom >> return this. <<f.m aA>> Store.findOne(this.properties. <<f aA>> ); <<?? f tEmm >> return this. <<f.m aA>> Store.findMany(this.properties. <<f aA>> ); <<?>> } <<@>> } EJS class <%= model . names . pascal %> extends BaseModel { <% for ( let field of model . fields . filter ( f => f . type === 'entity' )) { -%> get <%= field . names . pascal %> () { <% if ( field . subtype === 'oneOne' || field . subtype === 'oneMany' ) { -%> return this . <%= field . model . names . camel %> Store . findOne ( this . properties . <%= field . names . camel %> ); <% } else if ( field . subtype === 'manyMany' ) { -%> return this . <%= field . model . names . camel %> Store . findMany ( this . properties . <%= field . names . camel %> ); <% } -%> } <% } -%> } JavaScript let output = '' ; output += `class ${ model . names . pascal } extends BaseModel { ${ getRelations () } }` ; function getRelations () { return model . fields . filter ( f => f . type === 'entity' ). reduce (( acc , field ) => { return acc + getRelation ( field ) + '\\n\\t' ; }, '' ); } function getRelation ( field ) { let method = '' ; if ( field . subtype === 'oneOne' || field . subtype === 'oneMany' ) { method = 'findOne' ; } else if ( field . subtype === 'manyMany' ) { method = 'findMany' ; } else { return '' ; } return `get ${ field . names . pascal } () { return this. ${ field . model . names . camel } Store. ${ method } (this.properties. ${ field . names . camel } ); }` ; } return output ; Sortie class User extends BaseModel { getAvatar() { return this . avatarStore . findOne ( this . properties . avatar ); } getBookmarks() { return this . placeStore . findMany ( this . properties . bookmarks ); } }","title":"Obtenir des relations bas\u00e9es sur la cardinalit\u00e9"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#iterations","text":"","title":"It\u00e9rations"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#remplir-un-tableau-avec-tous-les-noms-de-champs-caches","text":"Dans un template de type one model , ce bloc cr\u00e9e un tableau (en JavaScript) qui contient les noms des champs hidden (en casse camel ). Hapify (long) const hiddenFields = [ <<for Fields hidden field >> ' <<field camel>> ', <<endfor>> ]; Hapify (short) const hiddenFields = [ <<@ F hd f >> ' <<f aA>> ', <<@>> ]; EJS const hiddenFields = [ <% for ( let field of model . fields . filter ( f => f . hidden )) { -%> '<%= field.names.camel %>' , <% } -%> ]; JavaScript let output = '' ; const hiddenFieldsNames = model . fields . filter ( f => f . hidden ) . map ( f => `' ${ f . names . camel } '` ); output += `const hiddenFields = [ ${ hiddenFieldsNames . join ( \",\\n\\t\" ) } ];` ; return output ; Sortie const hiddenFields = [ 'password' , 'token' , ];","title":"Remplir un tableau avec tous les noms de champs cach\u00e9s"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#creer-un-tableau-contenant-toutes-les-valeurs-possibles-dune-enumeration","text":"Dans un template de type one model , ce bloc d\u00e9finit les valeurs d'\u00e9num\u00e9ration sous forme de tableaux (en casse constant ) : Hapify (long) <<for Fields enum field >> const <<field camel>> Values = [ <<for field . enum e >> ' <<e constant>> ', <<endfor>> ]; <<endfor>> Hapify (short) <<@ F tU f >> const <<f aA>> Values = [ <<@ f . e e >> ' <<e A_A>> ', <<@>> ]; <<@>> EJS <% for ( let field of model . fields . filter ( f => f . type === 'enum' )) { -%> const <%= field . names . camel %> Values = [ <% for ( let e of field . enum ) { -%> '<%= e.names.constant %>' , <% } -%> ]; <% } -%> JavaScript let output = '' ; for ( let field of model . fields . filter ( f => f . type === 'enum' )) { const enums = field . enum . map ( e => `' ${ e . names . constant } '` ); output += `const ${ field . names . camel } Values = [ ${ enums . join ( ',\\n\\t' ) } ];` ; } return output ; Sortie const roleValues = [ 'ADMIN' , 'USER' , 'CUSTOMER' , ]; const statusValues = [ 'BUSY' , 'AVAILABLE' , 'OUT_OF_OFFICE' , ];","title":"Cr\u00e9er un tableau contenant toutes les valeurs possibles d'une \u00e9num\u00e9ration"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#creer-un-fichier-dindex-comprenant-tous-les-modeles-de-donnees","text":"Dans un template de type all models , ceci appellera les fichiers de tous les mod\u00e8les. Hapify (long) <<for Models model >> require_once('./ <<model kebab>> .php'); <<endfor>> Hapify (short) <<@ M m >> require_once('./ <<m a-a>> .php'); <<@>> EJS <% for ( let model of models ) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models ) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Sortie require_once('./user.php'); require_once('./place.php'); require_once('./service.php'); require_once('./place-category.php');","title":"Cr\u00e9er un fichier d'index comprenant tous les mod\u00e8les de donn\u00e9es"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#creer-un-fichier-dindex-comprenant-des-modeles-accessibles-uniquement-par-les-administrateurs","text":"Si vous voulez restreindre la boucle pr\u00e9c\u00e9dente pour les mod\u00e8les qui ne contiennent que des op\u00e9rations de type admin : Hapify (long) <<for Models onlyAdmin model >> require_once('./ <<model kebab>> .php'); <<endfor>> Hapify (short) <<@ M pOAd m >> require_once('./ <<m a-a>> .php'); <<@>> EJS <% for ( let model of models . filter ( m => m . accesses . properties . onlyAdmin )) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models . filter ( m => m . accesses . properties . onlyAdmin )) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Sortie require_once('./menu.php'); require_once('./menu-part.php'); require_once('./menu-item.php'); require_once('./order.php');","title":"Cr\u00e9er un fichier d'index comprenant des mod\u00e8les accessibles uniquement par les administrateurs"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#definir-une-valeur-par-defaut-en-fonction-du-type-de-donnees","text":"Dans un template de type one model , ce bloc attribue une valeur au champ en fonction de son type pour tous les champs internal . Si le type du champ est boolean , il attribue la valeur false , si le type est string , il attribue la valeur '' , si le type est number , il attribue la valeur 0 , sinon il attribue la valeur NULL . Ce template g\u00e9n\u00e8re du PHP. Hapify (long) <<for Fields internal field >> <<if field boolean >> $default <<field pascal>> = false; <<elseif field string >> $default <<field pascal>> = ''; <<elseif field number >> $default <<field pascal>> = 0; <<else>> $default <<field pascal>> = NULL; <<endif>> <<endfor>> Hapify (short) <<@ F in f >> <<? f tB >> $default <<f AA>> = false; <<?? f tS >> $default <<f AA>> = ''; <<?? f tN >> $default <<f AA>> = 0; <<??>> $default <<f AA>> = NULL; <<?>> <<@>> EJS <% for ( let field of model . fields . filter ( f => f . internal )) { -%> <% if ( field . type === 'boolean' ) { -%> $default <%= field . names . pascal %> = false ; <% } else if ( field . type === 'string' ) { -%> $default <%= field . names . pascal %> = '' ; <% } else if ( field . type === 'number' ) { -%> $default <%= field . names . pascal %> = 0 ; <% } else { -%> $default <%= field . names . pascal %> = NULL ; <% } -%> <% } -%> JavaScript let output = '' ; for ( let field of model . fields . filter ( f => f . internal )) { output += `$default ${ field . names . pascal } = ${ getDefaultValue ( field ) } ; \\ n` } return output ; function getDefaultValue ( field ) { switch ( field . type ) { case 'boolean' : return 'false' ; case 'string' : return \"''\" ; case 'number' : return '0' ; default : return 'NULL' ; } } Sortie $defaultId = ''; $defaultCreatedAt = NULL; $defaultStock = 0;","title":"D\u00e9finir une valeur par d\u00e9faut en fonction du type de donn\u00e9es"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#importer-toutes-les-dependances","text":"Dans un template de type one model , ce bloc importe d'autres mod\u00e8les de donn\u00e9es point\u00e9s par des champs de type entit\u00e9. Si le mod\u00e8le a une auto-d\u00e9pendance, il ne sera pas inclus dans la boucle. Hapify (long) <<for Dependencies dep >> import { <<dep pascal>> } from '../ <<dep kebab>> '; <<endfor>> Hapify (short) <<@ D d >> import { <<d AA>> } from '../ <<d a-a>> '; <<@>> EJS <% for ( let dep of model . dependencies . list ) { -%> import { <%= dep . names . pascal %> } from '../<%= dep.names.kebab %>' ; <% } -%> JavaScript let output = '' ; for ( let dep of model . dependencies . list ) { output += `import { ${ dep . names . pascal } } from '../ ${ dep . names . kebab } '; \\ n` ; } return output ; Sortie import { Restaurant } from '../restaurant' ; import { User } from '../user' ; import { MenuPart } from '../menu-part' ; import { MenuItem } from '../menu-item' ; Vous pouvez \u00e9galement filtrer par attributs de champ r\u00e9f\u00e9rent. Ce bloc exclut les mod\u00e8les dont les champs r\u00e9f\u00e9rents sont cach\u00e9s : Hapify (long) <<for Dependencies not hidden dep >> import { <<dep pascal>> } from '../ <<dep kebab>> '; <<endfor>> Hapify (short) <<@ D !hd d >> import { <<d AA>> } from '../ <<d a-a>> '; <<@>> EJS <% for ( let dep of model . dependencies . filter ( f => ! f . hidden )) { -%> import { <%= dep . names . pascal %> } from '../<%= dep.names.kebab %>' ; <% } -%> JavaScript let output = '' ; for ( let dep of model . dependencies . filter ( f => ! f . hidden )) { output += `import { ${ dep . names . pascal } } from '../ ${ dep . names . kebab } '; \\ n` ; } return output ; Sortie import { PlaceCategory } from '../place-category' ; import { Service } from '../service' ; import { User } from '../user' ;","title":"Importer toutes les d\u00e9pendances"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#suppression-en-cascade","text":"Dans un template de type one model , ce bloc \u00e9num\u00e8re tous les mod\u00e8les de donn\u00e9es qui se r\u00e9f\u00e8rent au mod\u00e8le de donn\u00e9es courant et les supprime. La premi\u00e8re it\u00e9ration boucle sur tous les mod\u00e8les de donn\u00e9es qui ont une d\u00e9pendance \u00e0 celui-ci. La deuxi\u00e8me it\u00e9ration boucle sur toutes les relations d'entit\u00e9s contenues dans ces mod\u00e8les de donn\u00e9es d\u00e9pendants. Notes Le tableau ReferencedIn contient tous les mod\u00e8les de donn\u00e9es qui se r\u00e9f\u00e8rent au mod\u00e8le de donn\u00e9es courant \u00e0 travers des champs de type entit\u00e9. Seuls les champs de type entit\u00e9 faisant r\u00e9f\u00e9rence sont d\u00e9finis dans ces mod\u00e8les de donn\u00e9es r\u00e9f\u00e9rents. Par cons\u00e9quent, si vous bouclez sur les champs des mod\u00e8les de donn\u00e9es r\u00e9f\u00e9rents, vous ne serez pas brouill\u00e9s par d'autres champs. Hapify (long) <<for ReferencedIn referrer >> <<for referrer . fields field >> await db.collection(' <<referrer pascal>> ').deleteMany({ <<field snake>> : id }); <<endfor>> <<endfor>> Hapify (short) <<@ R m >> <<@ m . f f >> await db.collection(' <<m AA>> ').deleteMany({ <<f a_a>> : id }); <<@>> <<@>> EJS <% for ( let referrer of model . referencedIn ) { -%> <% for ( let field of referrer . fields ) { -%> await db . collection ( '<%= referrer.names.pascal %>' ). deleteMany ({ <%= field . names . snake %>: id }); <% } -%> <% } -%> JavaScript let output = '' ; for ( let referrer of model . referencedIn ) { for ( let field of referrer . fields ) { output += `await db.collection(' ${ referrer . names . pascal } ').deleteMany({ ${ field . names . snake } : id }); \\ n` ; } } return output ; Sortie await db . collection ( 'Place' ). deleteMany ({ owner : id }); await db . collection ( 'Bookmark' ). deleteMany ({ owner : id }); await db . collection ( 'Message' ). deleteMany ({ sender : id }); await db . collection ( 'Message' ). deleteMany ({ recipient : id }); await db . collection ( 'Conversation' ). deleteMany ({ participants : id }); await db . collection ( 'Conversation' ). deleteMany ({ closed_by : id }); await db . collection ( 'ConversationReport' ). deleteMany ({ complainant : id }); await db . collection ( 'ConversationReport' ). deleteMany ({ defendant : id });","title":"Suppression en cascade"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#exclusion-de-fichiers-generes","text":"Lors de la g\u00e9n\u00e9ration il est possible d'exclure certain fichier de la g\u00e9n\u00e9ration. Si le template retourne une chaine vide ou ne contenant que des espaces, alors aucun fichier ne sera g\u00e9n\u00e9r\u00e9 pour ce couple template/mod\u00e8le de donn\u00e9es.","title":"Exclusion de fichiers g\u00e9n\u00e9r\u00e9s"},{"location":"getting-started/create-boilerplate/step-5-models-validator/","text":"Vos templates ne peuvent pas g\u00e9rer n'importe quelle combinaison de champs et d'attributs. Pour \u00e9viter cela, vous pouvez associer un validateur de mod\u00e8le de donn\u00e9es \u00e0 vos templates. Comment \u00e7a fonctionne ? Ce validateur est \u00e9crit en JavaScript pur. Il re\u00e7oit un mod\u00e8le de donn\u00e9es unique et renvoie des warnings et des errors . Ces avertissements et erreurs seront affich\u00e9s lors de la gestion des mod\u00e8les de donn\u00e9es : Avertissement Erreur \u00c9crire un validateur Lors de la validation du mod\u00e8le de donn\u00e9es, le code JavaScript est envelopp\u00e9 dans une fonction. Par cons\u00e9quent, le code que vous \u00e9crivez est le corps de cette fonction. Votre code doit retourner un objet comme celui-ci : return { errors : [ 'Model has no primary key' ], warnings : [] } Acc\u00e9der aux propri\u00e9t\u00e9s du mod\u00e8le Dans le script du validateur, le mod\u00e8le est disponible sous la variable model . La variable model est structur\u00e9e comme ceci : { \"id\" : \"bdc6c58e-ec49-9193-6b29-6c75518bc3ad\" , \"name\" : \"Bookmark\" , \"notes\" : \"A user can only list its own bookmarks\" , \"fields\" : [ { \"name\" : \"_id\" , \"notes\" : null , \"type\" : \"string\" , \"subtype\" : null , \"value\" : null , \"primary\" : true , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false } ], \"accesses\" : { \"create\" : \"auth\" , \"read\" : \"owner\" , \"update\" : \"admin\" , \"remove\" : \"owner\" , \"search\" : \"owner\" , \"count\" : \"owner\" } } Contrairement au moteur de template JavaScript, les propri\u00e9t\u00e9s du mod\u00e8le de donn\u00e9es ne sont pas pr\u00e9-calcul\u00e9es et vous n'avez pas acc\u00e8s aux d\u00e9pendances du mod\u00e8le de donn\u00e9es. Exemple de validateur Voici un exemple de validateur qui envoie un avertissement pour un type de champ non pris en charge, et une erreur si la cl\u00e9 primaire n'est pas conforme. // Model object is injected as \"model\" const errors = []; const warnings = []; // ----------------------------- // File fields if ( model . fields . filter (( f ) => f . type === 'file' ). length ) { errors . push ( 'File fields are not supported yet by this boilerplate' ); } // URL fields if ( model . fields . filter (( f ) => f . type === 'string' && f . subtype === 'url' ). length ) { warnings . push ( 'URL string is not supported yet and will be handle as default string' ); } // ----------------------------- // Primary key const primaries = model . fields . filter (( f ) => f . primary ); if ( primaries . length > 1 ) { errors . push ( 'Only one field can be primary' ); } const primary = primaries [ 0 ]; if ( primary ) { if ( primary . name !== '_id' ) { errors . push ( 'Primary key must be called \"_id\"' ); } if ( primary . type !== 'string' ) { errors . push ( 'Primary key must be a string' ); } if ( ! primary . internal ) { errors . push ( 'Primary key must be a internal' ); } } else { errors . push ( 'Primary key is required' ); } return { errors , warnings , };","title":"\u00c9tape 5: Validateur de mod\u00e8les de donn\u00e9es"},{"location":"getting-started/create-boilerplate/step-5-models-validator/#comment-ca-fonctionne","text":"Ce validateur est \u00e9crit en JavaScript pur. Il re\u00e7oit un mod\u00e8le de donn\u00e9es unique et renvoie des warnings et des errors . Ces avertissements et erreurs seront affich\u00e9s lors de la gestion des mod\u00e8les de donn\u00e9es : Avertissement Erreur","title":"Comment \u00e7a fonctionne ?"},{"location":"getting-started/create-boilerplate/step-5-models-validator/#ecrire-un-validateur","text":"Lors de la validation du mod\u00e8le de donn\u00e9es, le code JavaScript est envelopp\u00e9 dans une fonction. Par cons\u00e9quent, le code que vous \u00e9crivez est le corps de cette fonction. Votre code doit retourner un objet comme celui-ci : return { errors : [ 'Model has no primary key' ], warnings : [] }","title":"\u00c9crire un validateur"},{"location":"getting-started/create-boilerplate/step-5-models-validator/#acceder-aux-proprietes-du-modele","text":"Dans le script du validateur, le mod\u00e8le est disponible sous la variable model . La variable model est structur\u00e9e comme ceci : { \"id\" : \"bdc6c58e-ec49-9193-6b29-6c75518bc3ad\" , \"name\" : \"Bookmark\" , \"notes\" : \"A user can only list its own bookmarks\" , \"fields\" : [ { \"name\" : \"_id\" , \"notes\" : null , \"type\" : \"string\" , \"subtype\" : null , \"value\" : null , \"primary\" : true , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false } ], \"accesses\" : { \"create\" : \"auth\" , \"read\" : \"owner\" , \"update\" : \"admin\" , \"remove\" : \"owner\" , \"search\" : \"owner\" , \"count\" : \"owner\" } } Contrairement au moteur de template JavaScript, les propri\u00e9t\u00e9s du mod\u00e8le de donn\u00e9es ne sont pas pr\u00e9-calcul\u00e9es et vous n'avez pas acc\u00e8s aux d\u00e9pendances du mod\u00e8le de donn\u00e9es.","title":"Acc\u00e9der aux propri\u00e9t\u00e9s du mod\u00e8le"},{"location":"getting-started/create-boilerplate/step-5-models-validator/#exemple-de-validateur","text":"Voici un exemple de validateur qui envoie un avertissement pour un type de champ non pris en charge, et une erreur si la cl\u00e9 primaire n'est pas conforme. // Model object is injected as \"model\" const errors = []; const warnings = []; // ----------------------------- // File fields if ( model . fields . filter (( f ) => f . type === 'file' ). length ) { errors . push ( 'File fields are not supported yet by this boilerplate' ); } // URL fields if ( model . fields . filter (( f ) => f . type === 'string' && f . subtype === 'url' ). length ) { warnings . push ( 'URL string is not supported yet and will be handle as default string' ); } // ----------------------------- // Primary key const primaries = model . fields . filter (( f ) => f . primary ); if ( primaries . length > 1 ) { errors . push ( 'Only one field can be primary' ); } const primary = primaries [ 0 ]; if ( primary ) { if ( primary . name !== '_id' ) { errors . push ( 'Primary key must be called \"_id\"' ); } if ( primary . type !== 'string' ) { errors . push ( 'Primary key must be a string' ); } if ( ! primary . internal ) { errors . push ( 'Primary key must be a internal' ); } } else { errors . push ( 'Primary key is required' ); } return { errors , warnings , };","title":"Exemple de validateur"},{"location":"getting-started/existing-boilerplate/introduction/","text":"R\u00e9sum\u00e9 Dans cette section, vous apprendrez comment d\u00e9marrer un projet \u00e0 partir d'un boilerplate existant et comment g\u00e9n\u00e9rer le code \u00e0 partir de vos mod\u00e8les de donn\u00e9es. Si vous souhaitez cr\u00e9er des templates de code pour votre boilerplate, veuillez vous r\u00e9f\u00e9rer \u00e0 ce tutoriel . Nous supposons que vous avez d\u00e9j\u00e0 install\u00e9 le CLI avant de lire ce tutoriel. Si ce n'est pas le cas, veuillez vous r\u00e9f\u00e9rer au guide d'installation . Aper\u00e7u rapide du tutoriel G\u00e9n\u00e9rons !","title":"Introduction"},{"location":"getting-started/existing-boilerplate/introduction/#resume","text":"Dans cette section, vous apprendrez comment d\u00e9marrer un projet \u00e0 partir d'un boilerplate existant et comment g\u00e9n\u00e9rer le code \u00e0 partir de vos mod\u00e8les de donn\u00e9es. Si vous souhaitez cr\u00e9er des templates de code pour votre boilerplate, veuillez vous r\u00e9f\u00e9rer \u00e0 ce tutoriel . Nous supposons que vous avez d\u00e9j\u00e0 install\u00e9 le CLI avant de lire ce tutoriel. Si ce n'est pas le cas, veuillez vous r\u00e9f\u00e9rer au guide d'installation .","title":"R\u00e9sum\u00e9"},{"location":"getting-started/existing-boilerplate/introduction/#apercu-rapide-du-tutoriel","text":"G\u00e9n\u00e9rons !","title":"Aper\u00e7u rapide du tutoriel"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/","text":"Ex\u00e9cuter la commande new Cr\u00e9ez un nouveau dossier pour votre projet et allez dans ce dossier : mkdir my-project && cd my-project Utilisez la commande new pour cloner un boilerplate et initialiser votre projet : hpf new Choisir un ou plusieurs boilerplates Une fois que vous avez s\u00e9lectionn\u00e9 un projet, vous pourrez choisir un boilerplate public (disponible sur le Hub Hapify ) ou entrer une URL de git personnalis\u00e9e. ? Choose a boilerplate Enter a Git URL \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u276f HapiJS Backend NG-ZORRO Components NG-ZORRO Dashboard PHP Slim Backend Vous pouvez ajouter un autre boilerplate : ? Choose a project New one ? Choose a boilerplate HapiJS ? Add another boilerplate? (y/N) Par exemple, si vous choisissez un boilerplate back-end, vous pouvez ajouter un ou plusieurs boilerplate front-end. Si vous n'avez besoin que d'un seul boilerplate ou si vous choisissez un boilerplate full-stack, s\u00e9lectionnez simplement No . Utiliser un boilerplate \u00e0 partir d'un d\u00e9p\u00f4t git Si vous voulez utiliser un boilerplate qui n'est pas r\u00e9pertori\u00e9, choisissez l'option Enter a Git URL puis tapez ou collez l'URL : ? Choose a boilerplate Enter a Git URL ? Enter boilerplate Git URL https://github.com/someone/somerepo.git Vous devez entrer une URL compatible avec git clone . Importer des mod\u00e8les de donn\u00e9es pr\u00e9d\u00e9finis Vous pouvez importer des collections de mod\u00e8les de donn\u00e9es pr\u00e9d\u00e9finies ( presets ) depuis Hapify Cloud. Pour ce faire, s\u00e9lectionnez un ou plusieurs presets lorsque cela vous est demand\u00e9 : ? Choose some presets to preload in your project \u25c9 User \u25ef Listing \u25ef Messaging \u276f\u25c9 Food delivery \u25ef Shopping cart & wishlist Entrer le nom et la description ? Enter a project name Food delivery ? Enter a project description A food delivery app Sortie Apr\u00e8s quelques secondes, le boilerplate sera clon\u00e9 dans votre dossier courant : \u2713 Created 2 new dynamic boilerplates in ~/my-project. Run hpf use to connect a remote project (optional). Run hpf serve to edit models and templates. Run hpf generate to generate the source code. La structure des dossiers ressemble \u00e0 ceci : ~/my-project \u251c\u2500\u2500 boilerplate-hapijs | \u251c\u2500\u2500 .hapify | | \u251c\u2500\u2500 routes | | \u2514\u2500\u2500 validator.js | \u251c\u2500\u2500 Dockerfile | \u251c\u2500\u2500 hapify-models.json | \u251c\u2500\u2500 hapify.json | \u2514\u2500\u2500 ... \u2514\u2500\u2500 boilerplate-ngx-dashboard \u251c\u2500\u2500 .hapify | \u251c\u2500\u2500 src | \u2514\u2500\u2500 validator.js \u251c\u2500\u2500 src | \u251c\u2500\u2500 app | \u251c\u2500\u2500 assets | \u251c\u2500\u2500 index.html | \u2514\u2500\u2500 ... \u251c\u2500\u2500 hapify.json \u2514\u2500\u2500 ... hapify.json est le fichier de configuration. Il contient les m\u00e9ta-donn\u00e9es du boilerplate et la liste des templates. Le fichier hapify-models.json contient les mod\u00e8les de donn\u00e9es de votre projet. Il est r\u00e9f\u00e9renc\u00e9 par le fichier de configuration ( hapify.json ). Vous pouvez d\u00e9placer ou renommer ce fichier tant que vous changez le chemin dans le fichier de configuration. Le dossier .hapify (peut aussi \u00eatre nomm\u00e9 hapify ) est le dossier des templates. Il contient tous les templates du boilerplate. Facultatif : Stocker vos mod\u00e8les de donn\u00e9es sur Hapify Cloud Par d\u00e9faut, Hapify stocke vos mod\u00e8les de donn\u00e9es localement. Le chemin d'acc\u00e8s est d\u00e9fini dans le fichier de configuration. Vous pouvez stocker vos mod\u00e8les de donn\u00e9es en ligne, afin de les partager sur plusieurs d\u00e9p\u00f4ts. Pour connecter le CLI \u00e0 Hapify Cloud, veuillez suivre ces \u00e9tapes . Connecter votre boilerplate \u00e0 un projet distant Ex\u00e9cutez cette commande pour configurer votre boilerplate : hpf use Cr\u00e9er un projet Vous pouvez cr\u00e9er un projet directement depuis le CLI en s\u00e9lectionnant Create a new project . \u00c0 l'invite, entrez le nom et la description. ? Choose a project Create a new project ? Enter a project name First project ? Enter a project description My first project with Hapify S\u00e9lectionnez un projet existant Dans la liste ci-dessous, s\u00e9lectionnez un projet depuis votre compte. ? Choose a project (Use arrow keys) Create a new project \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u276f First project Second project \u00c0 savoir Vous pouvez cr\u00e9er un projet en ligne \u00e0 partir de votre compte Hapify : https://www.hapify.io/my-projects Le boilerplate va maintenant stocker et lire les mod\u00e8les depuis Hapify Cloud. ? Choose a project First project \u2713 Did set project 5c893c0a74e4650010e6f683 for channel HapiJS \u2713 Did set project 5c893c0a74e4650010e6f683 for channel Angular Dashboard L'ID du projet est stock\u00e9 dans le fichier de configuration ( hapify.json ).","title":"\u00c9tape 1: Cloner un boilerplate"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#executer-la-commande-new","text":"Cr\u00e9ez un nouveau dossier pour votre projet et allez dans ce dossier : mkdir my-project && cd my-project Utilisez la commande new pour cloner un boilerplate et initialiser votre projet : hpf new","title":"Ex\u00e9cuter la commande new"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#choisir-un-ou-plusieurs-boilerplates","text":"Une fois que vous avez s\u00e9lectionn\u00e9 un projet, vous pourrez choisir un boilerplate public (disponible sur le Hub Hapify ) ou entrer une URL de git personnalis\u00e9e. ? Choose a boilerplate Enter a Git URL \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u276f HapiJS Backend NG-ZORRO Components NG-ZORRO Dashboard PHP Slim Backend Vous pouvez ajouter un autre boilerplate : ? Choose a project New one ? Choose a boilerplate HapiJS ? Add another boilerplate? (y/N) Par exemple, si vous choisissez un boilerplate back-end, vous pouvez ajouter un ou plusieurs boilerplate front-end. Si vous n'avez besoin que d'un seul boilerplate ou si vous choisissez un boilerplate full-stack, s\u00e9lectionnez simplement No .","title":"Choisir un ou plusieurs boilerplates"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#utiliser-un-boilerplate-a-partir-dun-depot-git","text":"Si vous voulez utiliser un boilerplate qui n'est pas r\u00e9pertori\u00e9, choisissez l'option Enter a Git URL puis tapez ou collez l'URL : ? Choose a boilerplate Enter a Git URL ? Enter boilerplate Git URL https://github.com/someone/somerepo.git Vous devez entrer une URL compatible avec git clone .","title":"Utiliser un boilerplate \u00e0 partir d'un d\u00e9p\u00f4t git"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#importer-des-modeles-de-donnees-predefinis","text":"Vous pouvez importer des collections de mod\u00e8les de donn\u00e9es pr\u00e9d\u00e9finies ( presets ) depuis Hapify Cloud. Pour ce faire, s\u00e9lectionnez un ou plusieurs presets lorsque cela vous est demand\u00e9 : ? Choose some presets to preload in your project \u25c9 User \u25ef Listing \u25ef Messaging \u276f\u25c9 Food delivery \u25ef Shopping cart & wishlist","title":"Importer des mod\u00e8les de donn\u00e9es pr\u00e9d\u00e9finis"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#entrer-le-nom-et-la-description","text":"? Enter a project name Food delivery ? Enter a project description A food delivery app","title":"Entrer le nom et la description"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#sortie","text":"Apr\u00e8s quelques secondes, le boilerplate sera clon\u00e9 dans votre dossier courant : \u2713 Created 2 new dynamic boilerplates in ~/my-project. Run hpf use to connect a remote project (optional). Run hpf serve to edit models and templates. Run hpf generate to generate the source code. La structure des dossiers ressemble \u00e0 ceci : ~/my-project \u251c\u2500\u2500 boilerplate-hapijs | \u251c\u2500\u2500 .hapify | | \u251c\u2500\u2500 routes | | \u2514\u2500\u2500 validator.js | \u251c\u2500\u2500 Dockerfile | \u251c\u2500\u2500 hapify-models.json | \u251c\u2500\u2500 hapify.json | \u2514\u2500\u2500 ... \u2514\u2500\u2500 boilerplate-ngx-dashboard \u251c\u2500\u2500 .hapify | \u251c\u2500\u2500 src | \u2514\u2500\u2500 validator.js \u251c\u2500\u2500 src | \u251c\u2500\u2500 app | \u251c\u2500\u2500 assets | \u251c\u2500\u2500 index.html | \u2514\u2500\u2500 ... \u251c\u2500\u2500 hapify.json \u2514\u2500\u2500 ... hapify.json est le fichier de configuration. Il contient les m\u00e9ta-donn\u00e9es du boilerplate et la liste des templates. Le fichier hapify-models.json contient les mod\u00e8les de donn\u00e9es de votre projet. Il est r\u00e9f\u00e9renc\u00e9 par le fichier de configuration ( hapify.json ). Vous pouvez d\u00e9placer ou renommer ce fichier tant que vous changez le chemin dans le fichier de configuration. Le dossier .hapify (peut aussi \u00eatre nomm\u00e9 hapify ) est le dossier des templates. Il contient tous les templates du boilerplate.","title":"Sortie"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#facultatif-stocker-vos-modeles-de-donnees-sur-hapify-cloud","text":"Par d\u00e9faut, Hapify stocke vos mod\u00e8les de donn\u00e9es localement. Le chemin d'acc\u00e8s est d\u00e9fini dans le fichier de configuration. Vous pouvez stocker vos mod\u00e8les de donn\u00e9es en ligne, afin de les partager sur plusieurs d\u00e9p\u00f4ts. Pour connecter le CLI \u00e0 Hapify Cloud, veuillez suivre ces \u00e9tapes .","title":"Facultatif : Stocker vos mod\u00e8les de donn\u00e9es sur Hapify Cloud"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#connecter-votre-boilerplate-a-un-projet-distant","text":"Ex\u00e9cutez cette commande pour configurer votre boilerplate : hpf use","title":"Connecter votre boilerplate \u00e0 un projet distant"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#creer-un-projet","text":"Vous pouvez cr\u00e9er un projet directement depuis le CLI en s\u00e9lectionnant Create a new project . \u00c0 l'invite, entrez le nom et la description. ? Choose a project Create a new project ? Enter a project name First project ? Enter a project description My first project with Hapify","title":"Cr\u00e9er un projet"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#selectionnez-un-projet-existant","text":"Dans la liste ci-dessous, s\u00e9lectionnez un projet depuis votre compte. ? Choose a project (Use arrow keys) Create a new project \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u276f First project Second project \u00c0 savoir Vous pouvez cr\u00e9er un projet en ligne \u00e0 partir de votre compte Hapify : https://www.hapify.io/my-projects Le boilerplate va maintenant stocker et lire les mod\u00e8les depuis Hapify Cloud. ? Choose a project First project \u2713 Did set project 5c893c0a74e4650010e6f683 for channel HapiJS \u2713 Did set project 5c893c0a74e4650010e6f683 for channel Angular Dashboard L'ID du projet est stock\u00e9 dans le fichier de configuration ( hapify.json ).","title":"S\u00e9lectionnez un projet existant"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/","text":"Ex\u00e9cuter la commande serve . \u00c0 ce stade, vous disposez d'un boilerplate mais pas de mod\u00e8les de donn\u00e9es dans votre projet, sauf si vous avez import\u00e9 des collections de mod\u00e8les de donn\u00e9es pr\u00e9d\u00e9finis. Afin de cr\u00e9er et de modifier les mod\u00e8les de donn\u00e9es de votre projet, ex\u00e9cutez cette commande pour lancer l'interface graphique locale : hpf serve Liste des mod\u00e8les de donn\u00e9es Une fois lanc\u00e9e, l'interface graphique affiche tous les mod\u00e8les de donn\u00e9es. \u00c0 savoir Pour les projets avec beaucoup de mod\u00e8les de donn\u00e9es, vous pouvez filtrer ceux-ci par nom, nom de champ ou r\u00e9f\u00e9rence. Utilisez la barre sup\u00e9rieure droite. Appuyez sur la touche d'\u00e9chappement pour r\u00e9initialiser les filtres. Ajouter et modifier des mod\u00e8les de donn\u00e9es Cliquez sur le bouton New model , entrez un nom et appuyez sur la touche \"Entr\u00e9e\". Le nouveau mod\u00e8le de donn\u00e9es sera rempli avec les champs par d\u00e9faut. Les champs par d\u00e9faut sont d\u00e9finis dans le fichier de configuration du boilerplate ( hapify.json ). \u00c0 savoir Une fois cr\u00e9\u00e9, vous pouvez modifier le nom du mod\u00e8le de donn\u00e9es en cliquant sur celui-ci. Importer des mod\u00e8les de donn\u00e9es pr\u00e9d\u00e9finis Cliquez sur le bouton Import collections , choisissez une collection ( preset ) et validez. Les mod\u00e8les de donn\u00e9es de la collection seront fusionn\u00e9s avec les mod\u00e8les de donn\u00e9es existants en cas de conflit. Supprimer, cloner et copier Cliquez sur les trois points pour afficher ce menu : Copier-coller Lorsque vous copiez un mod\u00e8le de donn\u00e9es, il est ajout\u00e9 en tant que JSON dans votre presse-papiers. Pour coller un mod\u00e8le de donn\u00e9es, cliquez sur Paste from clipboard \u00e0 la fin de la liste des mod\u00e8les de donn\u00e9es. Ceci est utile pour copier-coller des mod\u00e8les de donn\u00e9es entre plusieurs projets. Ajouter et modifier des champs Cliquez sur Add field \u00e0 la fin d'un mod\u00e8le de donn\u00e9es et entrez un nom. Vous pouvez choisir son type et son sous-type : Et aussi ses attributs en cliquant sur l'engrenage : \u00c0 savoir Une fois cr\u00e9\u00e9, vous pouvez modifier le nom du champ en cliquant dessus. Voir aussi Pour en savoir plus sur la gestion des champs, veuillez vous r\u00e9f\u00e9rer \u00e0 la description du mod\u00e8le de donn\u00e9es . Supprimer un champ Cliquez sur l'ic\u00f4ne \"poubelle\" et s\u00e9lectionnez les champs \u00e0 supprimer : Modifier les acc\u00e8s au mod\u00e8le de donn\u00e9es D\u00e9veloppez le panneau de gestion des acc\u00e8s en cliquant sur l'ic\u00f4ne \"empreinte digitale\" en haut d'un mod\u00e8le : Voir aussi Pour en savoir plus sur la gestion des acc\u00e8s, veuillez vous r\u00e9f\u00e9rer \u00e0 la description du mod\u00e8le de donn\u00e9es . Ajouter des notes Vous pouvez laisser des notes sur les mod\u00e8les de donn\u00e9es et leurs champs. Cliquez sur l'ic\u00f4ne \"bulle\" et \u00e9crivez une note. Sur un mod\u00e8le: Sur un champ: Erreurs et avertissements Un boilerplate peut valider les mod\u00e8les de donn\u00e9es que vous \u00e9crivez. Ces erreurs ou avertissements appara\u00eetront lors de la modification des mod\u00e8les de donn\u00e9es.","title":"\u00c9tape 2: \u00c9diter les mod\u00e8les de donn\u00e9es"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#executer-la-commande-serve","text":"\u00c0 ce stade, vous disposez d'un boilerplate mais pas de mod\u00e8les de donn\u00e9es dans votre projet, sauf si vous avez import\u00e9 des collections de mod\u00e8les de donn\u00e9es pr\u00e9d\u00e9finis. Afin de cr\u00e9er et de modifier les mod\u00e8les de donn\u00e9es de votre projet, ex\u00e9cutez cette commande pour lancer l'interface graphique locale : hpf serve","title":"Ex\u00e9cuter la commande serve."},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#liste-des-modeles-de-donnees","text":"Une fois lanc\u00e9e, l'interface graphique affiche tous les mod\u00e8les de donn\u00e9es. \u00c0 savoir Pour les projets avec beaucoup de mod\u00e8les de donn\u00e9es, vous pouvez filtrer ceux-ci par nom, nom de champ ou r\u00e9f\u00e9rence. Utilisez la barre sup\u00e9rieure droite. Appuyez sur la touche d'\u00e9chappement pour r\u00e9initialiser les filtres.","title":"Liste des mod\u00e8les de donn\u00e9es"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#ajouter-et-modifier-des-modeles-de-donnees","text":"Cliquez sur le bouton New model , entrez un nom et appuyez sur la touche \"Entr\u00e9e\". Le nouveau mod\u00e8le de donn\u00e9es sera rempli avec les champs par d\u00e9faut. Les champs par d\u00e9faut sont d\u00e9finis dans le fichier de configuration du boilerplate ( hapify.json ). \u00c0 savoir Une fois cr\u00e9\u00e9, vous pouvez modifier le nom du mod\u00e8le de donn\u00e9es en cliquant sur celui-ci.","title":"Ajouter et modifier des mod\u00e8les de donn\u00e9es"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#importer-des-modeles-de-donnees-predefinis","text":"Cliquez sur le bouton Import collections , choisissez une collection ( preset ) et validez. Les mod\u00e8les de donn\u00e9es de la collection seront fusionn\u00e9s avec les mod\u00e8les de donn\u00e9es existants en cas de conflit.","title":"Importer des mod\u00e8les de donn\u00e9es pr\u00e9d\u00e9finis"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#supprimer-cloner-et-copier","text":"Cliquez sur les trois points pour afficher ce menu :","title":"Supprimer, cloner et copier"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#copier-coller","text":"Lorsque vous copiez un mod\u00e8le de donn\u00e9es, il est ajout\u00e9 en tant que JSON dans votre presse-papiers. Pour coller un mod\u00e8le de donn\u00e9es, cliquez sur Paste from clipboard \u00e0 la fin de la liste des mod\u00e8les de donn\u00e9es. Ceci est utile pour copier-coller des mod\u00e8les de donn\u00e9es entre plusieurs projets.","title":"Copier-coller"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#ajouter-et-modifier-des-champs","text":"Cliquez sur Add field \u00e0 la fin d'un mod\u00e8le de donn\u00e9es et entrez un nom. Vous pouvez choisir son type et son sous-type : Et aussi ses attributs en cliquant sur l'engrenage : \u00c0 savoir Une fois cr\u00e9\u00e9, vous pouvez modifier le nom du champ en cliquant dessus. Voir aussi Pour en savoir plus sur la gestion des champs, veuillez vous r\u00e9f\u00e9rer \u00e0 la description du mod\u00e8le de donn\u00e9es .","title":"Ajouter et modifier des champs"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#supprimer-un-champ","text":"Cliquez sur l'ic\u00f4ne \"poubelle\" et s\u00e9lectionnez les champs \u00e0 supprimer :","title":"Supprimer un champ"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#modifier-les-acces-au-modele-de-donnees","text":"D\u00e9veloppez le panneau de gestion des acc\u00e8s en cliquant sur l'ic\u00f4ne \"empreinte digitale\" en haut d'un mod\u00e8le : Voir aussi Pour en savoir plus sur la gestion des acc\u00e8s, veuillez vous r\u00e9f\u00e9rer \u00e0 la description du mod\u00e8le de donn\u00e9es .","title":"Modifier les acc\u00e8s au mod\u00e8le de donn\u00e9es"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#ajouter-des-notes","text":"Vous pouvez laisser des notes sur les mod\u00e8les de donn\u00e9es et leurs champs. Cliquez sur l'ic\u00f4ne \"bulle\" et \u00e9crivez une note. Sur un mod\u00e8le: Sur un champ:","title":"Ajouter des notes"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#erreurs-et-avertissements","text":"Un boilerplate peut valider les mod\u00e8les de donn\u00e9es que vous \u00e9crivez. Ces erreurs ou avertissements appara\u00eetront lors de la modification des mod\u00e8les de donn\u00e9es.","title":"Erreurs et avertissements"},{"location":"getting-started/existing-boilerplate/step-3-generate/","text":"Ex\u00e9cuter la commande generate Lorsque vos mod\u00e8les de donn\u00e9es seront pr\u00eats, g\u00e9n\u00e9rez le code avec cette commande : hpf generate Ceci lancera le g\u00e9n\u00e9rateur et copiera les fichiers g\u00e9n\u00e9r\u00e9s dans votre boilerplate localement : \u2022 Found channel HapiJS in ~/my-project/boilerplate-hapijs \u2022 Found channel Angular Dashboard in ~/my-project/boilerplate-ngx-dashboard \u2713 Generated 60 files for channel HapiJS \u2713 Generated 189 files for channel Angular Dashboard Vous pouvez maintenant commencer \u00e0 personnaliser et \u00e0 utiliser le code g\u00e9n\u00e9r\u00e9. \u00c0 savoir La commande generate peut g\u00e9rer plusieurs boilerplates ou channels \u00e0 la fois. Pour en savoir plus sur la commande generate , veuillez vous r\u00e9f\u00e9rer \u00e0 cet article . Formater le code Hapify ne formate pas le code de sortie. Cette t\u00e2che est d\u00e9l\u00e9gu\u00e9e au boilerplate lui-m\u00eame. Nous vous recommandons vivement d'utiliser le linter int\u00e9gr\u00e9 au boilerplate, le cas \u00e9ch\u00e9ant, ou d'utiliser le formateur de code de votre IDE.","title":"\u00c9tape 3: G\u00e9n\u00e9rer le code"},{"location":"getting-started/existing-boilerplate/step-3-generate/#executer-la-commande-generate","text":"Lorsque vos mod\u00e8les de donn\u00e9es seront pr\u00eats, g\u00e9n\u00e9rez le code avec cette commande : hpf generate Ceci lancera le g\u00e9n\u00e9rateur et copiera les fichiers g\u00e9n\u00e9r\u00e9s dans votre boilerplate localement : \u2022 Found channel HapiJS in ~/my-project/boilerplate-hapijs \u2022 Found channel Angular Dashboard in ~/my-project/boilerplate-ngx-dashboard \u2713 Generated 60 files for channel HapiJS \u2713 Generated 189 files for channel Angular Dashboard Vous pouvez maintenant commencer \u00e0 personnaliser et \u00e0 utiliser le code g\u00e9n\u00e9r\u00e9. \u00c0 savoir La commande generate peut g\u00e9rer plusieurs boilerplates ou channels \u00e0 la fois. Pour en savoir plus sur la commande generate , veuillez vous r\u00e9f\u00e9rer \u00e0 cet article .","title":"Ex\u00e9cuter la commande generate"},{"location":"getting-started/existing-boilerplate/step-3-generate/#formater-le-code","text":"Hapify ne formate pas le code de sortie. Cette t\u00e2che est d\u00e9l\u00e9gu\u00e9e au boilerplate lui-m\u00eame. Nous vous recommandons vivement d'utiliser le linter int\u00e9gr\u00e9 au boilerplate, le cas \u00e9ch\u00e9ant, ou d'utiliser le formateur de code de votre IDE.","title":"Formater le code"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/","text":"Hapify & Git patch Hapify permet de r\u00e9g\u00e9n\u00e9rer le code cible sans \u00e9craser les modifications que vous avez pu y apporter. Cette fonctionnalit\u00e9 se base sur les commandes git format-patch et git am . Vous pouvez ainsi utiliser Hapify tout au long de votre projet et non pas en d\u00e9marrage seulement. Pr\u00e9paration du d\u00e9p\u00f4t Pour pouvoir utiliser correctement la commande hpf patch , vous devez lancer la g\u00e9n\u00e9ration sur une branche s\u00e9par\u00e9e. Par exemple, cr\u00e9ez une branche nomm\u00e9e hapify . Premi\u00e8re g\u00e9n\u00e9ration Allez sur cette nouvelle branche hapify . Ex\u00e9cutez votre premi\u00e8re g\u00e9n\u00e9ration en utilisant hpf generate . Si vous utilisez un formateur de code, ex\u00e9cutez le apr\u00e8s chaque g\u00e9n\u00e9ration. Commitez ceci. Appelons-le G\u00e9n\u00e9ration 1 . Fusionnez la branche hapify dans votre branche de travail, disons develop . Maintenant vous pouvez commencer \u00e0 travailler sur develop et personnaliser le code cible g\u00e9n\u00e9r\u00e9. Deuxi\u00e8me g\u00e9n\u00e9ration Oh non ! Vous avez oubli\u00e9 quelque chose dans vos mod\u00e8les de donn\u00e9es, les sp\u00e9cifications du projet ont chang\u00e9, ou vous voulez modifier quelques lignes dans vos templates. Si vous utilisez un formateur de code, lancez-le dans votre branche de travail ( develop par exemple). Passez sur la branche hapify . Modifiez vos mod\u00e8les de donn\u00e9es et/ou templates. Lancez la g\u00e9n\u00e9ration et ex\u00e9cutez votre formateur de code (s'il y en a un). Commitez le tout. Appelons-le G\u00e9n\u00e9ration 2 . Appliquez la diff\u00e9rence Vous pouvez maintenant lancer la commande hpf patch pour calculer la diff\u00e9rence entre les commits G\u00e9n\u00e9ration 1 et G\u00e9n\u00e9ration 2 et l'appliquer \u00e0 develop . $ hpf patch ? Choose a source branch hapify ? Choose the first commit [2018-10-19 17:56:40 -0400] Generation 1 ? Choose the second commit [2018-10-22 01:47:18 -0400] Generation 2 ? Choose a destination branch develop Avant de faire quoi que ce soit, cela affichera la commande git qui sera ex\u00e9cut\u00e9e, et demandera une confirmation. Cela devrait ressembler \u00e0 ceci : git format-patch --stdout e5d01ec559aa79b0af8f80839e22e15f3283c752..be93268f6d404c4c7c83c55a6dcb98f4930a0c1c | git am -3 -k Si une erreur s'est produite pendant cette commande git, c'est probablement d\u00fb \u00e0 un conflit de fusion. Si c'est le cas, ouvrez votre \u00e9diteur de code et r\u00e9solvez le conflit. Une fois que c'est fait, lancez git am --continue pour finaliser ou git am --abort pour annuler la fusion.","title":"\u00c9tape 4: Cycle de vie"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/#hapify-git-patch","text":"Hapify permet de r\u00e9g\u00e9n\u00e9rer le code cible sans \u00e9craser les modifications que vous avez pu y apporter. Cette fonctionnalit\u00e9 se base sur les commandes git format-patch et git am . Vous pouvez ainsi utiliser Hapify tout au long de votre projet et non pas en d\u00e9marrage seulement.","title":"Hapify &amp; Git patch"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/#preparation-du-depot","text":"Pour pouvoir utiliser correctement la commande hpf patch , vous devez lancer la g\u00e9n\u00e9ration sur une branche s\u00e9par\u00e9e. Par exemple, cr\u00e9ez une branche nomm\u00e9e hapify .","title":"Pr\u00e9paration du d\u00e9p\u00f4t"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/#premiere-generation","text":"Allez sur cette nouvelle branche hapify . Ex\u00e9cutez votre premi\u00e8re g\u00e9n\u00e9ration en utilisant hpf generate . Si vous utilisez un formateur de code, ex\u00e9cutez le apr\u00e8s chaque g\u00e9n\u00e9ration. Commitez ceci. Appelons-le G\u00e9n\u00e9ration 1 . Fusionnez la branche hapify dans votre branche de travail, disons develop . Maintenant vous pouvez commencer \u00e0 travailler sur develop et personnaliser le code cible g\u00e9n\u00e9r\u00e9.","title":"Premi\u00e8re g\u00e9n\u00e9ration"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/#deuxieme-generation","text":"Oh non ! Vous avez oubli\u00e9 quelque chose dans vos mod\u00e8les de donn\u00e9es, les sp\u00e9cifications du projet ont chang\u00e9, ou vous voulez modifier quelques lignes dans vos templates. Si vous utilisez un formateur de code, lancez-le dans votre branche de travail ( develop par exemple). Passez sur la branche hapify . Modifiez vos mod\u00e8les de donn\u00e9es et/ou templates. Lancez la g\u00e9n\u00e9ration et ex\u00e9cutez votre formateur de code (s'il y en a un). Commitez le tout. Appelons-le G\u00e9n\u00e9ration 2 .","title":"Deuxi\u00e8me g\u00e9n\u00e9ration"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/#appliquez-la-difference","text":"Vous pouvez maintenant lancer la commande hpf patch pour calculer la diff\u00e9rence entre les commits G\u00e9n\u00e9ration 1 et G\u00e9n\u00e9ration 2 et l'appliquer \u00e0 develop . $ hpf patch ? Choose a source branch hapify ? Choose the first commit [2018-10-19 17:56:40 -0400] Generation 1 ? Choose the second commit [2018-10-22 01:47:18 -0400] Generation 2 ? Choose a destination branch develop Avant de faire quoi que ce soit, cela affichera la commande git qui sera ex\u00e9cut\u00e9e, et demandera une confirmation. Cela devrait ressembler \u00e0 ceci : git format-patch --stdout e5d01ec559aa79b0af8f80839e22e15f3283c752..be93268f6d404c4c7c83c55a6dcb98f4930a0c1c | git am -3 -k Si une erreur s'est produite pendant cette commande git, c'est probablement d\u00fb \u00e0 un conflit de fusion. Si c'est le cas, ouvrez votre \u00e9diteur de code et r\u00e9solvez le conflit. Une fois que c'est fait, lancez git am --continue pour finaliser ou git am --abort pour annuler la fusion.","title":"Appliquez la diff\u00e9rence"},{"location":"reference/cli/","text":"Hapify CLI Description Hapify est un outil de g\u00e9n\u00e9ration de code bas\u00e9 sur des mod\u00e8les de donn\u00e9es relationnels. Il utilise un langage de templating d\u00e9di\u00e9. Il affiche une console web pour la d\u00e9finition des mod\u00e8les et l'\u00e9criture des templates. Utilisation Installation Vous devez installer ce package globalement pour obtenir la commande hpf : npm install -g @hapify/cli Pour v\u00e9rifier la version install\u00e9e, ex\u00e9cutez hpf --version . Options globales -V , --version : affiche le num\u00e9ro de version --debug : active le mode d\u00e9bogage (par d\u00e9faut : false ) --silent : active le mode silencieux (par d\u00e9faut : false ) -d <path> , --dir <path> : change le r\u00e9pertoire de travail. Ce chemin peut \u00eatre absolu ou relatif au chemin courant. -k <secret> , --key <secret> : force l'utilisation d'une cl\u00e9 API plut\u00f4t que celle d\u00e9finie dans la configuration globale. Si vous voulez d\u00e9finir votre cl\u00e9 d'API de fa\u00e7on permanente, vous devriez utiliser la commande hpf key . -h , --help : affiche l'aide Commandes D\u00e9finir la configuration globale hpf config [ options ] Cette commande enregistre une ou plusieurs configurations globales dans ~/.hapify/config.json . Si le fichier n'existe pas, il sera automatiquement cr\u00e9\u00e9. Configuration disponible hpf config --apiKey <secret> : d\u00e9finit la cl\u00e9 d'API \u00e0 utiliser pour chaque commande. Ceci est \u00e9quivalent \u00e0 hpf key <key> . hpf config --apiUrl <url> : remplace l'URL d'API par d\u00e9faut. D\u00e9finir la cl\u00e9 d'API globale hpf key <key> Cette commande est un alias de hpf config --apiKey <secret> . Lister les boilerplates (channels) hpf list Alias : hpf ls Cette commande affiche ce qui est visible pour le CLI \u00e0 partir du r\u00e9pertoire courant. Elle affiche la liste des channels et la liste des mod\u00e8les de donn\u00e9es utilis\u00e9s par ces channels. Le CLI recherche les fichiers hapify.json afin de d\u00e9tecter automatiquement les channels. Il r\u00e9it\u00e8re sur les sous-r\u00e9pertoires. La profondeur par d\u00e9faut est de 2 . Pour modifier cette valeur, utilisez l'option depth . hpf list --depth 3 Attention Vous n'\u00eates pas cens\u00e9 ex\u00e9cuter le CLI avec des ensembles de mod\u00e8les de donn\u00e9es diff\u00e9rents. Si c'est le cas, le premier ensemble trouv\u00e9 sera utilis\u00e9. G\u00e9n\u00e9rer le code hpf generate Alias : hpf g Cette commande g\u00e9n\u00e8re tous les channels trouv\u00e9s \u00e0 partir de leurs templates et mod\u00e8les de donn\u00e9es. Pour d\u00e9finir la profondeur de la recherche de channels, utilisez cette option : --depth <n> . La valeur par d\u00e9faut est 2 . hpf generate --depth 3 \u00c0 savoir Les fichiers g\u00e9n\u00e9r\u00e9s vides ne seront pas sauvegard\u00e9s. Exporter le code hpf export Alias : hpf x Cette commande g\u00e9n\u00e8re un channel \u00e0 partir de ses templates et de ses mod\u00e8les de donn\u00e9es puis sauvegarde les fichiers g\u00e9n\u00e9r\u00e9s dans un fichier zip. Vous devez lancer cette commande \u00e0 partir du r\u00e9pertoire du channel, au niveau du fichier hapify.json . Par d\u00e9faut, le fichier zip porte le nom du dossier du channel. Exemple : angular-admin/angular-admin.zip . Vous pouvez d\u00e9finir un chemin personnalis\u00e9 avec cette option : -o, --output <path> . hpf export -o /path/to/file.zip \u00c0 savoir Les fichiers g\u00e9n\u00e9r\u00e9s vides ne seront pas sauvegard\u00e9s. Importez des mod\u00e8les de donn\u00e9es hpf import Alias : hpf m Utilisez cette commande pour importer des mod\u00e8les de donn\u00e9es pr\u00e9d\u00e9finis depuis Hapify Cloud (appel\u00e9s presets ). Importer des presets \u00e0 partir d'ID Vous pouvez \u00e9galement importer des pr\u00e9r\u00e9glages \u00e0 partir de leurs ID (visibles sur Hapify Hub ) hpf import --preset ab123 --preset bd456 Cloner un boilerplate et d\u00e9marrer un nouveau projet hpf new Alias : hpf n Cette commande vous permet de cloner et de configurer un boilerplate. Elle vous demandera de : s\u00e9lectionner un boilerplate s\u00e9lectionner ou cr\u00e9er le projet \u00e0 utiliser s\u00e9lectionner des presets de mod\u00e8les de donn\u00e9es \u00e0 importer Options -p <id> , --project <id> : Le projet \u00e0 utiliser (s'il existe d\u00e9j\u00e0) -b <slug> , --boilerplate <slug> : Le slug du boilerplate \u00e0 cloner --boilerplate-id <id> : L'ID du boilerplate \u00e0 cloner --boilerplate-url [url] : Les URL git des boilerplates \u00e0 cloner --preset [id] : ID des presets \u00e0 pr\u00e9charger dans le projet --no-presets : Ne pas demander de presets --project-name <name> : Le nom du projet \u00e0 cr\u00e9er --project-desc <description> : La description du projet \u00e0 cr\u00e9er (le nom doit \u00eatre d\u00e9fini) Pour consulter les presets disponibles, visitez hub.hapify.io . Cr\u00e9er un nouveau boilerplate/channel hpf init Alias : hpf i Cette commande cr\u00e9e une nouvelle structure de fichiers Hapify dans le r\u00e9pertoire courant. Elle cr\u00e9e 2 fichiers hapify.json , hapify-models.json et un dossier .hapify contenant un template models/__kebab__/hello.js.hpf . Elle vous demandera de s\u00e9lectionner ou de cr\u00e9er un projet. Options --channel-name <name> : Le nom du channel \u00e0 initialiser --channel-desc <description> : La description du channel \u00e0 initialiser --channel-logo <url> : L'URL du logo du channel \u00e0 initialiser --project-name <name> : Le nom du projet \u00e0 cr\u00e9er --project-desc <description> : La description du projet \u00e0 cr\u00e9er D\u00e9finir le projet \u00e0 utiliser dans un boilerplate/channel hpf use Alias : hpf u Change le projet utilis\u00e9 par un ou plusieurs channels existants. Change l'ID du projet dans le fichier hapify.json pour chaque channel trouv\u00e9. Elle vous demandera de s\u00e9lectionner ou de cr\u00e9er le projet \u00e0 utiliser. Options -p <id> , --project <id> : Le projet \u00e0 utiliser (s'il est d\u00e9j\u00e0 cr\u00e9\u00e9) --project-name <name> : Le nom du projet \u00e0 cr\u00e9er --project-desc <description> : La description du projet \u00e0 cr\u00e9er Appliquer un patch au code g\u00e9n\u00e9r\u00e9 avec de nouveaux mod\u00e8les de donn\u00e9es Au cours du processus de d\u00e9veloppement, vous pouvez ajouter, modifier ou supprimer certains mod\u00e8les. Pour fusionner automatiquement la diff\u00e9rence entre deux g\u00e9n\u00e9rations \u00e0 votre branche de travail, utilisez cette commande. Cette commande utilise git format-patch et git am . hpf patch Elle vous permettra de choisir la branche source et le commit, puis la branche de destination. D\u00e9marrer la console Ex\u00e9cutez cette commande pour modifier les mod\u00e8les de donn\u00e9es et les templates. hpf serve Ceci d\u00e9marrera une console web pour l'\u00e9dition des mod\u00e8les de donn\u00e9es et des templates. Options -p <n> , --port <n> : Le port requis (par d\u00e9faut entre 4800 et 4820 ) -H <hostname> , --hostname <hostname> : Le nom d'h\u00f4te requis (par d\u00e9faut : localhost ) --no-open : Ne pas ouvrir un nouvel onglet dans le navigateur pour afficher la console --depth <n> : Profondeur pour la recherche de channels (par d\u00e9faut : 2 )","title":"CLI"},{"location":"reference/cli/#hapify-cli","text":"","title":"Hapify CLI"},{"location":"reference/cli/#description","text":"Hapify est un outil de g\u00e9n\u00e9ration de code bas\u00e9 sur des mod\u00e8les de donn\u00e9es relationnels. Il utilise un langage de templating d\u00e9di\u00e9. Il affiche une console web pour la d\u00e9finition des mod\u00e8les et l'\u00e9criture des templates.","title":"Description"},{"location":"reference/cli/#utilisation","text":"","title":"Utilisation"},{"location":"reference/cli/#installation","text":"Vous devez installer ce package globalement pour obtenir la commande hpf : npm install -g @hapify/cli Pour v\u00e9rifier la version install\u00e9e, ex\u00e9cutez hpf --version .","title":"Installation"},{"location":"reference/cli/#options-globales","text":"-V , --version : affiche le num\u00e9ro de version --debug : active le mode d\u00e9bogage (par d\u00e9faut : false ) --silent : active le mode silencieux (par d\u00e9faut : false ) -d <path> , --dir <path> : change le r\u00e9pertoire de travail. Ce chemin peut \u00eatre absolu ou relatif au chemin courant. -k <secret> , --key <secret> : force l'utilisation d'une cl\u00e9 API plut\u00f4t que celle d\u00e9finie dans la configuration globale. Si vous voulez d\u00e9finir votre cl\u00e9 d'API de fa\u00e7on permanente, vous devriez utiliser la commande hpf key . -h , --help : affiche l'aide","title":"Options globales"},{"location":"reference/cli/#commandes","text":"","title":"Commandes"},{"location":"reference/cli/#definir-la-configuration-globale","text":"hpf config [ options ] Cette commande enregistre une ou plusieurs configurations globales dans ~/.hapify/config.json . Si le fichier n'existe pas, il sera automatiquement cr\u00e9\u00e9. Configuration disponible hpf config --apiKey <secret> : d\u00e9finit la cl\u00e9 d'API \u00e0 utiliser pour chaque commande. Ceci est \u00e9quivalent \u00e0 hpf key <key> . hpf config --apiUrl <url> : remplace l'URL d'API par d\u00e9faut.","title":"D\u00e9finir la configuration globale"},{"location":"reference/cli/#definir-la-cle-dapi-globale","text":"hpf key <key> Cette commande est un alias de hpf config --apiKey <secret> .","title":"D\u00e9finir la cl\u00e9 d'API globale"},{"location":"reference/cli/#lister-les-boilerplates-channels","text":"hpf list Alias : hpf ls Cette commande affiche ce qui est visible pour le CLI \u00e0 partir du r\u00e9pertoire courant. Elle affiche la liste des channels et la liste des mod\u00e8les de donn\u00e9es utilis\u00e9s par ces channels. Le CLI recherche les fichiers hapify.json afin de d\u00e9tecter automatiquement les channels. Il r\u00e9it\u00e8re sur les sous-r\u00e9pertoires. La profondeur par d\u00e9faut est de 2 . Pour modifier cette valeur, utilisez l'option depth . hpf list --depth 3 Attention Vous n'\u00eates pas cens\u00e9 ex\u00e9cuter le CLI avec des ensembles de mod\u00e8les de donn\u00e9es diff\u00e9rents. Si c'est le cas, le premier ensemble trouv\u00e9 sera utilis\u00e9.","title":"Lister les boilerplates (channels)"},{"location":"reference/cli/#generer-le-code","text":"hpf generate Alias : hpf g Cette commande g\u00e9n\u00e8re tous les channels trouv\u00e9s \u00e0 partir de leurs templates et mod\u00e8les de donn\u00e9es. Pour d\u00e9finir la profondeur de la recherche de channels, utilisez cette option : --depth <n> . La valeur par d\u00e9faut est 2 . hpf generate --depth 3 \u00c0 savoir Les fichiers g\u00e9n\u00e9r\u00e9s vides ne seront pas sauvegard\u00e9s.","title":"G\u00e9n\u00e9rer le code"},{"location":"reference/cli/#exporter-le-code","text":"hpf export Alias : hpf x Cette commande g\u00e9n\u00e8re un channel \u00e0 partir de ses templates et de ses mod\u00e8les de donn\u00e9es puis sauvegarde les fichiers g\u00e9n\u00e9r\u00e9s dans un fichier zip. Vous devez lancer cette commande \u00e0 partir du r\u00e9pertoire du channel, au niveau du fichier hapify.json . Par d\u00e9faut, le fichier zip porte le nom du dossier du channel. Exemple : angular-admin/angular-admin.zip . Vous pouvez d\u00e9finir un chemin personnalis\u00e9 avec cette option : -o, --output <path> . hpf export -o /path/to/file.zip \u00c0 savoir Les fichiers g\u00e9n\u00e9r\u00e9s vides ne seront pas sauvegard\u00e9s.","title":"Exporter le code"},{"location":"reference/cli/#importez-des-modeles-de-donnees","text":"hpf import Alias : hpf m Utilisez cette commande pour importer des mod\u00e8les de donn\u00e9es pr\u00e9d\u00e9finis depuis Hapify Cloud (appel\u00e9s presets ). Importer des presets \u00e0 partir d'ID Vous pouvez \u00e9galement importer des pr\u00e9r\u00e9glages \u00e0 partir de leurs ID (visibles sur Hapify Hub ) hpf import --preset ab123 --preset bd456","title":"Importez des mod\u00e8les de donn\u00e9es"},{"location":"reference/cli/#cloner-un-boilerplate-et-demarrer-un-nouveau-projet","text":"hpf new Alias : hpf n Cette commande vous permet de cloner et de configurer un boilerplate. Elle vous demandera de : s\u00e9lectionner un boilerplate s\u00e9lectionner ou cr\u00e9er le projet \u00e0 utiliser s\u00e9lectionner des presets de mod\u00e8les de donn\u00e9es \u00e0 importer Options -p <id> , --project <id> : Le projet \u00e0 utiliser (s'il existe d\u00e9j\u00e0) -b <slug> , --boilerplate <slug> : Le slug du boilerplate \u00e0 cloner --boilerplate-id <id> : L'ID du boilerplate \u00e0 cloner --boilerplate-url [url] : Les URL git des boilerplates \u00e0 cloner --preset [id] : ID des presets \u00e0 pr\u00e9charger dans le projet --no-presets : Ne pas demander de presets --project-name <name> : Le nom du projet \u00e0 cr\u00e9er --project-desc <description> : La description du projet \u00e0 cr\u00e9er (le nom doit \u00eatre d\u00e9fini) Pour consulter les presets disponibles, visitez hub.hapify.io .","title":"Cloner un boilerplate et d\u00e9marrer un nouveau projet"},{"location":"reference/cli/#creer-un-nouveau-boilerplatechannel","text":"hpf init Alias : hpf i Cette commande cr\u00e9e une nouvelle structure de fichiers Hapify dans le r\u00e9pertoire courant. Elle cr\u00e9e 2 fichiers hapify.json , hapify-models.json et un dossier .hapify contenant un template models/__kebab__/hello.js.hpf . Elle vous demandera de s\u00e9lectionner ou de cr\u00e9er un projet. Options --channel-name <name> : Le nom du channel \u00e0 initialiser --channel-desc <description> : La description du channel \u00e0 initialiser --channel-logo <url> : L'URL du logo du channel \u00e0 initialiser --project-name <name> : Le nom du projet \u00e0 cr\u00e9er --project-desc <description> : La description du projet \u00e0 cr\u00e9er","title":"Cr\u00e9er un nouveau boilerplate/channel"},{"location":"reference/cli/#definir-le-projet-a-utiliser-dans-un-boilerplatechannel","text":"hpf use Alias : hpf u Change le projet utilis\u00e9 par un ou plusieurs channels existants. Change l'ID du projet dans le fichier hapify.json pour chaque channel trouv\u00e9. Elle vous demandera de s\u00e9lectionner ou de cr\u00e9er le projet \u00e0 utiliser. Options -p <id> , --project <id> : Le projet \u00e0 utiliser (s'il est d\u00e9j\u00e0 cr\u00e9\u00e9) --project-name <name> : Le nom du projet \u00e0 cr\u00e9er --project-desc <description> : La description du projet \u00e0 cr\u00e9er","title":"D\u00e9finir le projet \u00e0 utiliser dans un boilerplate/channel"},{"location":"reference/cli/#appliquer-un-patch-au-code-genere-avec-de-nouveaux-modeles-de-donnees","text":"Au cours du processus de d\u00e9veloppement, vous pouvez ajouter, modifier ou supprimer certains mod\u00e8les. Pour fusionner automatiquement la diff\u00e9rence entre deux g\u00e9n\u00e9rations \u00e0 votre branche de travail, utilisez cette commande. Cette commande utilise git format-patch et git am . hpf patch Elle vous permettra de choisir la branche source et le commit, puis la branche de destination.","title":"Appliquer un patch au code g\u00e9n\u00e9r\u00e9 avec de nouveaux mod\u00e8les de donn\u00e9es"},{"location":"reference/cli/#demarrer-la-console","text":"Ex\u00e9cutez cette commande pour modifier les mod\u00e8les de donn\u00e9es et les templates. hpf serve Ceci d\u00e9marrera une console web pour l'\u00e9dition des mod\u00e8les de donn\u00e9es et des templates. Options -p <n> , --port <n> : Le port requis (par d\u00e9faut entre 4800 et 4820 ) -H <hostname> , --hostname <hostname> : Le nom d'h\u00f4te requis (par d\u00e9faut : localhost ) --no-open : Ne pas ouvrir un nouvel onglet dans le navigateur pour afficher la console --depth <n> : Profondeur pour la recherche de channels (par d\u00e9faut : 2 )","title":"D\u00e9marrer la console"},{"location":"reference/ejs-javascript/","text":"Hapify offre la possibilit\u00e9 d'\u00e9crire des template avec la syntaxe EJS ou bien en JavaScript pur. Ces deux options se basent sur le m\u00eame objet d\u00e9crit ci-dessous. Objet mod\u00e8le Les templates de type one model re\u00e7oivent l'objet mod\u00e8le via la variable model (alias m ). Dans le cas d'un template de type all models , un tableau d'objets mod\u00e8les sera disponible via la variable models (alias m ). Le bloc suivant est une repr\u00e9sentation en JSON de cet objet mod\u00e8le pour un cas tr\u00e8s simple. Ici, le mod\u00e8le User profile poss\u00e8de 3 champs dont une r\u00e9f\u00e9rence \u00e0 une entit\u00e9. Pour garder ce JSON aussi court que possible, nous avons supprim\u00e9 tous les alias, de nombreuses propri\u00e9t\u00e9s r\u00e9currentes et les d\u00e9tails des sous-mod\u00e8les. Ce JSON est une repr\u00e9sentation partielle de l'objet mod\u00e8le r\u00e9ellement inject\u00e9, mais il vous donne un bon aper\u00e7u de sa structure. Voir aussi Si vous voulez conna\u00eetre la structure compl\u00e8te de l'objet mod\u00e8le, vous pouvez vous r\u00e9f\u00e9rer \u00e0 la documentation de l'objet mod\u00e8le , ou bien \u00e0 l'interface TypeScript ExplicitModel dans le code source de hapify/generator . { \"id\" : \"b0993d03-70d1-0448-1eef-25bde4818d15\" , \"name\" : \"User profile\" , \"names\" : { \"raw\" : \"User profile\" , \"kebab\" : \"user-profile\" , \"snake\" : \"user_profile\" , \"header\" : \"User-Profile\" , \"constant\" : \"USER_PROFILE\" , \"big\" : \"USER-PROFILE\" , \"capital\" : \"User Profile\" , \"lower\" : \"user profile\" , \"upper\" : \"USER PROFILE\" , \"compact\" : \"userprofile\" , \"pascal\" : \"UserProfile\" , \"camel\" : \"userProfile\" }, \"fields\" : { \"list\" : [ { \"names\" : { \"raw\" : \"_id\" , \"kebab\" : \"-id\" , \"snake\" : \"_id\" , \"header\" : \"-Id\" , \"constant\" : \"_ID\" , \"big\" : \"-ID\" , \"capital\" : \"_Id\" , \"lower\" : \"_id\" , \"upper\" : \"_ID\" , \"compact\" : \"id\" , \"pascal\" : \"Id\" , \"camel\" : \"id\" }, \"name\" : \"_id\" , \"notes\" : null , \"type\" : \"string\" , \"subtype\" : null , \"value\" : null , \"primary\" : true , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false }, { \"names\" : { \"raw\" : \"created at\" , \"kebab\" : \"created-at\" , \"snake\" : \"created_at\" , \"header\" : \"Created-At\" , \"constant\" : \"CREATED_AT\" , \"big\" : \"CREATED-AT\" , \"capital\" : \"Created At\" , \"lower\" : \"created at\" , \"upper\" : \"CREATED AT\" , \"compact\" : \"createdat\" , \"pascal\" : \"CreatedAt\" , \"camel\" : \"createdAt\" }, \"name\" : \"created at\" , \"notes\" : null , \"type\" : \"datetime\" , \"subtype\" : null , \"value\" : null , \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : true , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false }, { \"names\" : { \"raw\" : \"avatar\" , \"kebab\" : \"avatar\" , \"snake\" : \"avatar\" , \"header\" : \"Avatar\" , \"constant\" : \"AVATAR\" , \"big\" : \"AVATAR\" , \"capital\" : \"Avatar\" , \"lower\" : \"avatar\" , \"upper\" : \"AVATAR\" , \"compact\" : \"avatar\" , \"pascal\" : \"Avatar\" , \"camel\" : \"avatar\" }, \"name\" : \"avatar\" , \"notes\" : null , \"type\" : \"entity\" , \"subtype\" : null , \"value\" : \"ac046aac-7a20-de65-2209-57e80a2bbea4\" , \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : false , \"restricted\" : false , \"ownership\" : false , \"model\" : \"// Avatar model details...\" }, { \"names\" : { \"raw\" : \"role\" , \"kebab\" : \"role\" , \"snake\" : \"role\" , \"header\" : \"Role\" , \"constant\" : \"ROLE\" , \"big\" : \"ROLE\" , \"capital\" : \"Role\" , \"lower\" : \"role\" , \"upper\" : \"ROLE\" , \"compact\" : \"role\" , \"pascal\" : \"Role\" , \"camel\" : \"role\" }, \"name\" : \"role\" , \"notes\" : null , \"type\" : \"enum\" , \"subtype\" : null , \"value\" : [ \"admin\" , \"user\" , \"customer\" ], \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : true , \"sortable\" : false , \"hidden\" : false , \"internal\" : false , \"restricted\" : false , \"ownership\" : false , \"enum\" : [ { \"name\" : \"admin\" , \"names\" : { \"raw\" : \"admin\" , \"kebab\" : \"admin\" , \"snake\" : \"admin\" , \"header\" : \"Admin\" , \"constant\" : \"ADMIN\" , \"big\" : \"ADMIN\" , \"capital\" : \"Admin\" , \"lower\" : \"admin\" , \"upper\" : \"ADMIN\" , \"compact\" : \"admin\" , \"pascal\" : \"Admin\" , \"camel\" : \"admin\" } }, \"// Same structure for each enum\" ] } ], \"primary\" : \"// Primary field details...\" , \"unique\" : [ \"// unique fields details (if any)...\" ], \"label\" : [ \"// label fields details (if any)...\" ], \"nullable\" : [ \"// nullable fields details (if any)...\" ], \"multiple\" : [ \"// multiple fields details (if any)...\" ], \"embedded\" : [ \"// embedded fields details (if any)...\" ], \"searchable\" : [ \"// searchable fields details (if any)...\" ], \"sortable\" : [ \"// sortable fields details (if any)...\" ], \"hidden\" : [ \"// hidden fields details (if any)...\" ], \"internal\" : [ \"// internal fields details (if any)...\" ], \"restricted\" : [ \"// internal fields details (if any)...\" ], \"ownership\" : [ \"// ownership fields details (if any)...\" ], \"searchableLabel\" : [ \"// searchableLabel fields details (if any)...\" ], \"references\" : [ \"// references fields details (if any)...\" ] }, \"properties\" : { \"fieldsCount\" : 3 , \"hasPrimary\" : true , \"hasUnique\" : false , \"hasLabel\" : false , \"hasNullable\" : false , \"hasMultiple\" : false , \"hasEmbedded\" : false , \"hasSearchable\" : false , \"hasSortable\" : true , \"hasHidden\" : false , \"hasInternal\" : true , \"hasRestricted\" : false , \"hasOwnership\" : false , \"hasSearchableLabel\" : false , \"mainlyHidden\" : false , \"mainlyInternal\" : true , \"isGeolocated\" : false , \"isGeoSearchable\" : false , \"hasDependencies\" : true , \"isReferenced\" : false }, \"accesses\" : { \"list\" : [ { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true }, { \"action\" : \"read\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true } ], \"properties\" : { \"onlyAdmin\" : false , \"onlyOwner\" : false , \"onlyAuth\" : false , \"onlyGuest\" : true , \"maxAdmin\" : false , \"maxOwner\" : false , \"maxAuth\" : false , \"maxGuest\" : true , \"noAdmin\" : true , \"noOwner\" : true , \"noAuth\" : true , \"noGuest\" : false , \"hasAdmin\" : false , \"hasOwner\" : false , \"hasAuth\" : false , \"hasGuest\" : true }, \"admin\" : [], \"owner\" : [], \"auth\" : [], \"guest\" : [ { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true } ], \"create\" : { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true }, \"read\" : \"// Same structure as create\" , \"update\" : \"// Same structure as create\" , \"remove\" : \"// Same structure as create\" , \"search\" : \"// Same structure as create\" , \"count\" : \"// Same structure as create\" }, \"dependencies\" : { \"list\" : [ \"// Avatar model details...\" ], \"self\" : false }, \"referencedIn\" : [ \"// Referring models come here, populated with entity fields only.\" ] } Templating Voici des exemples de template EJS et JavaScript utilisant cet objet mod\u00e8le. Template de type one model EJS class <%= model . names . pascal %> { private primaryKey = '<%= model.fields.primary.names.snake %>' ; } JavaScript return `class ${ model . names . pascal } { private primaryKey = ' ${ model . fields . primary . names . snake } '; }` ; Sortie class Place { private primaryKey = '_id' ; } Attention Un template JavaScript doit retourner une cha\u00eene de caract\u00e8res. \u00c0 savoir Les fichiers g\u00e9n\u00e9r\u00e9s vides ne seront pas sauvegard\u00e9s. Template de type all models EJS <% for ( let model of models ) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models ) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Sortie require_once('./user.php'); require_once('./place.php'); require_once('./service.php'); require_once('./place-category.php'); Voir aussi Pour plus d'exemples de templates, veuillez lire cet article .","title":"EJS & JavaScript"},{"location":"reference/ejs-javascript/#objet-modele","text":"Les templates de type one model re\u00e7oivent l'objet mod\u00e8le via la variable model (alias m ). Dans le cas d'un template de type all models , un tableau d'objets mod\u00e8les sera disponible via la variable models (alias m ). Le bloc suivant est une repr\u00e9sentation en JSON de cet objet mod\u00e8le pour un cas tr\u00e8s simple. Ici, le mod\u00e8le User profile poss\u00e8de 3 champs dont une r\u00e9f\u00e9rence \u00e0 une entit\u00e9. Pour garder ce JSON aussi court que possible, nous avons supprim\u00e9 tous les alias, de nombreuses propri\u00e9t\u00e9s r\u00e9currentes et les d\u00e9tails des sous-mod\u00e8les. Ce JSON est une repr\u00e9sentation partielle de l'objet mod\u00e8le r\u00e9ellement inject\u00e9, mais il vous donne un bon aper\u00e7u de sa structure. Voir aussi Si vous voulez conna\u00eetre la structure compl\u00e8te de l'objet mod\u00e8le, vous pouvez vous r\u00e9f\u00e9rer \u00e0 la documentation de l'objet mod\u00e8le , ou bien \u00e0 l'interface TypeScript ExplicitModel dans le code source de hapify/generator . { \"id\" : \"b0993d03-70d1-0448-1eef-25bde4818d15\" , \"name\" : \"User profile\" , \"names\" : { \"raw\" : \"User profile\" , \"kebab\" : \"user-profile\" , \"snake\" : \"user_profile\" , \"header\" : \"User-Profile\" , \"constant\" : \"USER_PROFILE\" , \"big\" : \"USER-PROFILE\" , \"capital\" : \"User Profile\" , \"lower\" : \"user profile\" , \"upper\" : \"USER PROFILE\" , \"compact\" : \"userprofile\" , \"pascal\" : \"UserProfile\" , \"camel\" : \"userProfile\" }, \"fields\" : { \"list\" : [ { \"names\" : { \"raw\" : \"_id\" , \"kebab\" : \"-id\" , \"snake\" : \"_id\" , \"header\" : \"-Id\" , \"constant\" : \"_ID\" , \"big\" : \"-ID\" , \"capital\" : \"_Id\" , \"lower\" : \"_id\" , \"upper\" : \"_ID\" , \"compact\" : \"id\" , \"pascal\" : \"Id\" , \"camel\" : \"id\" }, \"name\" : \"_id\" , \"notes\" : null , \"type\" : \"string\" , \"subtype\" : null , \"value\" : null , \"primary\" : true , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false }, { \"names\" : { \"raw\" : \"created at\" , \"kebab\" : \"created-at\" , \"snake\" : \"created_at\" , \"header\" : \"Created-At\" , \"constant\" : \"CREATED_AT\" , \"big\" : \"CREATED-AT\" , \"capital\" : \"Created At\" , \"lower\" : \"created at\" , \"upper\" : \"CREATED AT\" , \"compact\" : \"createdat\" , \"pascal\" : \"CreatedAt\" , \"camel\" : \"createdAt\" }, \"name\" : \"created at\" , \"notes\" : null , \"type\" : \"datetime\" , \"subtype\" : null , \"value\" : null , \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : true , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false }, { \"names\" : { \"raw\" : \"avatar\" , \"kebab\" : \"avatar\" , \"snake\" : \"avatar\" , \"header\" : \"Avatar\" , \"constant\" : \"AVATAR\" , \"big\" : \"AVATAR\" , \"capital\" : \"Avatar\" , \"lower\" : \"avatar\" , \"upper\" : \"AVATAR\" , \"compact\" : \"avatar\" , \"pascal\" : \"Avatar\" , \"camel\" : \"avatar\" }, \"name\" : \"avatar\" , \"notes\" : null , \"type\" : \"entity\" , \"subtype\" : null , \"value\" : \"ac046aac-7a20-de65-2209-57e80a2bbea4\" , \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : false , \"restricted\" : false , \"ownership\" : false , \"model\" : \"// Avatar model details...\" }, { \"names\" : { \"raw\" : \"role\" , \"kebab\" : \"role\" , \"snake\" : \"role\" , \"header\" : \"Role\" , \"constant\" : \"ROLE\" , \"big\" : \"ROLE\" , \"capital\" : \"Role\" , \"lower\" : \"role\" , \"upper\" : \"ROLE\" , \"compact\" : \"role\" , \"pascal\" : \"Role\" , \"camel\" : \"role\" }, \"name\" : \"role\" , \"notes\" : null , \"type\" : \"enum\" , \"subtype\" : null , \"value\" : [ \"admin\" , \"user\" , \"customer\" ], \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : true , \"sortable\" : false , \"hidden\" : false , \"internal\" : false , \"restricted\" : false , \"ownership\" : false , \"enum\" : [ { \"name\" : \"admin\" , \"names\" : { \"raw\" : \"admin\" , \"kebab\" : \"admin\" , \"snake\" : \"admin\" , \"header\" : \"Admin\" , \"constant\" : \"ADMIN\" , \"big\" : \"ADMIN\" , \"capital\" : \"Admin\" , \"lower\" : \"admin\" , \"upper\" : \"ADMIN\" , \"compact\" : \"admin\" , \"pascal\" : \"Admin\" , \"camel\" : \"admin\" } }, \"// Same structure for each enum\" ] } ], \"primary\" : \"// Primary field details...\" , \"unique\" : [ \"// unique fields details (if any)...\" ], \"label\" : [ \"// label fields details (if any)...\" ], \"nullable\" : [ \"// nullable fields details (if any)...\" ], \"multiple\" : [ \"// multiple fields details (if any)...\" ], \"embedded\" : [ \"// embedded fields details (if any)...\" ], \"searchable\" : [ \"// searchable fields details (if any)...\" ], \"sortable\" : [ \"// sortable fields details (if any)...\" ], \"hidden\" : [ \"// hidden fields details (if any)...\" ], \"internal\" : [ \"// internal fields details (if any)...\" ], \"restricted\" : [ \"// internal fields details (if any)...\" ], \"ownership\" : [ \"// ownership fields details (if any)...\" ], \"searchableLabel\" : [ \"// searchableLabel fields details (if any)...\" ], \"references\" : [ \"// references fields details (if any)...\" ] }, \"properties\" : { \"fieldsCount\" : 3 , \"hasPrimary\" : true , \"hasUnique\" : false , \"hasLabel\" : false , \"hasNullable\" : false , \"hasMultiple\" : false , \"hasEmbedded\" : false , \"hasSearchable\" : false , \"hasSortable\" : true , \"hasHidden\" : false , \"hasInternal\" : true , \"hasRestricted\" : false , \"hasOwnership\" : false , \"hasSearchableLabel\" : false , \"mainlyHidden\" : false , \"mainlyInternal\" : true , \"isGeolocated\" : false , \"isGeoSearchable\" : false , \"hasDependencies\" : true , \"isReferenced\" : false }, \"accesses\" : { \"list\" : [ { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true }, { \"action\" : \"read\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true } ], \"properties\" : { \"onlyAdmin\" : false , \"onlyOwner\" : false , \"onlyAuth\" : false , \"onlyGuest\" : true , \"maxAdmin\" : false , \"maxOwner\" : false , \"maxAuth\" : false , \"maxGuest\" : true , \"noAdmin\" : true , \"noOwner\" : true , \"noAuth\" : true , \"noGuest\" : false , \"hasAdmin\" : false , \"hasOwner\" : false , \"hasAuth\" : false , \"hasGuest\" : true }, \"admin\" : [], \"owner\" : [], \"auth\" : [], \"guest\" : [ { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true } ], \"create\" : { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true }, \"read\" : \"// Same structure as create\" , \"update\" : \"// Same structure as create\" , \"remove\" : \"// Same structure as create\" , \"search\" : \"// Same structure as create\" , \"count\" : \"// Same structure as create\" }, \"dependencies\" : { \"list\" : [ \"// Avatar model details...\" ], \"self\" : false }, \"referencedIn\" : [ \"// Referring models come here, populated with entity fields only.\" ] }","title":"Objet mod\u00e8le"},{"location":"reference/ejs-javascript/#templating","text":"Voici des exemples de template EJS et JavaScript utilisant cet objet mod\u00e8le.","title":"Templating"},{"location":"reference/ejs-javascript/#template-de-type-one-model","text":"EJS class <%= model . names . pascal %> { private primaryKey = '<%= model.fields.primary.names.snake %>' ; } JavaScript return `class ${ model . names . pascal } { private primaryKey = ' ${ model . fields . primary . names . snake } '; }` ; Sortie class Place { private primaryKey = '_id' ; } Attention Un template JavaScript doit retourner une cha\u00eene de caract\u00e8res. \u00c0 savoir Les fichiers g\u00e9n\u00e9r\u00e9s vides ne seront pas sauvegard\u00e9s.","title":"Template de type one model"},{"location":"reference/ejs-javascript/#template-de-type-all-models","text":"EJS <% for ( let model of models ) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models ) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Sortie require_once('./user.php'); require_once('./place.php'); require_once('./service.php'); require_once('./place-category.php'); Voir aussi Pour plus d'exemples de templates, veuillez lire cet article .","title":"Template de type all models"},{"location":"reference/hapify-syntax/","text":"Pourquoi utiliser une syntaxe sp\u00e9cifique ? Nous avons con\u00e7u une syntaxe capable de manipuler l'objet mod\u00e8le inject\u00e9 dans les templates. Cette syntaxe est optimis\u00e9e pour jouer avec les propri\u00e9t\u00e9s de cet objet mod\u00e8le en utilisant des mots courts. Cela permet de g\u00e9rer des id\u00e9es complexes avec des phrases simples. Par exemple, cette boucle en JavaScript : for ( let field of root . fields . filter ( f => f . searchable && f . type === 'entity' )) { out += ' Do something' ; } sera \u00e9crit comme ceci avec la syntaxe Hapify : Hapify (long) <<for Fields searchable and entity field >> Do something <<endfor>> Hapify (short) <<@ F se * tE f >> Do something <<@>> Syntaxes longue et courte Les templates Hapify peuvent \u00eatre \u00e9crits avec une syntaxe longue ou courte. Chacune a ses avantages : La syntaxe courte n'interf\u00e8re pas avec le code cible lors de la lecture du template, gr\u00e2ce \u00e0 un m\u00e9ta-code plus court. La syntaxe longue est explicite et peut \u00eatre lue naturellement. Dans un m\u00eame template, vous pouvez m\u00e9langer les deux syntaxes. Note Tous les exemples de codes ci-dessous sont traduits en \u00e9quivalent JavaScript \u00e0 titre informatif. Lors de la g\u00e9n\u00e9ration, la syntaxe Hapify est convertie en code JavaScript semblable. Balises Les blocs de syntaxe Hapify sont envelopp\u00e9s par deux balises : ouverture : << . fermeture : >> . \u00c9chappement G\u00e9n\u00e9ralement utilis\u00e9es pour les op\u00e9rations binaires, ces balises peuvent \u00eatre \u00e9chapp\u00e9es. Les balises \u00e9chapp\u00e9es \\<\\< (et \\>\\> ) sont remplac\u00e9es par << (et >> ) lors de la g\u00e9n\u00e9ration. Noms Noms du mod\u00e8le de donn\u00e9es Dans un template de type one model : Hapify (long) // Create a new <<Model lower>> const <<Model camel>> = new <<Model pascal>> (); Hapify (short) // Create a new <<M a>> const <<M aA>> = new <<M AA>> (); \u00c9quivalent JavaScript out += `// Create a new ${ root . names . lower } const ${ root . names . camel } = new ${ root . names . pascal } ();` ; Pour un mod\u00e8le de donn\u00e9es nomm\u00e9 user group , le r\u00e9sultat sera le suivant : // Create a new user group const userGroup = new UserGroup (); Noms des champs Lister tous les champs d'un mod\u00e8le de donn\u00e9es : Hapify (long) <?php $fields = array( <<for Fields field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ F f >> ' <<f aA>> ', <<@>> ); \u00c9quivalent JavaScript out += `<?php $fields = array( ${ root . fields . list . map ( f => \"'\" + f . names . camel + \"'\" ). join ( \",\\n\\t\" ) } );` ; Pour un mod\u00e8le de donn\u00e9es avec les champs name , created at et role : <?php $fields = array ( 'name' , 'createdAt' , 'role' , ); Casses Les casses disponibles sont : camel (alias : aA ) pour camelCase pascal (alias : AA ) pour PascalCase lower (alias : a ) pour lower case capital (alias : A ) pour Capital Case kebab (alias : a-a ) pour kebab-case header (alias : A-A ) pour Header-Case snake (alias : a_a ) pour snake_case constant (alias : A_A ) pour CONSTANT_CASE compact (alias : aa ) pour compactcase raw (alias : R ) (raw) pour le nom original Conditions Condition simple Hapify (long) const utils = require('utils'); <<if Fields entity >> const mongoDb = require('mongodb'); <<endif>> Hapify (short) const utils = require('utils'); <<? F tE >> const mongoDb = require('mongodb'); <<?>> \u00c9quivalent JavaScript out += `const utils = require('utils');` ; if ( root . fields . filter ( f => f . type === 'entity' ). length > 0 ) { out += ` \\ nconst mongoDb = require('mongodb');` ; } Pour un mod\u00e8le de donn\u00e9es qui contient au moins un champ de type entity , le r\u00e9sultat sera le suivant : const utils = require ( 'utils' ); const mongoDb = require ( 'mongodb' ); Pour un mod\u00e8le qui ne contient pas de champ de type entity , le r\u00e9sultat sera le suivant : const utils = require ( 'utils' ); Sans filtre Le filtrage des champs est optionnel. Hapify (long) <<if Fields >> // this model has at least one field <<endif>> Hapify (short) <<? F >> // this model has at least one field <<?>> \u00c9quivalent JavaScript if ( root . fields . list . length > 0 ) { out += ' // this model has at least one field' ; } Conditions alternatives Hapify (long) <<if Fields entity >> // At least one entity field <<elseif Fields hidden >> // No entity field and at least one hidden field <<else>> // No entity field and no hidden field <<endif>> Hapify (short) <<? F tE >> // At least one entity field <<?? F hd >> // No entity field and at least one hidden field <<??>> // No entity field and no hidden field <<?>> \u00c9quivalent JavaScript if ( root . fields . filter ( f => f . type === 'entity' ). length > 0 ) { out += ' // At least one entity field' ; } else if ( root . fields . filter ( f => f . hidden ). length > 0 ) { out += ' // No entity field and at least one hidden field' ; } else { out += ' // No entity field and no hidden field' ; } Conditions complexes Op\u00e9rateurs Les op\u00e9rateurs disponibles pour \u00e9crire les conditions sont : and - alias * ou && or - alias + ou || and not - alias andNot , / ou && ! or not - alias orNot , - ou || ! Exemple Hapify (long) <<if Fields ( entity and hidden ) or ( unique and not multiple ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<endif>> Hapify (short) <<? F ( tE * hd ) + ( un / ml ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<?>> \u00c9quivalent JavaScript for ( let field of root . fields . filter ( f => ( f . type === 'entity' && f . hidden ) || ( f . unique && ! f . multiple ))) { out += ' // ...' ; } Les conditions peuvent \u00e9galement \u00eatre \u00e9crites avec des op\u00e9rateurs natifs. R\u00e9\u00e9crivons cette derni\u00e8re condition : Hapify (long) <<if Fields ( entity && hidden ) || ( unique && !multiple ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<endif>> Hapify (short) <<? F ( tE && hd ) || ( un && !ml ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<?>> \u00c9quivalent JavaScript for ( let field of root . fields . filter ( f => ( f . type === 'entity' && f . hidden ) || ( f . unique && ! f . multiple ))) { out += ' // ...' ; } Conditions relatives au nombre d'occurrences En pr\u00e9cisant un nombre apr\u00e8s le if , on peut ajouter une condition sur le nombre minimum d\u2019\u00e9l\u00e9ments requis, ici les champs : Hapify (long) <<if 4 Fields hidden >> // This model has at least 4 hidden fields <<elseif 2 Fields label or boolean >> // This model has at least 2 label or boolean fields <<else>> // Something else <<endif>> Hapify (short) <<? 4 F hd >> // This model has at least 4 hidden fields <<?? 2 F lb + tB >> // This model has at least 2 label or boolean fields <<??>> // Something else <<?>> \u00c9quivalent JavaScript if ( root . fields . filter ( f => f . hidden ). length >= 4 ) { out += ' // This model has at least 4 hidden fields' ; } else if ( root . fields . filter ( f => f . label || f . type === 'boolean' ). length >= 2 ) { out += ' // This model has at least 2 label or boolean fields' ; } else { out += ' // Something else' ; } Conditions sur les mod\u00e8les de donn\u00e9es Tester un seul mod\u00e8le de donn\u00e9es Dans un template de type one model : Hapify (long) <<if Model isGeolocated >> // This block is reached if the model is geolocated. // that's means it has at least one latitude field and one longitude field <<endif>> Hapify (short) <<? M pGeo >> // This block is reached if the model is geolocated. // that's means it has at least one latitude field and one longitude field <<?>> \u00c9quivalent JavaScript if ( root . properties . isGeolocated ) { out += ' // ...' ; } Tester une liste de mod\u00e8les de donn\u00e9es Dans un template de type all models : Hapify (long) <<if Models not onlyGuest >> // This block is reached if at least one model has not only guest actions import 'session-service'; <<endif>> Hapify (short) <<? M !pOGs >> // This block is reached if at least one model has not only guest actions import 'session-service'; <<?>> \u00c9quivalent JavaScript if ( root . filter ( m => ! m . accesses . properties . onlyGuest ). length > 0 ) { out += \" import 'session-service';\" ; } Objets et filtres disponibles Objet racine Model ou Models (abr\u00e9g\u00e9 : M ) font r\u00e9f\u00e9rence \u00e0 l'objet principal : le mod\u00e8le de donn\u00e9es dans un template de type one model le tableau de mod\u00e8les de donn\u00e9es dans un template de type all models Objets filtrables et testables Dans le cas d'un template de type one model : Fields (alias: F ) est la liste des champs Dependencies (alias: D ) est la liste des d\u00e9pendances (liste de mod\u00e8les de donn\u00e9es) ReferencedIn (alias: RefModels , R ) est la liste des mod\u00e8les de donn\u00e9es qui d\u00e9pendent de celui-ci PrimaryField (alias: P ) est le champ primaire du mod\u00e8le Accesses (alias: A ) est la liste des acc\u00e8s CreateAccess (alias: Ac ) est l'acc\u00e8s \u00e0 l'action de cr\u00e9ation ReadAccess (alias: Ar ) est l'acc\u00e8s \u00e0 l'action de lecture UpdateAccess (alias: Au ) est l'acc\u00e8s \u00e0 l'action de mise \u00e0 jour RemoveAccess (alias: Ad ) est l'acc\u00e8s \u00e0 l'action de suppression SearchAccess (alias: As ) est l'acc\u00e8s \u00e0 l'action de recherche CountAccess (alias: An ) est l'acc\u00e8s \u00e0 l'action de comptage Filtrage sur les attributs de champ Attributs disponibles pour un champ : primary (alias: pr ) pour le bool\u00e9en primary unique (alias: un ) pour le bool\u00e9en unique label (alias: lb ) pour le bool\u00e9en label nullable (alias: nu ) pour le bool\u00e9en nullable multiple (alias: ml ) pour le bool\u00e9en multiple embedded (alias: em ) pour le bool\u00e9en embedded searchable (alias: se ) pour le bool\u00e9en searchable sortable (alias: so ) pour le bool\u00e9en sortable hidden (alias: hd ) pour le bool\u00e9en hidden internal (alias: in ) pour le bool\u00e9en internal restricted (alias: rs ) pour le bool\u00e9en restricted ownership (alias: os ) pour le bool\u00e9en ownership string (alias: tS ) pour le type string email (alias: tSe ) pour le type string et le sous-type email password (alias: tSp ) pour le type string et le sous-type password url (alias: tSu ) pour le type string et le sous-type url text (alias: tSt ) pour le type string et le sous-type text richText (alias: rich , tSr ) pour le type string et le sous-type rich number (alias: tN ) pour le type number integer (alias: tNi ) pour le type number et le sous-type integer float (alias: tNf ) pour le type number et le sous-type float latitude (alias: tNt ) pour le type number et le sous-type latitude longitude (alias: tNg ) pour le type number et le sous-type longitude boolean (alias: tB ) pour le type boolean datetime (alias: tD ) pour le type datetime date (alias: tDd ) pour le type datetime et le sous-type date time (alias: tDt ) pour le type datetime et le sous-type time enum (alias: tU ) pour le type enum entity (alias: tE ) pour le type entity oneOne (alias: tEoo ) pour le type entity et le sous-type oneOne oneMany (alias: tEom ) pour le type entity et le sous-type oneMany manyOne (alias: tEmo ) pour le type entity et le sous-type manyOne manyMany (alias: tEmm ) pour le type entity et le sous-type manyMany object (alias: tO ) pour le type object file (alias: tF ) pour le type file image (alias: tFi ) pour le type file et le sous-type image video (alias: tFv ) pour le type file et le sous-type video audio (alias: tFa ) pour le type file et le sous-type audio document (alias: tFd ) pour le type file et le sous-type document Exemple Hapify (long) <<if Fields ( restricted or internal ) and not number >> // Current model has at least one field matching to the condition <<endif>> Hapify (short) <<? F ( rs + in ) / tN >> // Current model has at least one field matching to the condition <<?>> \u00c9quivalent JavaScript if ( root . fields . filter ( f => ( f . restricted || f . internal ) && ! f . number ). length > 0 ) { out += \" // ...\" ; } Filtrage sur les propri\u00e9t\u00e9s du mod\u00e8le de donn\u00e9es Propri\u00e9t\u00e9s disponibles pour un mod\u00e8le de donn\u00e9es : mainlyHidden (alias: pMHd ) la majorit\u00e9 des champs sont hidden (strictement) mainlyInternal (alias: pMIn ) la majorit\u00e9 des champs sont internal (strictement) isGeolocated (alias: pGeo ) Le mod\u00e8le de donn\u00e9es contient au moins un champ latitude et un champ longitude . isGeoSearchable (alias: pGSe ) Le mod\u00e8le de donn\u00e9es contient au moins un champ latitude et un champ longitude recherchables. Exemple Hapify (long) <<if Model isGeolocated >> // This model contains at least one latitude field and one longitude field. <<endif>> Hapify (short) <<? M pGeo >> // This model contains at least one latitude field and one longitude field. <<?>> \u00c9quivalent JavaScript if ( root . properties . isGeolocated ) { out += \" // ...\" ; } Propri\u00e9t\u00e9s d'acc\u00e8s disponibles pour un mod\u00e8le de donn\u00e9es : onlyAdmin (alias: pOAd ) Le mod\u00e8le de donn\u00e9es ne contient que des acc\u00e8s restreints \u00e0 admin onlyOwner (alias: pOOw ) Le mod\u00e8le de donn\u00e9es ne contient que des acc\u00e8s restreints \u00e0 owner onlyAuth (alias: pOAu ) Le mod\u00e8le de donn\u00e9es ne contient que des acc\u00e8s restreints \u00e0 authenticated onlyGuest (alias: pOGs ) Le mod\u00e8le de donn\u00e9es ne contient que des acc\u00e8s restreints \u00e0 guest maxAdmin (alias: pMAd ) L'acc\u00e8s le plus permissif est admin maxOwner (alias: pMOw ) L'acc\u00e8s le plus permissif est owner maxAuth (alias: pMAu ) L'acc\u00e8s le plus permissif est authenticated maxGuest (alias: pMGs ) L'acc\u00e8s le plus permissif est guest noAdmin (alias: pNAd ) Aucune action n'est restreinte \u00e0 admin noOwner (alias: pNOw ) Aucune action n'est restreinte \u00e0 owner noAuth (alias: pNAu ) Aucune action n'est restreinte \u00e0 authenticated noGuest (alias: pNGs ) Aucune action n'est restreinte \u00e0 guest Exemple Hapify (long) <<if Model onlyAdmin >> // All actions on this model are restricted to admins <<endif>> Hapify (short) <<? M pOAd >> // All actions on this model are restricted to admins <<?>> \u00c9quivalent JavaScript if ( root . accesses . properties . onlyAdmin ) { out += \" // ...\" ; } Filtrage sur les acc\u00e8s aux mod\u00e8les de donn\u00e9es Rappel guest est l'acc\u00e8s le plus permissif et admin le moins permissif. Par cons\u00e9quent admin < owner < authenticated < guest . Filtres disponibles pour l'acc\u00e8s \u00e0 une action : admin (alias: ad ) l'acc\u00e8s est admin owner (alias: ow ) l'acc\u00e8s est owner auth (alias: au ) l'acc\u00e8s est auth guest (alias: gs ) l'acc\u00e8s est guest gteAdmin (alias: [ad ) l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 admin gteOwner (alias: [ow ) l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 owner gteAuth (alias: [au ) l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 auth gteGuest (alias: [gs ) l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 guest lteAdmin (alias: ad] ) l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 admin lteOwner (alias: ow] ) l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 owner lteAuth (alias: au] ) l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 auth lteGuest (alias: gs] ) l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 guest Exemples Teste l'acc\u00e8s pour une action pr\u00e9cise : Hapify (long) <<if ReadAccess guest >> // Anyone can read this model <<endif>> Hapify (short) <<? Ar gs >> // Anyone can read this model <<?>> \u00c9quivalent JavaScript if ( root . accesses . read . guest ) { out += ' // ...' ; } Teste si l'action de mise \u00e0 jour est restreinte soit aux administrateurs soit au propri\u00e9taire : Hapify (long) <<if UpdateAccess admin or owner >> // ... <<endif>> Hapify (short) <<? Au ad + ow >> // ... <<?>> \u00c9quivalent JavaScript if ( root . accesses . update . admin || root . accesses . update . owner ) { out += ' // ...' ; } Teste si au moins une action est restreinte \u00e0 un utilisateur authentifi\u00e9 ou moins : Hapify (long) <<if Accesses lteAuth >> // ... <<endif>> Hapify (short) <<? A au] >> // ... <<?>> \u00c9quivalent JavaScript if ( root . accesses . filter ( a => a . lteAuth ). length > 0 ) { out += ' // ...' ; } \u00c0 savoir Les conditions peuvent \u00eatre utilis\u00e9es sur un objet ou un tableau d'objets. S'il est utilis\u00e9 sur un tableau, il testera la longueur du tableau filtr\u00e9 par la condition fournie. Il peut \u00eatre utilis\u00e9 sur n'importe quel objet contenant une m\u00e9thode filter qui re\u00e7oit un callback retournant un bool\u00e9en. Par exemple, dans la structure du mod\u00e8le de donn\u00e9es, root.dependencies est un objet qui contient une m\u00e9thode filter . Ainsi, cet op\u00e9rateur peut tester si un mod\u00e8le a des d\u00e9pendances qui ont des champs avec une condition sp\u00e9cifique. It\u00e9rations Les it\u00e9rations utilisent les m\u00eames filtres et op\u00e9rateurs que les conditions. It\u00e9ration simple Boucle sur tous les champs d'un mod\u00e8le de donn\u00e9es qui ne sont pas cach\u00e9s et les assigne \u00e0 la variable field : Hapify (long) <?php $fields = array( <<for Fields not hidden field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ F !hd f >> ' <<f aA>> ', <<@>> ); \u00c9quivalent JavaScript out += `<?php $fields = array( ${ root . fields . filter ( f => ! f . hidden ) . map ( f => \"'\" + f . names . camel + \"'\" ) . join ( \",\\n\\t\" ) } );` ; Exemple pour un mod\u00e8le de donn\u00e9es avec les champs name , created at et role , dont role est cach\u00e9 : <?php $fields = array ( 'name' , 'createdAt' , ); Boucle sur les champs de type entity et recherchables du mod\u00e8le de donn\u00e9es : Hapify (long) <<for Fields searchable and entity field >> // ... <<endfor>> Hapify (short) <<@ F se * tE f >> // ... <<@>> \u00c9quivalent JavaScript for ( let field of root . fields . filter ( f => f . searchable && f . type === 'entity' )) { out += ' // ...' ; } Boucler sans filtrer Cette op\u00e9ration permet de passer en revue tous les champs : Hapify (long) <<for Fields field >> // ... <<endfor>> Hapify (short) <<@ F f >> // ... <<@>> \u00c9quivalent JavaScript for ( let field of root . fields . list ) { out += ' // ...' ; } Boucler sur les mod\u00e8les de donn\u00e9es Dans un template de type all models , ceci boucle sur tous les mod\u00e8les de donn\u00e9es qui sont g\u00e9o-localis\u00e9s : Hapify (long) <<for Models isGeolocated model >> // ... <<endfor>> Hapify (short) <<@ M pGeo m >> // ... <<@>> \u00c9quivalent JavaScript for ( let model of root . filter ( i => i . properties . isGeolocated )) { out += ' // ...' ; } Boucler sur les d\u00e9pendances Dans un template de type one model , ceci boucle sur les d\u00e9pendances dont le champ r\u00e9f\u00e9rent est recherchable : Hapify (long) <<for Dependencies searchable dep >> // ... <<endfor>> Hapify (short) <<@ D se d >> // ... <<@>> \u00c9quivalent JavaScript for ( let dep of root . dependencies . filter ( f => f . searchable )) { out += ' // ...' ; } \u00c0 savoir Dans le cas d'un mod\u00e8le de donn\u00e9es qui se r\u00e9f\u00e8re \u00e0 lui-m\u00eame, Dependencies exclue cette auto-d\u00e9pendance. Pour l'inclure utilisez le code suivant: <<< for (let dep of root.dependencies.filter(f => f, false)) { >>> // ... <<< } >>> Attention Le filtrage de Dependencies ne s'effectue que sur les champs du mod\u00e8le de donn\u00e9es courant qui portent la r\u00e9f\u00e9rence. Le filtrage ne s'effectue pas sur les champs du mod\u00e8le de donn\u00e9es cible. Boucler sur les mod\u00e8les de donn\u00e9es r\u00e9f\u00e9rents Dans un template de type one model , ceci boucle sur les mod\u00e8les de donn\u00e9es ayant une d\u00e9pendance envers celui-ci et qui sont g\u00e9o-localis\u00e9s : Hapify (long) <<for ReferencedIn isGeolocated referrer >> // ... <<endfor>> Hapify (short) <<@ R pGeo r >> // ... <<@>> \u00c9quivalent JavaScript for ( let referrer of root . referencedIn . filter ( m => m . properties . isGeolocated )) { out += ' // ...' ; } \u00c0 savoir Le filtre est optionnel. Vous pouvez obtenir tous les mod\u00e8les de donn\u00e9es r\u00e9f\u00e9rents comme ceci : <<for ReferencedIn referrer >> // ... <<endfor>> Attention Seuls les champs de type entit\u00e9 faisant r\u00e9f\u00e9rence sont d\u00e9finis dans ces mod\u00e8les de donn\u00e9es r\u00e9f\u00e9rents. Boucler sur les acc\u00e8s du mod\u00e8le de donn\u00e9es Boucle sur tous les acc\u00e8s restreints \u00e0 un administrateur ou au propri\u00e9taire et affiche le nom de l'action : Hapify (long) <<for Accesses admin or owner access >> <<=access.action>> <<endfor>> Hapify (short) <<@ A ad + ow a >> <<=a.action>> <<@>> \u00c9quivalent JavaScript for ( let access of root . accesses . filter ( a => a . admin || a . owner )) { out += ` ${ access . action } \\ n` ; } It\u00e9ration raccourcie Boucle sur les 2 premiers champs d'un mod\u00e8le de donn\u00e9es : Hapify (long) <?php $fields = array( <<for 2 Fields field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ 2 F f >> ' <<f aA>> ', <<@>> ); \u00c9quivalent JavaScript out += `<?php $fields = array( ${ root . fields . list . slice ( 0 , 2 ) . map ( f => \"'\" + f . names . camel + \"'\" ) . join ( \",\\n\\t\" ) } );` ; Pour un mod\u00e8le de donn\u00e9es avec les champs name , email et role : <?php $fields = array ( 'name' , 'email' , ); It\u00e9rations imbriqu\u00e9es Boucle sur les enum Dans un template de type one model , ce bloc d\u00e9finit un type TypeScript contenant les \u00e9num\u00e9rations d'un champ : Hapify (long) <<for Fields enum field >> type <<field pascal>> = <<for field . enum e >> | '<<e snake >> '<<endfor >> ; <<endfor>> Hapify (short) <<@ F tU f >> type <<f AA>> = <<@ f . e e >> | '<<e a_a >> '<<@ >> ; <<@>> \u00c9quivalent JavaScript for ( let field of root . fields . filter ( f => f . type === 'enum' )) { out += `type ${ field . names . pascal } = ${ field . enum . map ( e => \"'\" + e . names . snake + \"'\" ). join ( ' | ' ) } ;` ; } Sortie type Role = | 'admin' | 'user' | 'customer' ; Boucler sur les champs de tous les mod\u00e8les de donn\u00e9es Dans un template de type all models , ce bloc permet de passer en revue tous les champs de tous les mod\u00e8les de donn\u00e9es : Hapify (long) const models = { <<for Models model >> <<m camel>> : [ <<for model . fields field >> ' <<field camel>> ', <<endfor>> ], <<endfor>> } Hapify (short) const models = { <<@ M m >> <<m aA>> : [ <<@ m . f f >> ' <<f aA>> ', <<@>> ], <<@>> } Sortie const models = { user : [ 'id' , 'createdAt' , 'email' , 'name' , ], place : [ 'id' , 'name' , 'category' , ], placeCategory : [ 'id' , 'createdAt' , 'email' , 'name' , ], } Entr\u00e9es brutes et interpolation Cet op\u00e9rateur vous permet d'\u00e9crire du JavaScript pur. Variable personnalis\u00e9e D\u00e9finit une variable personnalis\u00e9e et l'ajoute \u00e0 la sortie : <<< const length = root.fields.length; >>> // This model has <<=length>> fields Fonction personnalis\u00e9e D\u00e9finit une fonction personnalis\u00e9e et l'appelle : Hapify (long) <<< function fieldName(field) { return field.names.snake.replace('_', ':'); } >>> <<for Fields field >> <<=fieldName(field)>> <<endfor>> Hapify (short) <<< function fieldName(f) { return f.names.snake.replace('_', ':'); } >>> <<@ F f >> <<=fieldName(f)>> <<@>> Sortie id created:at place:category Condition ou it\u00e9ration personnalis\u00e9e Ce bloc permet d'\u00e9crire une condition non g\u00e9r\u00e9e par la syntaxe Hapify : <<< if (root.fields.hidden.length < 3 || root.properties.mainlyInternal) { >>> // ... <<< } >>> \u00c0 savoir Dans un template Hapify de type one model , la variable root pointe vers le mod\u00e8le de donn\u00e9es. Dans un template Hapify de type all models , la variable root pointe vers le tableau de mod\u00e8les de donn\u00e9es. Voir aussi Pour connaitre en d\u00e9tail la structure du mod\u00e8le de donn\u00e9es, reportez-vous \u00e0 l'objet mod\u00e8le . Erreur N'\u00e9crivez pas ceci : <<= JSON.stringify(root) >> . L'objet root a des propri\u00e9t\u00e9s r\u00e9cursives. Par cons\u00e9quent, cette commande conduira \u00e0 une boucle infinie. Commentaires Cette syntaxe \u00e9crit un commentaire dans le template sans aucune sortie dans le fichier g\u00e9n\u00e9r\u00e9. <<# This is just a comment>> \u00c9chappement Il est possible d'\u00e9chapper les balises de la syntaxe Hapify avec le caract\u00e8re \\ : Hapify $val = 4; $res = $val \\<\\< 3; $res = 4 \\>\\> $val; Sortie $val = 4; $res = $val << 3; $res = 4 >> $val; Formatage Les lignes vides ou ne contenant que du m\u00e9ta-code de type condition ou it\u00e9ration sont automatiquement supprim\u00e9es suite \u00e0 la g\u00e9n\u00e9ration. Pour forcer le g\u00e9n\u00e9rateur \u00e0 garder une ligne vide, ins\u00e9rez un ou plusieurs espaces au d\u00e9but de celle-ci. Attention Hapify ne formate pas le code g\u00e9n\u00e9r\u00e9, car les r\u00e8gles de mise en forme sont sp\u00e9cifiques \u00e0 chaque langage voire chaque framework. Nous vous recommandons vivement d'utiliser un formateur de code suite \u00e0 la g\u00e9n\u00e9ration. Mots r\u00e9serv\u00e9s La liste suivante de mots ne peut pas \u00eatre utilis\u00e9e pour nommer des variables. A , Ac , Accesses , Ad , An , Ar , As , Au , CountAccess , CreateAccess , D , Dependencies , F , Fields , M , Model , Models , P , PrimaryField , R , ReadAccess , RefModels , ReferencedIn , RemoveAccess , SearchAccess , UpdateAccess , ad , admin , and , andNot , au , audio , auth , boolean , date , datetime , document , else , elseif , em , email , embedded , endfor , endif , entity , enum , file , float , for , gs , gteAdmin , gteAuth , gteGuest , gteOwner , guest , hd , hidden , if , image , in , integer , internal , isGeoSearchable , isGeolocated , label , latitude , lb , longitude , lteAdmin , lteAuth , lteGuest , lteOwner , mainlyHidden , mainlyInternal , manyMany , manyOne , maxAdmin , maxAuth , maxGuest , maxOwner , ml , multiple , noAdmin , noAuth , noGuest , noOwner , not , nu , nullable , number , object , oneMany , oneOne , onlyAdmin , onlyAuth , onlyGuest , onlyOwner , or , orNot , os , out , ow , owner , ownership , pGSe , pGeo , pMAd , pMAu , pMGs , pMHd , pMIn , pMOw , pNAd , pNAu , pNGs , pNOw , pOAd , pOAu , pOGs , pOOw , password , pr , primary , restricted , rich , richText , root , rs , se , searchable , so , sortable , string , tB , tD , tDd , tDt , tE , tEmm , tEom , tEoo , tF , tFa , tFd , tFi , tFv , tN , tNf , tNg , tNi , tNt , tO , tS , tSe , tSp , tSr , tSt , tSu , tU , text , time , un , unique , url , video .","title":"Syntaxe Hapify"},{"location":"reference/hapify-syntax/#pourquoi-utiliser-une-syntaxe-specifique","text":"Nous avons con\u00e7u une syntaxe capable de manipuler l'objet mod\u00e8le inject\u00e9 dans les templates. Cette syntaxe est optimis\u00e9e pour jouer avec les propri\u00e9t\u00e9s de cet objet mod\u00e8le en utilisant des mots courts. Cela permet de g\u00e9rer des id\u00e9es complexes avec des phrases simples. Par exemple, cette boucle en JavaScript : for ( let field of root . fields . filter ( f => f . searchable && f . type === 'entity' )) { out += ' Do something' ; } sera \u00e9crit comme ceci avec la syntaxe Hapify : Hapify (long) <<for Fields searchable and entity field >> Do something <<endfor>> Hapify (short) <<@ F se * tE f >> Do something <<@>>","title":"Pourquoi utiliser une syntaxe sp\u00e9cifique ?"},{"location":"reference/hapify-syntax/#syntaxes-longue-et-courte","text":"Les templates Hapify peuvent \u00eatre \u00e9crits avec une syntaxe longue ou courte. Chacune a ses avantages : La syntaxe courte n'interf\u00e8re pas avec le code cible lors de la lecture du template, gr\u00e2ce \u00e0 un m\u00e9ta-code plus court. La syntaxe longue est explicite et peut \u00eatre lue naturellement. Dans un m\u00eame template, vous pouvez m\u00e9langer les deux syntaxes. Note Tous les exemples de codes ci-dessous sont traduits en \u00e9quivalent JavaScript \u00e0 titre informatif. Lors de la g\u00e9n\u00e9ration, la syntaxe Hapify est convertie en code JavaScript semblable.","title":"Syntaxes longue et courte"},{"location":"reference/hapify-syntax/#balises","text":"Les blocs de syntaxe Hapify sont envelopp\u00e9s par deux balises : ouverture : << . fermeture : >> .","title":"Balises"},{"location":"reference/hapify-syntax/#echappement","text":"G\u00e9n\u00e9ralement utilis\u00e9es pour les op\u00e9rations binaires, ces balises peuvent \u00eatre \u00e9chapp\u00e9es. Les balises \u00e9chapp\u00e9es \\<\\< (et \\>\\> ) sont remplac\u00e9es par << (et >> ) lors de la g\u00e9n\u00e9ration.","title":"\u00c9chappement"},{"location":"reference/hapify-syntax/#noms","text":"","title":"Noms"},{"location":"reference/hapify-syntax/#noms-du-modele-de-donnees","text":"Dans un template de type one model : Hapify (long) // Create a new <<Model lower>> const <<Model camel>> = new <<Model pascal>> (); Hapify (short) // Create a new <<M a>> const <<M aA>> = new <<M AA>> (); \u00c9quivalent JavaScript out += `// Create a new ${ root . names . lower } const ${ root . names . camel } = new ${ root . names . pascal } ();` ; Pour un mod\u00e8le de donn\u00e9es nomm\u00e9 user group , le r\u00e9sultat sera le suivant : // Create a new user group const userGroup = new UserGroup ();","title":"Noms du mod\u00e8le de donn\u00e9es"},{"location":"reference/hapify-syntax/#noms-des-champs","text":"Lister tous les champs d'un mod\u00e8le de donn\u00e9es : Hapify (long) <?php $fields = array( <<for Fields field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ F f >> ' <<f aA>> ', <<@>> ); \u00c9quivalent JavaScript out += `<?php $fields = array( ${ root . fields . list . map ( f => \"'\" + f . names . camel + \"'\" ). join ( \",\\n\\t\" ) } );` ; Pour un mod\u00e8le de donn\u00e9es avec les champs name , created at et role : <?php $fields = array ( 'name' , 'createdAt' , 'role' , );","title":"Noms des champs"},{"location":"reference/hapify-syntax/#casses","text":"Les casses disponibles sont : camel (alias : aA ) pour camelCase pascal (alias : AA ) pour PascalCase lower (alias : a ) pour lower case capital (alias : A ) pour Capital Case kebab (alias : a-a ) pour kebab-case header (alias : A-A ) pour Header-Case snake (alias : a_a ) pour snake_case constant (alias : A_A ) pour CONSTANT_CASE compact (alias : aa ) pour compactcase raw (alias : R ) (raw) pour le nom original","title":"Casses"},{"location":"reference/hapify-syntax/#conditions","text":"","title":"Conditions"},{"location":"reference/hapify-syntax/#condition-simple","text":"Hapify (long) const utils = require('utils'); <<if Fields entity >> const mongoDb = require('mongodb'); <<endif>> Hapify (short) const utils = require('utils'); <<? F tE >> const mongoDb = require('mongodb'); <<?>> \u00c9quivalent JavaScript out += `const utils = require('utils');` ; if ( root . fields . filter ( f => f . type === 'entity' ). length > 0 ) { out += ` \\ nconst mongoDb = require('mongodb');` ; } Pour un mod\u00e8le de donn\u00e9es qui contient au moins un champ de type entity , le r\u00e9sultat sera le suivant : const utils = require ( 'utils' ); const mongoDb = require ( 'mongodb' ); Pour un mod\u00e8le qui ne contient pas de champ de type entity , le r\u00e9sultat sera le suivant : const utils = require ( 'utils' );","title":"Condition simple"},{"location":"reference/hapify-syntax/#sans-filtre","text":"Le filtrage des champs est optionnel. Hapify (long) <<if Fields >> // this model has at least one field <<endif>> Hapify (short) <<? F >> // this model has at least one field <<?>> \u00c9quivalent JavaScript if ( root . fields . list . length > 0 ) { out += ' // this model has at least one field' ; }","title":"Sans filtre"},{"location":"reference/hapify-syntax/#conditions-alternatives","text":"Hapify (long) <<if Fields entity >> // At least one entity field <<elseif Fields hidden >> // No entity field and at least one hidden field <<else>> // No entity field and no hidden field <<endif>> Hapify (short) <<? F tE >> // At least one entity field <<?? F hd >> // No entity field and at least one hidden field <<??>> // No entity field and no hidden field <<?>> \u00c9quivalent JavaScript if ( root . fields . filter ( f => f . type === 'entity' ). length > 0 ) { out += ' // At least one entity field' ; } else if ( root . fields . filter ( f => f . hidden ). length > 0 ) { out += ' // No entity field and at least one hidden field' ; } else { out += ' // No entity field and no hidden field' ; }","title":"Conditions alternatives"},{"location":"reference/hapify-syntax/#conditions-complexes","text":"","title":"Conditions complexes"},{"location":"reference/hapify-syntax/#operateurs","text":"Les op\u00e9rateurs disponibles pour \u00e9crire les conditions sont : and - alias * ou && or - alias + ou || and not - alias andNot , / ou && ! or not - alias orNot , - ou || ! Exemple Hapify (long) <<if Fields ( entity and hidden ) or ( unique and not multiple ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<endif>> Hapify (short) <<? F ( tE * hd ) + ( un / ml ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<?>> \u00c9quivalent JavaScript for ( let field of root . fields . filter ( f => ( f . type === 'entity' && f . hidden ) || ( f . unique && ! f . multiple ))) { out += ' // ...' ; } Les conditions peuvent \u00e9galement \u00eatre \u00e9crites avec des op\u00e9rateurs natifs. R\u00e9\u00e9crivons cette derni\u00e8re condition : Hapify (long) <<if Fields ( entity && hidden ) || ( unique && !multiple ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<endif>> Hapify (short) <<? F ( tE && hd ) || ( un && !ml ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<?>> \u00c9quivalent JavaScript for ( let field of root . fields . filter ( f => ( f . type === 'entity' && f . hidden ) || ( f . unique && ! f . multiple ))) { out += ' // ...' ; }","title":"Op\u00e9rateurs"},{"location":"reference/hapify-syntax/#conditions-relatives-au-nombre-doccurrences","text":"En pr\u00e9cisant un nombre apr\u00e8s le if , on peut ajouter une condition sur le nombre minimum d\u2019\u00e9l\u00e9ments requis, ici les champs : Hapify (long) <<if 4 Fields hidden >> // This model has at least 4 hidden fields <<elseif 2 Fields label or boolean >> // This model has at least 2 label or boolean fields <<else>> // Something else <<endif>> Hapify (short) <<? 4 F hd >> // This model has at least 4 hidden fields <<?? 2 F lb + tB >> // This model has at least 2 label or boolean fields <<??>> // Something else <<?>> \u00c9quivalent JavaScript if ( root . fields . filter ( f => f . hidden ). length >= 4 ) { out += ' // This model has at least 4 hidden fields' ; } else if ( root . fields . filter ( f => f . label || f . type === 'boolean' ). length >= 2 ) { out += ' // This model has at least 2 label or boolean fields' ; } else { out += ' // Something else' ; }","title":"Conditions relatives au nombre d'occurrences"},{"location":"reference/hapify-syntax/#conditions-sur-les-modeles-de-donnees","text":"","title":"Conditions sur les mod\u00e8les de donn\u00e9es"},{"location":"reference/hapify-syntax/#tester-un-seul-modele-de-donnees","text":"Dans un template de type one model : Hapify (long) <<if Model isGeolocated >> // This block is reached if the model is geolocated. // that's means it has at least one latitude field and one longitude field <<endif>> Hapify (short) <<? M pGeo >> // This block is reached if the model is geolocated. // that's means it has at least one latitude field and one longitude field <<?>> \u00c9quivalent JavaScript if ( root . properties . isGeolocated ) { out += ' // ...' ; }","title":"Tester un seul mod\u00e8le de donn\u00e9es"},{"location":"reference/hapify-syntax/#tester-une-liste-de-modeles-de-donnees","text":"Dans un template de type all models : Hapify (long) <<if Models not onlyGuest >> // This block is reached if at least one model has not only guest actions import 'session-service'; <<endif>> Hapify (short) <<? M !pOGs >> // This block is reached if at least one model has not only guest actions import 'session-service'; <<?>> \u00c9quivalent JavaScript if ( root . filter ( m => ! m . accesses . properties . onlyGuest ). length > 0 ) { out += \" import 'session-service';\" ; }","title":"Tester une liste de mod\u00e8les de donn\u00e9es"},{"location":"reference/hapify-syntax/#objets-et-filtres-disponibles","text":"","title":"Objets et filtres disponibles"},{"location":"reference/hapify-syntax/#objet-racine","text":"Model ou Models (abr\u00e9g\u00e9 : M ) font r\u00e9f\u00e9rence \u00e0 l'objet principal : le mod\u00e8le de donn\u00e9es dans un template de type one model le tableau de mod\u00e8les de donn\u00e9es dans un template de type all models","title":"Objet racine"},{"location":"reference/hapify-syntax/#objets-filtrables-et-testables","text":"Dans le cas d'un template de type one model : Fields (alias: F ) est la liste des champs Dependencies (alias: D ) est la liste des d\u00e9pendances (liste de mod\u00e8les de donn\u00e9es) ReferencedIn (alias: RefModels , R ) est la liste des mod\u00e8les de donn\u00e9es qui d\u00e9pendent de celui-ci PrimaryField (alias: P ) est le champ primaire du mod\u00e8le Accesses (alias: A ) est la liste des acc\u00e8s CreateAccess (alias: Ac ) est l'acc\u00e8s \u00e0 l'action de cr\u00e9ation ReadAccess (alias: Ar ) est l'acc\u00e8s \u00e0 l'action de lecture UpdateAccess (alias: Au ) est l'acc\u00e8s \u00e0 l'action de mise \u00e0 jour RemoveAccess (alias: Ad ) est l'acc\u00e8s \u00e0 l'action de suppression SearchAccess (alias: As ) est l'acc\u00e8s \u00e0 l'action de recherche CountAccess (alias: An ) est l'acc\u00e8s \u00e0 l'action de comptage","title":"Objets filtrables et testables"},{"location":"reference/hapify-syntax/#filtrage-sur-les-attributs-de-champ","text":"Attributs disponibles pour un champ : primary (alias: pr ) pour le bool\u00e9en primary unique (alias: un ) pour le bool\u00e9en unique label (alias: lb ) pour le bool\u00e9en label nullable (alias: nu ) pour le bool\u00e9en nullable multiple (alias: ml ) pour le bool\u00e9en multiple embedded (alias: em ) pour le bool\u00e9en embedded searchable (alias: se ) pour le bool\u00e9en searchable sortable (alias: so ) pour le bool\u00e9en sortable hidden (alias: hd ) pour le bool\u00e9en hidden internal (alias: in ) pour le bool\u00e9en internal restricted (alias: rs ) pour le bool\u00e9en restricted ownership (alias: os ) pour le bool\u00e9en ownership string (alias: tS ) pour le type string email (alias: tSe ) pour le type string et le sous-type email password (alias: tSp ) pour le type string et le sous-type password url (alias: tSu ) pour le type string et le sous-type url text (alias: tSt ) pour le type string et le sous-type text richText (alias: rich , tSr ) pour le type string et le sous-type rich number (alias: tN ) pour le type number integer (alias: tNi ) pour le type number et le sous-type integer float (alias: tNf ) pour le type number et le sous-type float latitude (alias: tNt ) pour le type number et le sous-type latitude longitude (alias: tNg ) pour le type number et le sous-type longitude boolean (alias: tB ) pour le type boolean datetime (alias: tD ) pour le type datetime date (alias: tDd ) pour le type datetime et le sous-type date time (alias: tDt ) pour le type datetime et le sous-type time enum (alias: tU ) pour le type enum entity (alias: tE ) pour le type entity oneOne (alias: tEoo ) pour le type entity et le sous-type oneOne oneMany (alias: tEom ) pour le type entity et le sous-type oneMany manyOne (alias: tEmo ) pour le type entity et le sous-type manyOne manyMany (alias: tEmm ) pour le type entity et le sous-type manyMany object (alias: tO ) pour le type object file (alias: tF ) pour le type file image (alias: tFi ) pour le type file et le sous-type image video (alias: tFv ) pour le type file et le sous-type video audio (alias: tFa ) pour le type file et le sous-type audio document (alias: tFd ) pour le type file et le sous-type document Exemple Hapify (long) <<if Fields ( restricted or internal ) and not number >> // Current model has at least one field matching to the condition <<endif>> Hapify (short) <<? F ( rs + in ) / tN >> // Current model has at least one field matching to the condition <<?>> \u00c9quivalent JavaScript if ( root . fields . filter ( f => ( f . restricted || f . internal ) && ! f . number ). length > 0 ) { out += \" // ...\" ; }","title":"Filtrage sur les attributs de champ"},{"location":"reference/hapify-syntax/#filtrage-sur-les-proprietes-du-modele-de-donnees","text":"Propri\u00e9t\u00e9s disponibles pour un mod\u00e8le de donn\u00e9es : mainlyHidden (alias: pMHd ) la majorit\u00e9 des champs sont hidden (strictement) mainlyInternal (alias: pMIn ) la majorit\u00e9 des champs sont internal (strictement) isGeolocated (alias: pGeo ) Le mod\u00e8le de donn\u00e9es contient au moins un champ latitude et un champ longitude . isGeoSearchable (alias: pGSe ) Le mod\u00e8le de donn\u00e9es contient au moins un champ latitude et un champ longitude recherchables. Exemple Hapify (long) <<if Model isGeolocated >> // This model contains at least one latitude field and one longitude field. <<endif>> Hapify (short) <<? M pGeo >> // This model contains at least one latitude field and one longitude field. <<?>> \u00c9quivalent JavaScript if ( root . properties . isGeolocated ) { out += \" // ...\" ; } Propri\u00e9t\u00e9s d'acc\u00e8s disponibles pour un mod\u00e8le de donn\u00e9es : onlyAdmin (alias: pOAd ) Le mod\u00e8le de donn\u00e9es ne contient que des acc\u00e8s restreints \u00e0 admin onlyOwner (alias: pOOw ) Le mod\u00e8le de donn\u00e9es ne contient que des acc\u00e8s restreints \u00e0 owner onlyAuth (alias: pOAu ) Le mod\u00e8le de donn\u00e9es ne contient que des acc\u00e8s restreints \u00e0 authenticated onlyGuest (alias: pOGs ) Le mod\u00e8le de donn\u00e9es ne contient que des acc\u00e8s restreints \u00e0 guest maxAdmin (alias: pMAd ) L'acc\u00e8s le plus permissif est admin maxOwner (alias: pMOw ) L'acc\u00e8s le plus permissif est owner maxAuth (alias: pMAu ) L'acc\u00e8s le plus permissif est authenticated maxGuest (alias: pMGs ) L'acc\u00e8s le plus permissif est guest noAdmin (alias: pNAd ) Aucune action n'est restreinte \u00e0 admin noOwner (alias: pNOw ) Aucune action n'est restreinte \u00e0 owner noAuth (alias: pNAu ) Aucune action n'est restreinte \u00e0 authenticated noGuest (alias: pNGs ) Aucune action n'est restreinte \u00e0 guest Exemple Hapify (long) <<if Model onlyAdmin >> // All actions on this model are restricted to admins <<endif>> Hapify (short) <<? M pOAd >> // All actions on this model are restricted to admins <<?>> \u00c9quivalent JavaScript if ( root . accesses . properties . onlyAdmin ) { out += \" // ...\" ; }","title":"Filtrage sur les propri\u00e9t\u00e9s du mod\u00e8le de donn\u00e9es"},{"location":"reference/hapify-syntax/#filtrage-sur-les-acces-aux-modeles-de-donnees","text":"Rappel guest est l'acc\u00e8s le plus permissif et admin le moins permissif. Par cons\u00e9quent admin < owner < authenticated < guest . Filtres disponibles pour l'acc\u00e8s \u00e0 une action : admin (alias: ad ) l'acc\u00e8s est admin owner (alias: ow ) l'acc\u00e8s est owner auth (alias: au ) l'acc\u00e8s est auth guest (alias: gs ) l'acc\u00e8s est guest gteAdmin (alias: [ad ) l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 admin gteOwner (alias: [ow ) l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 owner gteAuth (alias: [au ) l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 auth gteGuest (alias: [gs ) l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 guest lteAdmin (alias: ad] ) l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 admin lteOwner (alias: ow] ) l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 owner lteAuth (alias: au] ) l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 auth lteGuest (alias: gs] ) l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 guest Exemples Teste l'acc\u00e8s pour une action pr\u00e9cise : Hapify (long) <<if ReadAccess guest >> // Anyone can read this model <<endif>> Hapify (short) <<? Ar gs >> // Anyone can read this model <<?>> \u00c9quivalent JavaScript if ( root . accesses . read . guest ) { out += ' // ...' ; } Teste si l'action de mise \u00e0 jour est restreinte soit aux administrateurs soit au propri\u00e9taire : Hapify (long) <<if UpdateAccess admin or owner >> // ... <<endif>> Hapify (short) <<? Au ad + ow >> // ... <<?>> \u00c9quivalent JavaScript if ( root . accesses . update . admin || root . accesses . update . owner ) { out += ' // ...' ; } Teste si au moins une action est restreinte \u00e0 un utilisateur authentifi\u00e9 ou moins : Hapify (long) <<if Accesses lteAuth >> // ... <<endif>> Hapify (short) <<? A au] >> // ... <<?>> \u00c9quivalent JavaScript if ( root . accesses . filter ( a => a . lteAuth ). length > 0 ) { out += ' // ...' ; } \u00c0 savoir Les conditions peuvent \u00eatre utilis\u00e9es sur un objet ou un tableau d'objets. S'il est utilis\u00e9 sur un tableau, il testera la longueur du tableau filtr\u00e9 par la condition fournie. Il peut \u00eatre utilis\u00e9 sur n'importe quel objet contenant une m\u00e9thode filter qui re\u00e7oit un callback retournant un bool\u00e9en. Par exemple, dans la structure du mod\u00e8le de donn\u00e9es, root.dependencies est un objet qui contient une m\u00e9thode filter . Ainsi, cet op\u00e9rateur peut tester si un mod\u00e8le a des d\u00e9pendances qui ont des champs avec une condition sp\u00e9cifique.","title":"Filtrage sur les acc\u00e8s aux mod\u00e8les de donn\u00e9es"},{"location":"reference/hapify-syntax/#iterations","text":"Les it\u00e9rations utilisent les m\u00eames filtres et op\u00e9rateurs que les conditions.","title":"It\u00e9rations"},{"location":"reference/hapify-syntax/#iteration-simple","text":"Boucle sur tous les champs d'un mod\u00e8le de donn\u00e9es qui ne sont pas cach\u00e9s et les assigne \u00e0 la variable field : Hapify (long) <?php $fields = array( <<for Fields not hidden field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ F !hd f >> ' <<f aA>> ', <<@>> ); \u00c9quivalent JavaScript out += `<?php $fields = array( ${ root . fields . filter ( f => ! f . hidden ) . map ( f => \"'\" + f . names . camel + \"'\" ) . join ( \",\\n\\t\" ) } );` ; Exemple pour un mod\u00e8le de donn\u00e9es avec les champs name , created at et role , dont role est cach\u00e9 : <?php $fields = array ( 'name' , 'createdAt' , ); Boucle sur les champs de type entity et recherchables du mod\u00e8le de donn\u00e9es : Hapify (long) <<for Fields searchable and entity field >> // ... <<endfor>> Hapify (short) <<@ F se * tE f >> // ... <<@>> \u00c9quivalent JavaScript for ( let field of root . fields . filter ( f => f . searchable && f . type === 'entity' )) { out += ' // ...' ; }","title":"It\u00e9ration simple"},{"location":"reference/hapify-syntax/#boucler-sans-filtrer","text":"Cette op\u00e9ration permet de passer en revue tous les champs : Hapify (long) <<for Fields field >> // ... <<endfor>> Hapify (short) <<@ F f >> // ... <<@>> \u00c9quivalent JavaScript for ( let field of root . fields . list ) { out += ' // ...' ; }","title":"Boucler sans filtrer"},{"location":"reference/hapify-syntax/#boucler-sur-les-modeles-de-donnees","text":"Dans un template de type all models , ceci boucle sur tous les mod\u00e8les de donn\u00e9es qui sont g\u00e9o-localis\u00e9s : Hapify (long) <<for Models isGeolocated model >> // ... <<endfor>> Hapify (short) <<@ M pGeo m >> // ... <<@>> \u00c9quivalent JavaScript for ( let model of root . filter ( i => i . properties . isGeolocated )) { out += ' // ...' ; }","title":"Boucler sur les mod\u00e8les de donn\u00e9es"},{"location":"reference/hapify-syntax/#boucler-sur-les-dependances","text":"Dans un template de type one model , ceci boucle sur les d\u00e9pendances dont le champ r\u00e9f\u00e9rent est recherchable : Hapify (long) <<for Dependencies searchable dep >> // ... <<endfor>> Hapify (short) <<@ D se d >> // ... <<@>> \u00c9quivalent JavaScript for ( let dep of root . dependencies . filter ( f => f . searchable )) { out += ' // ...' ; } \u00c0 savoir Dans le cas d'un mod\u00e8le de donn\u00e9es qui se r\u00e9f\u00e8re \u00e0 lui-m\u00eame, Dependencies exclue cette auto-d\u00e9pendance. Pour l'inclure utilisez le code suivant: <<< for (let dep of root.dependencies.filter(f => f, false)) { >>> // ... <<< } >>> Attention Le filtrage de Dependencies ne s'effectue que sur les champs du mod\u00e8le de donn\u00e9es courant qui portent la r\u00e9f\u00e9rence. Le filtrage ne s'effectue pas sur les champs du mod\u00e8le de donn\u00e9es cible.","title":"Boucler sur les d\u00e9pendances"},{"location":"reference/hapify-syntax/#boucler-sur-les-modeles-de-donnees-referents","text":"Dans un template de type one model , ceci boucle sur les mod\u00e8les de donn\u00e9es ayant une d\u00e9pendance envers celui-ci et qui sont g\u00e9o-localis\u00e9s : Hapify (long) <<for ReferencedIn isGeolocated referrer >> // ... <<endfor>> Hapify (short) <<@ R pGeo r >> // ... <<@>> \u00c9quivalent JavaScript for ( let referrer of root . referencedIn . filter ( m => m . properties . isGeolocated )) { out += ' // ...' ; } \u00c0 savoir Le filtre est optionnel. Vous pouvez obtenir tous les mod\u00e8les de donn\u00e9es r\u00e9f\u00e9rents comme ceci : <<for ReferencedIn referrer >> // ... <<endfor>> Attention Seuls les champs de type entit\u00e9 faisant r\u00e9f\u00e9rence sont d\u00e9finis dans ces mod\u00e8les de donn\u00e9es r\u00e9f\u00e9rents.","title":"Boucler sur les mod\u00e8les de donn\u00e9es r\u00e9f\u00e9rents"},{"location":"reference/hapify-syntax/#boucler-sur-les-acces-du-modele-de-donnees","text":"Boucle sur tous les acc\u00e8s restreints \u00e0 un administrateur ou au propri\u00e9taire et affiche le nom de l'action : Hapify (long) <<for Accesses admin or owner access >> <<=access.action>> <<endfor>> Hapify (short) <<@ A ad + ow a >> <<=a.action>> <<@>> \u00c9quivalent JavaScript for ( let access of root . accesses . filter ( a => a . admin || a . owner )) { out += ` ${ access . action } \\ n` ; }","title":"Boucler sur les acc\u00e8s du mod\u00e8le de donn\u00e9es"},{"location":"reference/hapify-syntax/#iteration-raccourcie","text":"Boucle sur les 2 premiers champs d'un mod\u00e8le de donn\u00e9es : Hapify (long) <?php $fields = array( <<for 2 Fields field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ 2 F f >> ' <<f aA>> ', <<@>> ); \u00c9quivalent JavaScript out += `<?php $fields = array( ${ root . fields . list . slice ( 0 , 2 ) . map ( f => \"'\" + f . names . camel + \"'\" ) . join ( \",\\n\\t\" ) } );` ; Pour un mod\u00e8le de donn\u00e9es avec les champs name , email et role : <?php $fields = array ( 'name' , 'email' , );","title":"It\u00e9ration raccourcie"},{"location":"reference/hapify-syntax/#iterations-imbriquees","text":"","title":"It\u00e9rations imbriqu\u00e9es"},{"location":"reference/hapify-syntax/#boucle-sur-les-enum","text":"Dans un template de type one model , ce bloc d\u00e9finit un type TypeScript contenant les \u00e9num\u00e9rations d'un champ : Hapify (long) <<for Fields enum field >> type <<field pascal>> = <<for field . enum e >> | '<<e snake >> '<<endfor >> ; <<endfor>> Hapify (short) <<@ F tU f >> type <<f AA>> = <<@ f . e e >> | '<<e a_a >> '<<@ >> ; <<@>> \u00c9quivalent JavaScript for ( let field of root . fields . filter ( f => f . type === 'enum' )) { out += `type ${ field . names . pascal } = ${ field . enum . map ( e => \"'\" + e . names . snake + \"'\" ). join ( ' | ' ) } ;` ; } Sortie type Role = | 'admin' | 'user' | 'customer' ;","title":"Boucle sur les enum"},{"location":"reference/hapify-syntax/#boucler-sur-les-champs-de-tous-les-modeles-de-donnees","text":"Dans un template de type all models , ce bloc permet de passer en revue tous les champs de tous les mod\u00e8les de donn\u00e9es : Hapify (long) const models = { <<for Models model >> <<m camel>> : [ <<for model . fields field >> ' <<field camel>> ', <<endfor>> ], <<endfor>> } Hapify (short) const models = { <<@ M m >> <<m aA>> : [ <<@ m . f f >> ' <<f aA>> ', <<@>> ], <<@>> } Sortie const models = { user : [ 'id' , 'createdAt' , 'email' , 'name' , ], place : [ 'id' , 'name' , 'category' , ], placeCategory : [ 'id' , 'createdAt' , 'email' , 'name' , ], }","title":"Boucler sur les champs de tous les mod\u00e8les de donn\u00e9es"},{"location":"reference/hapify-syntax/#entrees-brutes-et-interpolation","text":"Cet op\u00e9rateur vous permet d'\u00e9crire du JavaScript pur.","title":"Entr\u00e9es brutes et interpolation"},{"location":"reference/hapify-syntax/#variable-personnalisee","text":"D\u00e9finit une variable personnalis\u00e9e et l'ajoute \u00e0 la sortie : <<< const length = root.fields.length; >>> // This model has <<=length>> fields","title":"Variable personnalis\u00e9e"},{"location":"reference/hapify-syntax/#fonction-personnalisee","text":"D\u00e9finit une fonction personnalis\u00e9e et l'appelle : Hapify (long) <<< function fieldName(field) { return field.names.snake.replace('_', ':'); } >>> <<for Fields field >> <<=fieldName(field)>> <<endfor>> Hapify (short) <<< function fieldName(f) { return f.names.snake.replace('_', ':'); } >>> <<@ F f >> <<=fieldName(f)>> <<@>> Sortie id created:at place:category","title":"Fonction personnalis\u00e9e"},{"location":"reference/hapify-syntax/#condition-ou-iteration-personnalisee","text":"Ce bloc permet d'\u00e9crire une condition non g\u00e9r\u00e9e par la syntaxe Hapify : <<< if (root.fields.hidden.length < 3 || root.properties.mainlyInternal) { >>> // ... <<< } >>> \u00c0 savoir Dans un template Hapify de type one model , la variable root pointe vers le mod\u00e8le de donn\u00e9es. Dans un template Hapify de type all models , la variable root pointe vers le tableau de mod\u00e8les de donn\u00e9es. Voir aussi Pour connaitre en d\u00e9tail la structure du mod\u00e8le de donn\u00e9es, reportez-vous \u00e0 l'objet mod\u00e8le .","title":"Condition ou it\u00e9ration personnalis\u00e9e"},{"location":"reference/hapify-syntax/#erreur","text":"N'\u00e9crivez pas ceci : <<= JSON.stringify(root) >> . L'objet root a des propri\u00e9t\u00e9s r\u00e9cursives. Par cons\u00e9quent, cette commande conduira \u00e0 une boucle infinie.","title":"Erreur"},{"location":"reference/hapify-syntax/#commentaires","text":"Cette syntaxe \u00e9crit un commentaire dans le template sans aucune sortie dans le fichier g\u00e9n\u00e9r\u00e9. <<# This is just a comment>>","title":"Commentaires"},{"location":"reference/hapify-syntax/#echappement_1","text":"Il est possible d'\u00e9chapper les balises de la syntaxe Hapify avec le caract\u00e8re \\ : Hapify $val = 4; $res = $val \\<\\< 3; $res = 4 \\>\\> $val; Sortie $val = 4; $res = $val << 3; $res = 4 >> $val;","title":"\u00c9chappement"},{"location":"reference/hapify-syntax/#formatage","text":"Les lignes vides ou ne contenant que du m\u00e9ta-code de type condition ou it\u00e9ration sont automatiquement supprim\u00e9es suite \u00e0 la g\u00e9n\u00e9ration. Pour forcer le g\u00e9n\u00e9rateur \u00e0 garder une ligne vide, ins\u00e9rez un ou plusieurs espaces au d\u00e9but de celle-ci. Attention Hapify ne formate pas le code g\u00e9n\u00e9r\u00e9, car les r\u00e8gles de mise en forme sont sp\u00e9cifiques \u00e0 chaque langage voire chaque framework. Nous vous recommandons vivement d'utiliser un formateur de code suite \u00e0 la g\u00e9n\u00e9ration.","title":"Formatage"},{"location":"reference/hapify-syntax/#mots-reserves","text":"La liste suivante de mots ne peut pas \u00eatre utilis\u00e9e pour nommer des variables. A , Ac , Accesses , Ad , An , Ar , As , Au , CountAccess , CreateAccess , D , Dependencies , F , Fields , M , Model , Models , P , PrimaryField , R , ReadAccess , RefModels , ReferencedIn , RemoveAccess , SearchAccess , UpdateAccess , ad , admin , and , andNot , au , audio , auth , boolean , date , datetime , document , else , elseif , em , email , embedded , endfor , endif , entity , enum , file , float , for , gs , gteAdmin , gteAuth , gteGuest , gteOwner , guest , hd , hidden , if , image , in , integer , internal , isGeoSearchable , isGeolocated , label , latitude , lb , longitude , lteAdmin , lteAuth , lteGuest , lteOwner , mainlyHidden , mainlyInternal , manyMany , manyOne , maxAdmin , maxAuth , maxGuest , maxOwner , ml , multiple , noAdmin , noAuth , noGuest , noOwner , not , nu , nullable , number , object , oneMany , oneOne , onlyAdmin , onlyAuth , onlyGuest , onlyOwner , or , orNot , os , out , ow , owner , ownership , pGSe , pGeo , pMAd , pMAu , pMGs , pMHd , pMIn , pMOw , pNAd , pNAu , pNGs , pNOw , pOAd , pOAu , pOGs , pOOw , password , pr , primary , restricted , rich , richText , root , rs , se , searchable , so , sortable , string , tB , tD , tDd , tDt , tE , tEmm , tEom , tEoo , tF , tFa , tFd , tFi , tFv , tN , tNf , tNg , tNi , tNt , tO , tS , tSe , tSp , tSr , tSt , tSu , tU , text , time , un , unique , url , video .","title":"Mots r\u00e9serv\u00e9s"},{"location":"reference/model-object/","text":"Ce document d\u00e9crit la structure de l'objet qui repr\u00e9sente un mod\u00e8le de donn\u00e9es lors de l'\u00e9criture d'un template. Avant de lire ce document, vous devriez jeter un coup d'\u0153il \u00e0 la section concepts . Dans les templates Injection du mod\u00e8le de donn\u00e9es L'entr\u00e9e du template peut \u00eatre d\u00e9finie comme one model ou all models . Au cours de la g\u00e9n\u00e9ration, s'il est d\u00e9fini comme one model , le template sera appel\u00e9 une fois pour chaque mod\u00e8le de donn\u00e9es. Par cons\u00e9quent, il engendrera un fichier pour chaque mod\u00e8le de donn\u00e9es. S'il est d\u00e9fini comme all models , le template sera appel\u00e9 une seule fois pour tous les mod\u00e8les de donn\u00e9es. Il engendrera alors un unique fichier. Mod\u00e8le unique Si le template ne n\u00e9cessite qu'un seul mod\u00e8le, alors un objet model (alias m ) sera disponible comme variable globale dans le template. Dans un template Hapify, il sera disponible sous Model , M ou encore root . Dans un template EJS ou JavaScript, il sera disponible sous model ou m . Plusieurs mod\u00e8les Si le template n\u00e9cessite tous les mod\u00e8les, un tableau models (alias m ) sera disponible comme variable globale dans le template. Ce tableau contient tous les mod\u00e8les disponibles. Dans un template Hapify, il sera disponible sous Models , M ou encore root . Dans un template EJS ou JavaScript, il sera disponible sous models ou m . Structure de l'objet mod\u00e8le Les objets suivants seront disponibles dans le template. Objet mod\u00e8le id (string): un ID unique name (string): le nom du mod\u00e8le, tel que l'utilisateur l'a saisi. names (object): variantes calcul\u00e9es \u00e0 partir de la propri\u00e9t\u00e9 name . raw (string): tel que l'utilisateur l'a saisi. Exemple Online item . kebab (string): exemple online-item . big (string): exemple ONLINE-ITEM . header (string): exemple Online-Item . snake (string): exemple online_item . constant (string): exemple ONLINE_ITEM . compact (string): exemple onlineitem . camel (string): exemple onlineItem . pascal (string): exemple OnlineItem . lower (string): exemple online item . capital (string): exemple Online Item . fields - alias f (object): un objet contenant tous les champs, regroup\u00e9s dans diff\u00e9rents tableaux. Voir la section Objet de champ pour en savoir plus sur la structure d'un champ. list - alias l (array): contenant tous les champs du mod\u00e8le. primary - alias pr (Field): champ primaire du mod\u00e8le. null si aucun champ primaire n'est d\u00e9fini. unique - alias un (array): les champs marqu\u00e9s comme unique . label - alias lb (array): les champs marqu\u00e9s comme label . nullable - alias nu (array): les champs marqu\u00e9s comme nullable . multiple - alias ml (array): les champs marqu\u00e9s comme multiple . embedded - alias em (array): les champs marqu\u00e9s comme embedded . searchable - alias se (array): les champs marqu\u00e9s comme searchable . sortable - alias so (array): les champs marqu\u00e9s comme sortable . hidden - alias hd (array): les champs marqu\u00e9s comme hidden . internal - alias in (array): les champs marqu\u00e9s comme internal . restricted - alias rs (array): les champs marqu\u00e9s comme restricted . ownership - alias os (array): les champs marqu\u00e9s comme ownership . searchableLabel - alias sl (array): les champs marqu\u00e9s comme label et searchable . Utile pour une recherche rapide par label. filter - alias f (function): filtrer les champs avec une r\u00e8gle personnalis\u00e9e. \u00c9quivalent de model.fields.list.filter . references - alias r - mod\u00e8le non profond uniquement (array): champs de type entity . filter - alias f (function): filtre le tableau. dependencies - alias d - mod\u00e8le non profond uniquement (object): les d\u00e9pendances de ce mod\u00e8le (vers d'autres mod\u00e8les). Un mod\u00e8le a une d\u00e9pendance si l'un de ces champs est de type entity . list - alias l (array): mod\u00e8les de donn\u00e9es d\u00e9pendants, sauf auto-d\u00e9pendance. Ces mod\u00e8les sont ajout\u00e9s en tant que \"mod\u00e8les profonds\". self - alias s (boolean): ce mod\u00e8le de donn\u00e9es a une auto-d\u00e9pendance. filter - alias f (function): filtre les d\u00e9pendances. Premier argument (function - d\u00e9faut (f) => f ): fonction de filtrage recevant le champ du r\u00e9f\u00e9rent (le champ de type entity ). Second argument (boolean - d\u00e9faut true ): bool\u00e9en indiquant si il faut exclure l'auto-d\u00e9pendance. referencedIn - alias ri - mod\u00e8le non profond uniquement (array): mod\u00e8les qui font r\u00e9f\u00e9rence \u00e0 celui-ci. Ces mod\u00e8les sont ajout\u00e9s en tant que \"mod\u00e8les profonds\". Ces mod\u00e8les ne contiennent que des champs de type entity faisant r\u00e9f\u00e9rence au mod\u00e8le courant. filter - alias f (function): filtre le tableau. properties - alias p (object): les propri\u00e9t\u00e9s pr\u00e9-calcul\u00e9es \u00e0 partir des champs. fieldsCount (number): le nombre de champs contenus dans le mod\u00e8le. hasPrimary (boolean): a un champ primaire. hasUnique (boolean): a au moins un champ unique. hasLabel (boolean): a au moins un champ label. hasNullable (boolean): a au moins un champ nullable. hasMultiple (boolean): a au moins un champ multiple. hasEmbedded (boolean): a au moins un champ embarqu\u00e9. hasSearchable (boolean): a au moins un champ recherchable. hasSortable (boolean): a au moins un champ triable. hasHidden (boolean): a au moins un champ cach\u00e9. hasInternal (boolean): a au moins un champ interne. hasRestricted (boolean): a au moins un champ restreint. hasOwnership (boolean): a au moins un champ de propri\u00e9t\u00e9. hasSearchableLabel (boolean): le mod\u00e8le a au moins un champ marqu\u00e9 comme label et \u00e9galement recherchable. hasDependencies - mod\u00e8le non profond uniquement (boolean): le mod\u00e8le a des d\u00e9pendances avec d'autres mod\u00e8les ou avec lui-m\u00eame (par le biais d'un champ entity ). isReferenced - mod\u00e8le non profond uniquement (boolean): est r\u00e9f\u00e9renc\u00e9 par d'autres mod\u00e8les. mainlyHidden (boolean): la majorit\u00e9 des champs sont cach\u00e9s (strictement). mainlyInternal (boolean): la majorit\u00e9 des champs sont internes (strictement). isGeolocated (boolean): contient au moins un champ latitude et un champ longitude. isGeoSearchable (boolean): contient au moins un champ latitude recherchable et un champ longitude recherchable. accesses - alias a (object): les acc\u00e8s au mod\u00e8le regroup\u00e9s par action ou restriction. Voir la section Objet d'acc\u00e8s pour en savoir plus sur la structure des acc\u00e8s. list - alias l (array): tous les acc\u00e8s au mod\u00e8le. admin - alias ad (array): les acc\u00e8s limit\u00e9s \u00e0 admin . owner - alias ow (array): les acc\u00e8s limit\u00e9s \u00e0 owner . auth - alias au (array): les acc\u00e8s limit\u00e9s \u00e0 authenticated . guest - alias gs (array): les acc\u00e8s limit\u00e9s \u00e0 guest . create - alias c (object): l'acc\u00e8s \u00e0 l'action create . read - alias r (object): l'acc\u00e8s \u00e0 l'action read . update - alias u (object): l'acc\u00e8s \u00e0 l'action update . remove - alias d (object): l'acc\u00e8s \u00e0 l'action delete . search - alias s (object): l'acc\u00e8s \u00e0 l'action search . count - alias n (object): l'acc\u00e8s \u00e0 l'action count . filter - alias f (Function): filtrer les acc\u00e8s avec une r\u00e8gle personnalis\u00e9e. \u00c9quivalent de model.accesses.list.filter . properties - alias p (object): propri\u00e9t\u00e9s pr\u00e9-calcul\u00e9es \u00e0 partir des acc\u00e8s. onlyAdmin (boolean): ne contient que des acc\u00e8s limit\u00e9s \u00e0 admin . onlyOwner (boolean): ne contient que des acc\u00e8s limit\u00e9s \u00e0 owner . onlyAuth (boolean): ne contient que des acc\u00e8s limit\u00e9s \u00e0 authenticated . onlyGuest (boolean): ne contient que des acc\u00e8s limit\u00e9s \u00e0 guest . maxAdmin (boolean): l'acc\u00e8s le plus permissif est admin . maxOwner (boolean): l'acc\u00e8s le plus permissif est owner . maxAuth (boolean): l'acc\u00e8s le plus permissif est authenticated . maxGuest (boolean): l'acc\u00e8s le plus permissif est guest . noAdmin (boolean): il n'y a pas d'acc\u00e8s limit\u00e9 \u00e0 admin . noOwner (boolean): il n'y a pas d'acc\u00e8s limit\u00e9 \u00e0 owner . noAuth (boolean): il n'y a pas d'acc\u00e8s limit\u00e9 \u00e0 authenticated . noGuest (boolean): il n'y a pas d'acc\u00e8s limit\u00e9 \u00e0 guest . hasAdmin (boolean): il existe au moins un acc\u00e8s restreint \u00e0 admin . hasOwner (boolean): il existe au moins un acc\u00e8s restreint \u00e0 owner . hasAuth (boolean): il existe au moins un acc\u00e8s restreint \u00e0 authenticated . hasGuest (boolean): il existe au moins un acc\u00e8s restreint \u00e0 guest . Objet de champ name (string): le nom du champ, tel que l'utilisateur l'a saisi. names (object): variantes calcul\u00e9es \u00e0 partir de la propri\u00e9t\u00e9 name . raw (string): tel que l'utilisateur l'a saisi. Exemple first_name . kebab (string): exemple first-name . big (string): exemple FIRST-NAME . header (string): exemple First-Name . snake (string): exemple first_name . constant (string): exemple FIRST_NAME . compact (string): exemple firstname . camel (string): exemple firstName . pascal (string): exemple FirstName . lower (string): exemple first name . upper (string): exemple FIRST NAME . capital (string): exemple First Name . primary (boolean): est marqu\u00e9 comme primary . unique (boolean): est marqu\u00e9 comme unique . label (boolean): est marqu\u00e9 comme label . nullable (boolean): est marqu\u00e9 comme nullable . multiple (boolean): est marqu\u00e9 comme multiple . embedded (boolean): est marqu\u00e9 comme embedded . searchable (boolean): est marqu\u00e9 comme searchable . sortable (boolean): est marqu\u00e9 comme sortable . hidden (boolean): est marqu\u00e9 comme hidden . internal (boolean): est marqu\u00e9 comme internal . restricted (boolean): est marqu\u00e9 comme restricted . ownership (boolean): est marqu\u00e9 comme ownership . type (string): type du champ. Peut-\u00eatre string , number , boolean , datetime , entity , object ou file . subtype (string): sous-type du champ. Les valeurs disponibles d\u00e9pendent du type : string : Peut-\u00eatre null , email , password , url , text ou rich . number : Peut-\u00eatre null , integer , float , latitude ou longitude . boolean : Est null . datetime : Peut-\u00eatre null , date ou time . entity : Est null . object : Est null . file : Peut-\u00eatre null , image , video , audio ou document . model - alias m (object): objet mod\u00e8le cible si le champ est de type entity . null sinon. enum - alias e (array): un tableau contenant tous les enum si le champ est de type enum . null sinon. Voir la section Objet enum pour en savoir plus sur la structure d'un enum. value (string|string[]): Si le type est entity : ID brut du mod\u00e8le cible (string). Si le type est enum : liste brute d'enum (string[]). Sinon null . Objet enum name (string): nom de l'enum, tel que l'utilisateur l'a saisi. names (object): variantes calcul\u00e9es \u00e0 partir de la propri\u00e9t\u00e9 name . raw (string): tel que l'utilisateur l'a saisi. Exemple first_name . kebab (string): exemple first-name . big (string): exemple FIRST-NAME . header (string): exemple First-Name . snake (string): exemple first_name . constant (string): exemple FIRST_NAME . compact (string): exemple firstname . camel (string): exemple firstName . pascal (string): exemple FirstName . lower (string): exemple first name . upper (string): exemple FIRST NAME . capital (string): exemple First Name . Objet d'acc\u00e8s action (string): nom de l'action. Peut-\u00eatre create , read , update , remove , search ou count . admin (boolean): l'acc\u00e8s est admin . owner (boolean): l'acc\u00e8s est owner . auth (boolean): l'acc\u00e8s est authenticated . guest (boolean): l'acc\u00e8s est guest . gteAdmin (boolean): l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 admin (toujours true ). gteOwner (boolean): l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 owner . gteAuth (boolean): l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 authenticated . gteGuest (boolean): l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 guest . lteAdmin (boolean): l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 admin . lteOwner (boolean): l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 owner . lteAuth (boolean): l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 authenticated . lteGuest (boolean): l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 guest (toujours true ).","title":"Objet mod\u00e8le"},{"location":"reference/model-object/#dans-les-templates","text":"","title":"Dans les templates"},{"location":"reference/model-object/#injection-du-modele-de-donnees","text":"L'entr\u00e9e du template peut \u00eatre d\u00e9finie comme one model ou all models . Au cours de la g\u00e9n\u00e9ration, s'il est d\u00e9fini comme one model , le template sera appel\u00e9 une fois pour chaque mod\u00e8le de donn\u00e9es. Par cons\u00e9quent, il engendrera un fichier pour chaque mod\u00e8le de donn\u00e9es. S'il est d\u00e9fini comme all models , le template sera appel\u00e9 une seule fois pour tous les mod\u00e8les de donn\u00e9es. Il engendrera alors un unique fichier.","title":"Injection du mod\u00e8le de donn\u00e9es"},{"location":"reference/model-object/#modele-unique","text":"Si le template ne n\u00e9cessite qu'un seul mod\u00e8le, alors un objet model (alias m ) sera disponible comme variable globale dans le template. Dans un template Hapify, il sera disponible sous Model , M ou encore root . Dans un template EJS ou JavaScript, il sera disponible sous model ou m .","title":"Mod\u00e8le unique"},{"location":"reference/model-object/#plusieurs-modeles","text":"Si le template n\u00e9cessite tous les mod\u00e8les, un tableau models (alias m ) sera disponible comme variable globale dans le template. Ce tableau contient tous les mod\u00e8les disponibles. Dans un template Hapify, il sera disponible sous Models , M ou encore root . Dans un template EJS ou JavaScript, il sera disponible sous models ou m .","title":"Plusieurs mod\u00e8les"},{"location":"reference/model-object/#structure-de-lobjet-modele","text":"Les objets suivants seront disponibles dans le template.","title":"Structure de l'objet mod\u00e8le"},{"location":"reference/model-object/#objet-modele","text":"id (string): un ID unique name (string): le nom du mod\u00e8le, tel que l'utilisateur l'a saisi. names (object): variantes calcul\u00e9es \u00e0 partir de la propri\u00e9t\u00e9 name . raw (string): tel que l'utilisateur l'a saisi. Exemple Online item . kebab (string): exemple online-item . big (string): exemple ONLINE-ITEM . header (string): exemple Online-Item . snake (string): exemple online_item . constant (string): exemple ONLINE_ITEM . compact (string): exemple onlineitem . camel (string): exemple onlineItem . pascal (string): exemple OnlineItem . lower (string): exemple online item . capital (string): exemple Online Item . fields - alias f (object): un objet contenant tous les champs, regroup\u00e9s dans diff\u00e9rents tableaux. Voir la section Objet de champ pour en savoir plus sur la structure d'un champ. list - alias l (array): contenant tous les champs du mod\u00e8le. primary - alias pr (Field): champ primaire du mod\u00e8le. null si aucun champ primaire n'est d\u00e9fini. unique - alias un (array): les champs marqu\u00e9s comme unique . label - alias lb (array): les champs marqu\u00e9s comme label . nullable - alias nu (array): les champs marqu\u00e9s comme nullable . multiple - alias ml (array): les champs marqu\u00e9s comme multiple . embedded - alias em (array): les champs marqu\u00e9s comme embedded . searchable - alias se (array): les champs marqu\u00e9s comme searchable . sortable - alias so (array): les champs marqu\u00e9s comme sortable . hidden - alias hd (array): les champs marqu\u00e9s comme hidden . internal - alias in (array): les champs marqu\u00e9s comme internal . restricted - alias rs (array): les champs marqu\u00e9s comme restricted . ownership - alias os (array): les champs marqu\u00e9s comme ownership . searchableLabel - alias sl (array): les champs marqu\u00e9s comme label et searchable . Utile pour une recherche rapide par label. filter - alias f (function): filtrer les champs avec une r\u00e8gle personnalis\u00e9e. \u00c9quivalent de model.fields.list.filter . references - alias r - mod\u00e8le non profond uniquement (array): champs de type entity . filter - alias f (function): filtre le tableau. dependencies - alias d - mod\u00e8le non profond uniquement (object): les d\u00e9pendances de ce mod\u00e8le (vers d'autres mod\u00e8les). Un mod\u00e8le a une d\u00e9pendance si l'un de ces champs est de type entity . list - alias l (array): mod\u00e8les de donn\u00e9es d\u00e9pendants, sauf auto-d\u00e9pendance. Ces mod\u00e8les sont ajout\u00e9s en tant que \"mod\u00e8les profonds\". self - alias s (boolean): ce mod\u00e8le de donn\u00e9es a une auto-d\u00e9pendance. filter - alias f (function): filtre les d\u00e9pendances. Premier argument (function - d\u00e9faut (f) => f ): fonction de filtrage recevant le champ du r\u00e9f\u00e9rent (le champ de type entity ). Second argument (boolean - d\u00e9faut true ): bool\u00e9en indiquant si il faut exclure l'auto-d\u00e9pendance. referencedIn - alias ri - mod\u00e8le non profond uniquement (array): mod\u00e8les qui font r\u00e9f\u00e9rence \u00e0 celui-ci. Ces mod\u00e8les sont ajout\u00e9s en tant que \"mod\u00e8les profonds\". Ces mod\u00e8les ne contiennent que des champs de type entity faisant r\u00e9f\u00e9rence au mod\u00e8le courant. filter - alias f (function): filtre le tableau. properties - alias p (object): les propri\u00e9t\u00e9s pr\u00e9-calcul\u00e9es \u00e0 partir des champs. fieldsCount (number): le nombre de champs contenus dans le mod\u00e8le. hasPrimary (boolean): a un champ primaire. hasUnique (boolean): a au moins un champ unique. hasLabel (boolean): a au moins un champ label. hasNullable (boolean): a au moins un champ nullable. hasMultiple (boolean): a au moins un champ multiple. hasEmbedded (boolean): a au moins un champ embarqu\u00e9. hasSearchable (boolean): a au moins un champ recherchable. hasSortable (boolean): a au moins un champ triable. hasHidden (boolean): a au moins un champ cach\u00e9. hasInternal (boolean): a au moins un champ interne. hasRestricted (boolean): a au moins un champ restreint. hasOwnership (boolean): a au moins un champ de propri\u00e9t\u00e9. hasSearchableLabel (boolean): le mod\u00e8le a au moins un champ marqu\u00e9 comme label et \u00e9galement recherchable. hasDependencies - mod\u00e8le non profond uniquement (boolean): le mod\u00e8le a des d\u00e9pendances avec d'autres mod\u00e8les ou avec lui-m\u00eame (par le biais d'un champ entity ). isReferenced - mod\u00e8le non profond uniquement (boolean): est r\u00e9f\u00e9renc\u00e9 par d'autres mod\u00e8les. mainlyHidden (boolean): la majorit\u00e9 des champs sont cach\u00e9s (strictement). mainlyInternal (boolean): la majorit\u00e9 des champs sont internes (strictement). isGeolocated (boolean): contient au moins un champ latitude et un champ longitude. isGeoSearchable (boolean): contient au moins un champ latitude recherchable et un champ longitude recherchable. accesses - alias a (object): les acc\u00e8s au mod\u00e8le regroup\u00e9s par action ou restriction. Voir la section Objet d'acc\u00e8s pour en savoir plus sur la structure des acc\u00e8s. list - alias l (array): tous les acc\u00e8s au mod\u00e8le. admin - alias ad (array): les acc\u00e8s limit\u00e9s \u00e0 admin . owner - alias ow (array): les acc\u00e8s limit\u00e9s \u00e0 owner . auth - alias au (array): les acc\u00e8s limit\u00e9s \u00e0 authenticated . guest - alias gs (array): les acc\u00e8s limit\u00e9s \u00e0 guest . create - alias c (object): l'acc\u00e8s \u00e0 l'action create . read - alias r (object): l'acc\u00e8s \u00e0 l'action read . update - alias u (object): l'acc\u00e8s \u00e0 l'action update . remove - alias d (object): l'acc\u00e8s \u00e0 l'action delete . search - alias s (object): l'acc\u00e8s \u00e0 l'action search . count - alias n (object): l'acc\u00e8s \u00e0 l'action count . filter - alias f (Function): filtrer les acc\u00e8s avec une r\u00e8gle personnalis\u00e9e. \u00c9quivalent de model.accesses.list.filter . properties - alias p (object): propri\u00e9t\u00e9s pr\u00e9-calcul\u00e9es \u00e0 partir des acc\u00e8s. onlyAdmin (boolean): ne contient que des acc\u00e8s limit\u00e9s \u00e0 admin . onlyOwner (boolean): ne contient que des acc\u00e8s limit\u00e9s \u00e0 owner . onlyAuth (boolean): ne contient que des acc\u00e8s limit\u00e9s \u00e0 authenticated . onlyGuest (boolean): ne contient que des acc\u00e8s limit\u00e9s \u00e0 guest . maxAdmin (boolean): l'acc\u00e8s le plus permissif est admin . maxOwner (boolean): l'acc\u00e8s le plus permissif est owner . maxAuth (boolean): l'acc\u00e8s le plus permissif est authenticated . maxGuest (boolean): l'acc\u00e8s le plus permissif est guest . noAdmin (boolean): il n'y a pas d'acc\u00e8s limit\u00e9 \u00e0 admin . noOwner (boolean): il n'y a pas d'acc\u00e8s limit\u00e9 \u00e0 owner . noAuth (boolean): il n'y a pas d'acc\u00e8s limit\u00e9 \u00e0 authenticated . noGuest (boolean): il n'y a pas d'acc\u00e8s limit\u00e9 \u00e0 guest . hasAdmin (boolean): il existe au moins un acc\u00e8s restreint \u00e0 admin . hasOwner (boolean): il existe au moins un acc\u00e8s restreint \u00e0 owner . hasAuth (boolean): il existe au moins un acc\u00e8s restreint \u00e0 authenticated . hasGuest (boolean): il existe au moins un acc\u00e8s restreint \u00e0 guest .","title":"Objet mod\u00e8le"},{"location":"reference/model-object/#objet-de-champ","text":"name (string): le nom du champ, tel que l'utilisateur l'a saisi. names (object): variantes calcul\u00e9es \u00e0 partir de la propri\u00e9t\u00e9 name . raw (string): tel que l'utilisateur l'a saisi. Exemple first_name . kebab (string): exemple first-name . big (string): exemple FIRST-NAME . header (string): exemple First-Name . snake (string): exemple first_name . constant (string): exemple FIRST_NAME . compact (string): exemple firstname . camel (string): exemple firstName . pascal (string): exemple FirstName . lower (string): exemple first name . upper (string): exemple FIRST NAME . capital (string): exemple First Name . primary (boolean): est marqu\u00e9 comme primary . unique (boolean): est marqu\u00e9 comme unique . label (boolean): est marqu\u00e9 comme label . nullable (boolean): est marqu\u00e9 comme nullable . multiple (boolean): est marqu\u00e9 comme multiple . embedded (boolean): est marqu\u00e9 comme embedded . searchable (boolean): est marqu\u00e9 comme searchable . sortable (boolean): est marqu\u00e9 comme sortable . hidden (boolean): est marqu\u00e9 comme hidden . internal (boolean): est marqu\u00e9 comme internal . restricted (boolean): est marqu\u00e9 comme restricted . ownership (boolean): est marqu\u00e9 comme ownership . type (string): type du champ. Peut-\u00eatre string , number , boolean , datetime , entity , object ou file . subtype (string): sous-type du champ. Les valeurs disponibles d\u00e9pendent du type : string : Peut-\u00eatre null , email , password , url , text ou rich . number : Peut-\u00eatre null , integer , float , latitude ou longitude . boolean : Est null . datetime : Peut-\u00eatre null , date ou time . entity : Est null . object : Est null . file : Peut-\u00eatre null , image , video , audio ou document . model - alias m (object): objet mod\u00e8le cible si le champ est de type entity . null sinon. enum - alias e (array): un tableau contenant tous les enum si le champ est de type enum . null sinon. Voir la section Objet enum pour en savoir plus sur la structure d'un enum. value (string|string[]): Si le type est entity : ID brut du mod\u00e8le cible (string). Si le type est enum : liste brute d'enum (string[]). Sinon null .","title":"Objet de champ"},{"location":"reference/model-object/#objet-enum","text":"name (string): nom de l'enum, tel que l'utilisateur l'a saisi. names (object): variantes calcul\u00e9es \u00e0 partir de la propri\u00e9t\u00e9 name . raw (string): tel que l'utilisateur l'a saisi. Exemple first_name . kebab (string): exemple first-name . big (string): exemple FIRST-NAME . header (string): exemple First-Name . snake (string): exemple first_name . constant (string): exemple FIRST_NAME . compact (string): exemple firstname . camel (string): exemple firstName . pascal (string): exemple FirstName . lower (string): exemple first name . upper (string): exemple FIRST NAME . capital (string): exemple First Name .","title":"Objet enum"},{"location":"reference/model-object/#objet-dacces","text":"action (string): nom de l'action. Peut-\u00eatre create , read , update , remove , search ou count . admin (boolean): l'acc\u00e8s est admin . owner (boolean): l'acc\u00e8s est owner . auth (boolean): l'acc\u00e8s est authenticated . guest (boolean): l'acc\u00e8s est guest . gteAdmin (boolean): l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 admin (toujours true ). gteOwner (boolean): l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 owner . gteAuth (boolean): l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 authenticated . gteGuest (boolean): l'acc\u00e8s est sup\u00e9rieur ou \u00e9gal \u00e0 guest . lteAdmin (boolean): l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 admin . lteOwner (boolean): l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 owner . lteAuth (boolean): l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 authenticated . lteGuest (boolean): l'acc\u00e8s est inf\u00e9rieur ou \u00e9gal \u00e0 guest (toujours true ).","title":"Objet d'acc\u00e8s"}]}