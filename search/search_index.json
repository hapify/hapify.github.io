{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"code-samples/hapify/","text":"This document provides code examples to help you play with Hapify templates. Prerequisites Before reading this article, we recommend you to read the documentation about Hapify templates . Creating a TypeScript class Hapify (long) <<# Import dependencies >> <<for Dependencies not ( hidden and internal ) dep >> import { <<dep pascal>> } from './ <<dep pascal>> '; <<endfor>> <<# Declare interfaces for enum fields >> <<for Fields enum field >> export type <<Model pascal>><<field pascal>> Enum = <<for field . enum e >> | '<<e snake >> '<<endfor >> ; <<endfor>> <<if Model hasNotes >> /** <<! Model>> */ <<endif>> export class <<Model pascal>> { <<for Fields not primary field >> <<if field hasNotes >> /** <<! field>> */ <<endif>> <<if field entity >> private <<field camel>> : number <<if field multiple >> []<<endif >> ; <<elseif field enum >> public <<field camel>> : <<Model pascal>><<field pascal>> Enum; <<elseif field datetime >> public <<field camel>> : Date; <<else>> public <<field camel>> : <<=field.type>> ; <<endif>> <<endfor>> constructor(private <<PrimaryField camel>> : number) {} <<# Getter for primary field >> getId(): number { return this. <<PrimaryField camel>> } getLabel(): string { <<if Fields label >> return ` <<=labels()>> `; <<else>> return this.getId().toString(); <<endif>> } <<# Getter for each entity >> <<for Fields entity field >> get <<field pascal>> (): <<field.model pascal>> <<if field multiple >> []<<endif >> { <<if field multiple >> return this. <<field camel>> .map(id => new <<field.model pascal>> (id)); <<else>> return new <<field.model pascal>> (this. <<field camel>> ); <<endif>> } <<endfor>> } <<< function labels() { return root.fields.label .map(label => \"${this.\"+label.names.snake+\"}\") .join(' '); } >>> Output 1 import { PlaceCategory } from './PlaceCategory' ; import { Service } from './Service' ; import { User } from './User' ; /** Represent a restaurant */ export class Place { public name : string ; public description : string ; private categories : number []; public address1 : string ; public address2 : string ; /** Inferred from address fields */ public latitude : number ; /** Inferred from address fields */ public longitude : number ; public phone : string ; public websiteUrl : string ; private services : number []; public timetable : string ; private owner : number ; public disabled : boolean ; constructor ( private id : number ) {} getId () : number { return this . id } getLabel () : string { return ` ${ this . name } ` ; } getCategories () : PlaceCategory [] { return this . categories . map ( id => new PlaceCategory ( id )); } getServices () : Service [] { return this . services . map ( id => new Service ( id )); } getOwner () : User { return new User ( this . owner ); } } Output 2 export type UserRoleEnum = | 'admin' | 'user' ; /** Represent a customer */ export class User { public name : string ; public email : string ; /** Hashed using BCrpyt */ public password : string ; public role : UserRoleEnum ; /** Allow admins to disable this user */ public banned : boolean ; public lastConnectedAt : Date ; constructor ( private id : number ) {} getId () : number { return this . id } getLabel () : string { return ` ${ this . name } ` ; } }","title":"Hapify"},{"location":"code-samples/hapify/#prerequisites","text":"Before reading this article, we recommend you to read the documentation about Hapify templates .","title":"Prerequisites"},{"location":"code-samples/hapify/#creating-a-typescript-class","text":"Hapify (long) <<# Import dependencies >> <<for Dependencies not ( hidden and internal ) dep >> import { <<dep pascal>> } from './ <<dep pascal>> '; <<endfor>> <<# Declare interfaces for enum fields >> <<for Fields enum field >> export type <<Model pascal>><<field pascal>> Enum = <<for field . enum e >> | '<<e snake >> '<<endfor >> ; <<endfor>> <<if Model hasNotes >> /** <<! Model>> */ <<endif>> export class <<Model pascal>> { <<for Fields not primary field >> <<if field hasNotes >> /** <<! field>> */ <<endif>> <<if field entity >> private <<field camel>> : number <<if field multiple >> []<<endif >> ; <<elseif field enum >> public <<field camel>> : <<Model pascal>><<field pascal>> Enum; <<elseif field datetime >> public <<field camel>> : Date; <<else>> public <<field camel>> : <<=field.type>> ; <<endif>> <<endfor>> constructor(private <<PrimaryField camel>> : number) {} <<# Getter for primary field >> getId(): number { return this. <<PrimaryField camel>> } getLabel(): string { <<if Fields label >> return ` <<=labels()>> `; <<else>> return this.getId().toString(); <<endif>> } <<# Getter for each entity >> <<for Fields entity field >> get <<field pascal>> (): <<field.model pascal>> <<if field multiple >> []<<endif >> { <<if field multiple >> return this. <<field camel>> .map(id => new <<field.model pascal>> (id)); <<else>> return new <<field.model pascal>> (this. <<field camel>> ); <<endif>> } <<endfor>> } <<< function labels() { return root.fields.label .map(label => \"${this.\"+label.names.snake+\"}\") .join(' '); } >>> Output 1 import { PlaceCategory } from './PlaceCategory' ; import { Service } from './Service' ; import { User } from './User' ; /** Represent a restaurant */ export class Place { public name : string ; public description : string ; private categories : number []; public address1 : string ; public address2 : string ; /** Inferred from address fields */ public latitude : number ; /** Inferred from address fields */ public longitude : number ; public phone : string ; public websiteUrl : string ; private services : number []; public timetable : string ; private owner : number ; public disabled : boolean ; constructor ( private id : number ) {} getId () : number { return this . id } getLabel () : string { return ` ${ this . name } ` ; } getCategories () : PlaceCategory [] { return this . categories . map ( id => new PlaceCategory ( id )); } getServices () : Service [] { return this . services . map ( id => new Service ( id )); } getOwner () : User { return new User ( this . owner ); } } Output 2 export type UserRoleEnum = | 'admin' | 'user' ; /** Represent a customer */ export class User { public name : string ; public email : string ; /** Hashed using BCrpyt */ public password : string ; public role : UserRoleEnum ; /** Allow admins to disable this user */ public banned : boolean ; public lastConnectedAt : Date ; constructor ( private id : number ) {} getId () : number { return this . id } getLabel () : string { return ` ${ this . name } ` ; } }","title":"Creating a TypeScript class"},{"location":"code-samples/javascript/","text":"This document provides code examples to help you play with JavaScript templates. Prerequisites Before reading this article, we recommend that you read the documentation about JavaScript templates . Creating indexes for MongoDB This template will produce a JSON containing all the indexes that must be created in MongoDB based on the field attributes. It creates an index for searchable, sortable fields or references. It also creates a unique index for unique fields and a text index for searchable string fields. JavaScript /** Generate indexes for a model */ function _model ( out , model ) { const modelName = model . names . snake ; const strings = { fields : {} }; const uniques = { fields : {}, options : { unique : true } }; // Even if no fields have indexes, Include this collection // Get fields objects out [ modelName ] = model . fields . list . reduce (( p , field ) => { // Non primary fields if ( field . primary ) { return p ; } // Only if the field is searchable, sortable a reference or is unique if ( ! ( field . sortable || field . searchable || field . type === 'entity' || field . unique )) { return p ; } const fieldName = field . names . snake ; // Special text index for strings if ( field . type === 'string' && field . searchable ) { strings . fields [ fieldName ] = 'text' ; } // Normal indexes p [ ` ${ modelName } _ ${ fieldName } ` ] = { fields : { [ fieldName ] : 1 } }; if ( field . unique ) { p [ ` ${ modelName } _ ${ fieldName } ` ]. options = { unique : true }; uniques . fields [ fieldName ] = 1 ; } return p ; }, {}); // Add labels if ( Object . keys ( strings . fields ). length > 0 ) { out [ modelName ][ ` ${ modelName } __text` ] = strings ; } // Optimize unique indexes if ( Object . keys ( uniques . fields ). length > 1 ) { // Remove unique from other indexes model . fields . unique . map ( field => { const fieldName = field . names . snake ; if ( out [ modelName ][ ` ${ modelName } _ ${ fieldName } ` ]) { delete out [ modelName ][ ` ${ modelName } _ ${ fieldName } ` ]. options ; } }); // Add unique out [ modelName ][ ` ${ modelName } __uniques` ] = uniques ; } return out ; } const _output = models . reduce ( _model , {}); return JSON . stringify ( _output , null , 2 ); Output { \"service\" : { \"service_created_at\" : { \"fields\" : { \"created_at\" : 1 } }, \"service_name\" : { \"fields\" : { \"name\" : 1 }, \"options\" : { \"unique\" : true } }, \"service__text\" : { \"fields\" : { \"name\" : \"text\" } } }, \"user\" : { \"user_created_at\" : { \"fields\" : { \"created_at\" : 1 } }, \"user_name\" : { \"fields\" : { \"name\" : 1 } }, \"user_email\" : { \"fields\" : { \"email\" : 1 }, \"options\" : { \"unique\" : true } }, \"user_role\" : { \"fields\" : { \"role\" : 1 } }, \"user_banned\" : { \"fields\" : { \"banned\" : 1 } }, \"user__text\" : { \"fields\" : { \"name\" : \"text\" , \"email\" : \"text\" , \"role\" : \"text\" } } } } Generate a JSON description of the data model This template will produce a JSON that lists the fields and resolves the dependencies between the models. JavaScript const _output = models . map (( m ) => { return { collection : m . names . snake , dependencies : m . dependencies . list . map (( d ) => { return d . names . snake }), fields : m . fields . list . map (( f ) => { const out = { name : f . names . snake , notes : f . notes , type : f . type , subtype : f . subtype , properties : [] }; // Convert boolean properties to list for ( const prop of Object . keys ( f )) { if ( typeof f [ prop ] === 'boolean' && f [ prop ]) { out . properties . push ( prop ) } } // Append model reference if any if ( f . model ) { out . reference = f . model . names . snake ; } return out ; }) }; }); return JSON . stringify ( _output , null , 4 ); Output [ { \"collection\" : \"bookmark\" , \"dependencies\" : [ \"user\" , \"place\" ], \"fields\" : [ { \"name\" : \"_id\" , \"notes\" : null , \"type\" : \"string\" , \"subtype\" : null , \"properties\" : [ \"primary\" , \"internal\" ] }, { \"name\" : \"created_at\" , \"notes\" : null , \"type\" : \"datetime\" , \"subtype\" : null , \"properties\" : [ \"sortable\" , \"internal\" ] }, { \"name\" : \"owner\" , \"notes\" : \"Current user when creating the bookmark\" , \"type\" : \"entity\" , \"subtype\" : null , \"properties\" : [ \"unique\" , \"searchable\" , \"internal\" , \"ownership\" ], \"reference\" : \"user\" }, { \"name\" : \"place\" , \"notes\" : null , \"type\" : \"entity\" , \"subtype\" : null , \"properties\" : [ \"unique\" , \"searchable\" ], \"reference\" : \"place\" } ] } ]","title":"JavaScript"},{"location":"code-samples/javascript/#prerequisites","text":"Before reading this article, we recommend that you read the documentation about JavaScript templates .","title":"Prerequisites"},{"location":"code-samples/javascript/#creating-indexes-for-mongodb","text":"This template will produce a JSON containing all the indexes that must be created in MongoDB based on the field attributes. It creates an index for searchable, sortable fields or references. It also creates a unique index for unique fields and a text index for searchable string fields. JavaScript /** Generate indexes for a model */ function _model ( out , model ) { const modelName = model . names . snake ; const strings = { fields : {} }; const uniques = { fields : {}, options : { unique : true } }; // Even if no fields have indexes, Include this collection // Get fields objects out [ modelName ] = model . fields . list . reduce (( p , field ) => { // Non primary fields if ( field . primary ) { return p ; } // Only if the field is searchable, sortable a reference or is unique if ( ! ( field . sortable || field . searchable || field . type === 'entity' || field . unique )) { return p ; } const fieldName = field . names . snake ; // Special text index for strings if ( field . type === 'string' && field . searchable ) { strings . fields [ fieldName ] = 'text' ; } // Normal indexes p [ ` ${ modelName } _ ${ fieldName } ` ] = { fields : { [ fieldName ] : 1 } }; if ( field . unique ) { p [ ` ${ modelName } _ ${ fieldName } ` ]. options = { unique : true }; uniques . fields [ fieldName ] = 1 ; } return p ; }, {}); // Add labels if ( Object . keys ( strings . fields ). length > 0 ) { out [ modelName ][ ` ${ modelName } __text` ] = strings ; } // Optimize unique indexes if ( Object . keys ( uniques . fields ). length > 1 ) { // Remove unique from other indexes model . fields . unique . map ( field => { const fieldName = field . names . snake ; if ( out [ modelName ][ ` ${ modelName } _ ${ fieldName } ` ]) { delete out [ modelName ][ ` ${ modelName } _ ${ fieldName } ` ]. options ; } }); // Add unique out [ modelName ][ ` ${ modelName } __uniques` ] = uniques ; } return out ; } const _output = models . reduce ( _model , {}); return JSON . stringify ( _output , null , 2 ); Output { \"service\" : { \"service_created_at\" : { \"fields\" : { \"created_at\" : 1 } }, \"service_name\" : { \"fields\" : { \"name\" : 1 }, \"options\" : { \"unique\" : true } }, \"service__text\" : { \"fields\" : { \"name\" : \"text\" } } }, \"user\" : { \"user_created_at\" : { \"fields\" : { \"created_at\" : 1 } }, \"user_name\" : { \"fields\" : { \"name\" : 1 } }, \"user_email\" : { \"fields\" : { \"email\" : 1 }, \"options\" : { \"unique\" : true } }, \"user_role\" : { \"fields\" : { \"role\" : 1 } }, \"user_banned\" : { \"fields\" : { \"banned\" : 1 } }, \"user__text\" : { \"fields\" : { \"name\" : \"text\" , \"email\" : \"text\" , \"role\" : \"text\" } } } }","title":"Creating indexes for MongoDB"},{"location":"code-samples/javascript/#generate-a-json-description-of-the-data-model","text":"This template will produce a JSON that lists the fields and resolves the dependencies between the models. JavaScript const _output = models . map (( m ) => { return { collection : m . names . snake , dependencies : m . dependencies . list . map (( d ) => { return d . names . snake }), fields : m . fields . list . map (( f ) => { const out = { name : f . names . snake , notes : f . notes , type : f . type , subtype : f . subtype , properties : [] }; // Convert boolean properties to list for ( const prop of Object . keys ( f )) { if ( typeof f [ prop ] === 'boolean' && f [ prop ]) { out . properties . push ( prop ) } } // Append model reference if any if ( f . model ) { out . reference = f . model . names . snake ; } return out ; }) }; }); return JSON . stringify ( _output , null , 4 ); Output [ { \"collection\" : \"bookmark\" , \"dependencies\" : [ \"user\" , \"place\" ], \"fields\" : [ { \"name\" : \"_id\" , \"notes\" : null , \"type\" : \"string\" , \"subtype\" : null , \"properties\" : [ \"primary\" , \"internal\" ] }, { \"name\" : \"created_at\" , \"notes\" : null , \"type\" : \"datetime\" , \"subtype\" : null , \"properties\" : [ \"sortable\" , \"internal\" ] }, { \"name\" : \"owner\" , \"notes\" : \"Current user when creating the bookmark\" , \"type\" : \"entity\" , \"subtype\" : null , \"properties\" : [ \"unique\" , \"searchable\" , \"internal\" , \"ownership\" ], \"reference\" : \"user\" }, { \"name\" : \"place\" , \"notes\" : null , \"type\" : \"entity\" , \"subtype\" : null , \"properties\" : [ \"unique\" , \"searchable\" ], \"reference\" : \"place\" } ] } ]","title":"Generate a JSON description of the data model"},{"location":"getting-started/installation/","text":"Installing the CLI The first step is to install the CLI using NPM : npm install -g @hapify/cli You can also check if the package is installed by running: hpf --version . Optional : Connect CLI to Hapify Cloud The Hapify CLI can interact with Hapify Cloud to store your projects and their models. To do this, you need to get an API key from Hapify Cloud. 1. Sign up for Hapify Cloud If you do not have an account yet, please visit hapify.io/sign-up . 2. Get your API key Once you have registered, or if you already have an account, go to hapify.io/mykey and copy your API key. 3. Configure the CLI Run this command with your own API key to connect the CLI to Hapify Cloud. hpf key XXXXXXXXXXXX Your CLI can now interact with Hapify Cloud.","title":"Installation"},{"location":"getting-started/installation/#installing-the-cli","text":"The first step is to install the CLI using NPM : npm install -g @hapify/cli You can also check if the package is installed by running: hpf --version .","title":"Installing the CLI"},{"location":"getting-started/installation/#optional-connect-cli-to-hapify-cloud","text":"The Hapify CLI can interact with Hapify Cloud to store your projects and their models. To do this, you need to get an API key from Hapify Cloud.","title":"Optional: Connect CLI to Hapify Cloud"},{"location":"getting-started/installation/#1-sign-up-for-hapify-cloud","text":"If you do not have an account yet, please visit hapify.io/sign-up .","title":"1. Sign up for Hapify Cloud"},{"location":"getting-started/installation/#2-get-your-api-key","text":"Once you have registered, or if you already have an account, go to hapify.io/mykey and copy your API key.","title":"2. Get your API key"},{"location":"getting-started/installation/#3-configure-the-cli","text":"Run this command with your own API key to connect the CLI to Hapify Cloud. hpf key XXXXXXXXXXXX Your CLI can now interact with Hapify Cloud.","title":"3. Configure the CLI"},{"location":"getting-started/troubleshooting/","text":"While using the Hapify CLI/GUI, you may encounter some errors during code generation, template or model edition and project management. This guide will list all known errors to help you resolve them. If you find an unknown error, please contact us: hapify.io/contact . Errors sent by the Hapify syntax Errors range: 1000 to 1999 1001 (SyntaxInternalError): Thrown when an unexpected error is triggered. 1002 (SyntaxArgumentsError): Thrown when the \"run\" function is called with wrong arguments. 1003 (SyntaxParsingError): Thrown when the Hpf template has a syntax error. 1004 (SyntaxEvaluationError): Thrown when the evaluation of the Hpf template causes an error. 1005 (SyntaxTimeoutError): Thrown when the Hpf template is too long to process. Errors sent by the Hapify Generator Errors range: 2000 to 2999 2001 (GeneratorInternalError): Thrown when an unexpected error is triggered. 2002 (GeneratorRequestError): Thrown when routes are called with wrong arguments. 2003 (GeneratorRouteError): Thrown when an error occurs during routes processing (status >= 401). 2004 (GeneratorEvaluationError): Thrown when the evaluation of the JS template causes an error. 2005 (GeneratorTimeoutError): Thrown when the JS template is too long to process. Errors sent by the Hapify API Errors range: 3000 to 3999 Generic errors 3001 (ApiInternalError): Thrown when an unexpected error is triggered. 3002 (ApiError): Thrown when a route emits an error that cannot be specified. 3003 (ApiRequestError): Thrown when a route are called with wrong arguments. 3010 (ApiAuthenticationError): Thrown when there was an issue with the authentication. 3020 (ApiPlanError): Thrown when the resource reached a limit of the current plan. 3030 (ApiForbiddenError): Thrown when the access to the resource is forbidden. 3040 (ApiNotFoundError): Thrown when the resource is not found. 3090 (ApiDuplicateError): Thrown when the resource already exists. 3220 (ApiDataError): Thrown when the data to process is malformed. 3290 (ApiRateError): Thrown when too many requests have been done. Generator errors 3021 (ApiGeneratorPlanError): Thrown when a limit about models, fields or templates has been reached. 3031 (ApiGeneratorForbiddenError): Thrown when the access to a project or model is forbidden. 3041 (ApiGeneratorNotFoundError): Thrown when a project or model does not exist. 3221 (ApiGeneratorDataError): Thrown when there is no model attached to this project. 3291 (ApiGeneratorRateError): Thrown when too many requests have been done to the generator. Model errors 3032 (ApiModelForbiddenError): Thrown when the access to the model is forbidden. 3042 (ApiModelNotFoundError): Thrown when the project or model does not exist. Project errors 3023 (ApiProjectPlanError): Thrown when the user already reached their project limit. 3033 (ApiProjectForbiddenError): Thrown when the access to the project is forbidden. 3043 (ApiProjectNotFoundError): Thrown when the project does not exist. Errors sent by the Hapify CLI Errors range: 4000 to 4999 4001 (CliInternalError): Thrown when an unexpected error is triggered. 4002 (CliMessageValidationError): Thrown when an incoming message from web console is malformed. 4003 (CliDataValidationError): Thrown when data sent by the web console is malformed. 4004 (CliUnknownMessageError): Thrown when the incoming message ID is unknown. 4005 (CliValidatorEvaluationError): Thrown when the evaluation of the JS validator causes an error. 4006 (CliValidatorTimeoutError): Thrown when the JS validator is too long to process. 4007 (CliValidatorOutputError): Thrown when the JS validator returns malformed data. Errors sent by the Hapify GUI Errors range: 5000 to 5999 5001 (ConsoleInternalError): Thrown when an unexpected error is triggered. 5002 (ConsoleWebSocketError): Thrown when an error occurred with WebSocket client. 5003 (ConsoleWebSocketTimeoutError): Thrown when a timeout is triggered when calling WebSocket server. 5004 (ConsoleWebSocketFetchError): Thrown when unable to fetch connection information for WebSocket server. 5005 (ConsoleWebSocketConnectionError): Thrown when connection to WebSocket server is lost. 5006 (ConsoleWebSocketResponseError): Thrown when an unknown error is returned by the WebSocket client. Errors sent by the Hapify VM Errors range: 6000 to 6999 6001 (VmOutputError): Thrown when the script does not return a string or undefined. 6002 (VmEvaluationError): Thrown when the evaluation of the JS script causes an error. 6003 (VmTimeoutError): Thrown when the JS script is too long to process. 6004 (VmIntegrityError): Thrown when the script throws a modified error. Errors sent by the EJS generator Errors range: 7000 to 7999 7001 (EjsEvaluationError) : Thrown when the evaluation of the EJS script causes an error.","title":"Troubleshooting"},{"location":"getting-started/troubleshooting/#errors-sent-by-the-hapify-syntax","text":"Errors range: 1000 to 1999 1001 (SyntaxInternalError): Thrown when an unexpected error is triggered. 1002 (SyntaxArgumentsError): Thrown when the \"run\" function is called with wrong arguments. 1003 (SyntaxParsingError): Thrown when the Hpf template has a syntax error. 1004 (SyntaxEvaluationError): Thrown when the evaluation of the Hpf template causes an error. 1005 (SyntaxTimeoutError): Thrown when the Hpf template is too long to process.","title":"Errors sent by the Hapify syntax"},{"location":"getting-started/troubleshooting/#errors-sent-by-the-hapify-generator","text":"Errors range: 2000 to 2999 2001 (GeneratorInternalError): Thrown when an unexpected error is triggered. 2002 (GeneratorRequestError): Thrown when routes are called with wrong arguments. 2003 (GeneratorRouteError): Thrown when an error occurs during routes processing (status >= 401). 2004 (GeneratorEvaluationError): Thrown when the evaluation of the JS template causes an error. 2005 (GeneratorTimeoutError): Thrown when the JS template is too long to process.","title":"Errors sent by the Hapify Generator"},{"location":"getting-started/troubleshooting/#errors-sent-by-the-hapify-api","text":"Errors range: 3000 to 3999","title":"Errors sent by the Hapify API"},{"location":"getting-started/troubleshooting/#generic-errors","text":"3001 (ApiInternalError): Thrown when an unexpected error is triggered. 3002 (ApiError): Thrown when a route emits an error that cannot be specified. 3003 (ApiRequestError): Thrown when a route are called with wrong arguments. 3010 (ApiAuthenticationError): Thrown when there was an issue with the authentication. 3020 (ApiPlanError): Thrown when the resource reached a limit of the current plan. 3030 (ApiForbiddenError): Thrown when the access to the resource is forbidden. 3040 (ApiNotFoundError): Thrown when the resource is not found. 3090 (ApiDuplicateError): Thrown when the resource already exists. 3220 (ApiDataError): Thrown when the data to process is malformed. 3290 (ApiRateError): Thrown when too many requests have been done.","title":"Generic errors"},{"location":"getting-started/troubleshooting/#generator-errors","text":"3021 (ApiGeneratorPlanError): Thrown when a limit about models, fields or templates has been reached. 3031 (ApiGeneratorForbiddenError): Thrown when the access to a project or model is forbidden. 3041 (ApiGeneratorNotFoundError): Thrown when a project or model does not exist. 3221 (ApiGeneratorDataError): Thrown when there is no model attached to this project. 3291 (ApiGeneratorRateError): Thrown when too many requests have been done to the generator.","title":"Generator errors"},{"location":"getting-started/troubleshooting/#model-errors","text":"3032 (ApiModelForbiddenError): Thrown when the access to the model is forbidden. 3042 (ApiModelNotFoundError): Thrown when the project or model does not exist.","title":"Model errors"},{"location":"getting-started/troubleshooting/#project-errors","text":"3023 (ApiProjectPlanError): Thrown when the user already reached their project limit. 3033 (ApiProjectForbiddenError): Thrown when the access to the project is forbidden. 3043 (ApiProjectNotFoundError): Thrown when the project does not exist.","title":"Project errors"},{"location":"getting-started/troubleshooting/#errors-sent-by-the-hapify-cli","text":"Errors range: 4000 to 4999 4001 (CliInternalError): Thrown when an unexpected error is triggered. 4002 (CliMessageValidationError): Thrown when an incoming message from web console is malformed. 4003 (CliDataValidationError): Thrown when data sent by the web console is malformed. 4004 (CliUnknownMessageError): Thrown when the incoming message ID is unknown. 4005 (CliValidatorEvaluationError): Thrown when the evaluation of the JS validator causes an error. 4006 (CliValidatorTimeoutError): Thrown when the JS validator is too long to process. 4007 (CliValidatorOutputError): Thrown when the JS validator returns malformed data.","title":"Errors sent by the Hapify CLI"},{"location":"getting-started/troubleshooting/#errors-sent-by-the-hapify-gui","text":"Errors range: 5000 to 5999 5001 (ConsoleInternalError): Thrown when an unexpected error is triggered. 5002 (ConsoleWebSocketError): Thrown when an error occurred with WebSocket client. 5003 (ConsoleWebSocketTimeoutError): Thrown when a timeout is triggered when calling WebSocket server. 5004 (ConsoleWebSocketFetchError): Thrown when unable to fetch connection information for WebSocket server. 5005 (ConsoleWebSocketConnectionError): Thrown when connection to WebSocket server is lost. 5006 (ConsoleWebSocketResponseError): Thrown when an unknown error is returned by the WebSocket client.","title":"Errors sent by the Hapify GUI"},{"location":"getting-started/troubleshooting/#errors-sent-by-the-hapify-vm","text":"Errors range: 6000 to 6999 6001 (VmOutputError): Thrown when the script does not return a string or undefined. 6002 (VmEvaluationError): Thrown when the evaluation of the JS script causes an error. 6003 (VmTimeoutError): Thrown when the JS script is too long to process. 6004 (VmIntegrityError): Thrown when the script throws a modified error.","title":"Errors sent by the Hapify VM"},{"location":"getting-started/troubleshooting/#errors-sent-by-the-ejs-generator","text":"Errors range: 7000 to 7999 7001 (EjsEvaluationError) : Thrown when the evaluation of the EJS script causes an error.","title":"Errors sent by the EJS generator"},{"location":"getting-started/concepts/key-concepts/","text":"Hapify automates the writing of CRUD operations for both back-end and front-end development. Focus only on business features instead of doing repetitive work! Hapify is an agnostic code generator for any type of application manipulating data models, in any language. Hapify works with any paradigm or code structure. You can write your own code templates or use those provided by the community. Hapify takes two inputs: data models and code templates . Templating Hapify provides a simple but powerful syntax to help you create dynamic boilerplates. Using Hapify you can either: Convert your own boilerplates into dynamic boilerplates. Use boilerplates provided by the community See also For more information about template engines, refer to the Hapify syntax documentation and the EJS and JavaScript templates documentation . Data modeling Hapify lets you define the data models that fit your project specifications. The model definition in Hapify is agnostic and featured-oriented (behavioral), which means Hapify defines what the model should do , not how it will do it . The data models can be edited in a local web console. Tip You can import data models provided on the Hapify Hub . See also For more information on data models, you can refer to this . Hapify Boilerplate A typical Hapify boilerplate is divided into two parts: Dynamic files: Hapify template files, compatible with Hapify data models and the Hapify engine. Static files: All other files, which are not related to data models: Docker files, CSS files, libraries, plugins, etc. Channel A channel is a set of templates. Most boilerplates have only one channel. However, a full-stack boilerplate can contain two channels, one for front-end templates and one for back-end templates.","title":"Key concepts"},{"location":"getting-started/concepts/key-concepts/#templating","text":"Hapify provides a simple but powerful syntax to help you create dynamic boilerplates. Using Hapify you can either: Convert your own boilerplates into dynamic boilerplates. Use boilerplates provided by the community See also For more information about template engines, refer to the Hapify syntax documentation and the EJS and JavaScript templates documentation .","title":"Templating"},{"location":"getting-started/concepts/key-concepts/#data-modeling","text":"Hapify lets you define the data models that fit your project specifications. The model definition in Hapify is agnostic and featured-oriented (behavioral), which means Hapify defines what the model should do , not how it will do it . The data models can be edited in a local web console. Tip You can import data models provided on the Hapify Hub . See also For more information on data models, you can refer to this .","title":"Data modeling"},{"location":"getting-started/concepts/key-concepts/#hapify-boilerplate","text":"A typical Hapify boilerplate is divided into two parts: Dynamic files: Hapify template files, compatible with Hapify data models and the Hapify engine. Static files: All other files, which are not related to data models: Docker files, CSS files, libraries, plugins, etc.","title":"Hapify Boilerplate"},{"location":"getting-started/concepts/key-concepts/#channel","text":"A channel is a set of templates. Most boilerplates have only one channel. However, a full-stack boilerplate can contain two channels, one for front-end templates and one for back-end templates.","title":"Channel"},{"location":"getting-started/concepts/models/","text":"Modeling approach The model definition in Hapify is agnostic and featured-oriented (behavioral), which means Hapify defines what the model should do , not how it will do it . Access management Hapify supports the 6 following base operations: Create Read Update Delete Search Count For each of these actions, Hapify allows you to define the following access restrictions: Guest : user who is not logged-in. Authenticated : logged-in user. Owner : logged-in user who owns the entity (see Field attributes for more details). Admin : logged-in super-admin user. Accesses are inclusive, which means the Authenticated restriction necessarily includes Owner and Admin . Guest is the most permissive and Admin the least permissive. Therefore Admin < Owner < Authenticated < Guest . Fields A model contains a list of fields. Each field is defined by: a name a type a subtype (optional) a set of (behavioral) attributes. Types and subtypes Available types ans subtypes are: string email , password , url , text , rich number integer , float , latitude , longitude boolean datetime date , time enum entity (reference to another model) oneOne , oneMany , manyOne , manyMany object file image , video , audio , document Field attributes Primary : the field is the primary identifier. Unique : the field contains unique values, required to avoid duplicates. A model could have multiple unique keys. (e.g.: user's email or coupon code). Label : the field is a human readable identifier. (e.g.: user's first name and last name, a movie title). Nullable : the field can contain empty value. In other words, it is not required. Multiple : this field will contain not a single value but a list of value or references. Embedded : ability to automatically attach data from a linked entity. (e.g.: When you get a user's details, you may want to get their avatar at the same time). This can be used to embed forms as well. Searchable : ability to search for entities based on this field. Sortable : ability to sort search results based on this field. Hidden : this field should never be sent to the end-user. (e.g.: user's password). Internal : a value defined internally by the system, which the end-user cannot set (e.g.: entity creation date, primary key, etc.). Restricted : if data access (read and/or write) is restricted to specific users (e.g.: a validated status to be set by an admin only). Ownership : defines the identity of the entity owner(s) (e.g.: a bar with a field creator containing the user ID). See also For the complete structure of the data models, you can refer to this documentation .","title":"Data models"},{"location":"getting-started/concepts/models/#modeling-approach","text":"The model definition in Hapify is agnostic and featured-oriented (behavioral), which means Hapify defines what the model should do , not how it will do it .","title":"Modeling approach"},{"location":"getting-started/concepts/models/#access-management","text":"Hapify supports the 6 following base operations: Create Read Update Delete Search Count For each of these actions, Hapify allows you to define the following access restrictions: Guest : user who is not logged-in. Authenticated : logged-in user. Owner : logged-in user who owns the entity (see Field attributes for more details). Admin : logged-in super-admin user. Accesses are inclusive, which means the Authenticated restriction necessarily includes Owner and Admin . Guest is the most permissive and Admin the least permissive. Therefore Admin < Owner < Authenticated < Guest .","title":"Access management"},{"location":"getting-started/concepts/models/#fields","text":"A model contains a list of fields. Each field is defined by: a name a type a subtype (optional) a set of (behavioral) attributes.","title":"Fields"},{"location":"getting-started/concepts/models/#types-and-subtypes","text":"Available types ans subtypes are: string email , password , url , text , rich number integer , float , latitude , longitude boolean datetime date , time enum entity (reference to another model) oneOne , oneMany , manyOne , manyMany object file image , video , audio , document","title":"Types and subtypes"},{"location":"getting-started/concepts/models/#field-attributes","text":"Primary : the field is the primary identifier. Unique : the field contains unique values, required to avoid duplicates. A model could have multiple unique keys. (e.g.: user's email or coupon code). Label : the field is a human readable identifier. (e.g.: user's first name and last name, a movie title). Nullable : the field can contain empty value. In other words, it is not required. Multiple : this field will contain not a single value but a list of value or references. Embedded : ability to automatically attach data from a linked entity. (e.g.: When you get a user's details, you may want to get their avatar at the same time). This can be used to embed forms as well. Searchable : ability to search for entities based on this field. Sortable : ability to sort search results based on this field. Hidden : this field should never be sent to the end-user. (e.g.: user's password). Internal : a value defined internally by the system, which the end-user cannot set (e.g.: entity creation date, primary key, etc.). Restricted : if data access (read and/or write) is restricted to specific users (e.g.: a validated status to be set by an admin only). Ownership : defines the identity of the entity owner(s) (e.g.: a bar with a field creator containing the user ID). See also For the complete structure of the data models, you can refer to this documentation .","title":"Field attributes"},{"location":"getting-started/concepts/terminology/","text":"Hapify uses specific terms to describe its concepts. boilerplate : A boilerplate is an application base. It is from this that you will build a new application. It is composed of static files and dynamic files. dynamic file : File that is generated by Hapify via a template and data models. static file : Any other file that is not generated: Example: Docker files, CSS files, libraries, plugins, etc. template : File containing meta-code that can be used to generate target code. There are several template engines, each of which can interpret a different meta-code. channel : A set of templates. Most boilerplates have only one channel. However, a full-stack boilerplate may contain two channels, one for front-end templates and one for back-end templates. model : Relational data model describing the specifications of a project. field : An entry in a data model. field type : Property of a field describing its data type. Example: text, boolean, number, etc. field attribute : Property of a field describing its behavior. Example: searchable, hidden, etc. project : Application defined by a list of data models. target code : Source code generated by a template fed by one or more data models. This is the source code used by the final application. meta-code : Source code of the template. This code will describe how to generate the target code from one or more data models. preset : Collection of predefined data models that can be imported at the start of a project. action : Operation that can be performed on an entity: Create , Read , Update , Delete , Search , Count .","title":"Terminology"},{"location":"getting-started/create-boilerplate/introduction/","text":"Summary In this section you will learn how to create your own boilerplate with Hapify. You can start a boilerplate from scratch or use a pre-existing boilerplate. This section focuses on writing templates code. Since Hapify is an agnostic framework engine and is not limited to a specific framework, we will not focus on the boilerplate structure itself. We will look at some common template examples. Tip If your boilerplate uses npm or yarn as a package manager, you can add the CLI as a development dependency: npm install --save-dev @hapify/cli . Also add a script in package.json : \"hpf\": \"hpf\" . This way you can define a version of Hapify for your boilerplate and use it with npm run hpf . Template engines Hapify offers three template engines. A boilerplate can use several engines simultaneously. These engines have access to the model object . This object, injected into the templates, makes the data model and all its properties and relationships explicit, so that they are easily accessible within the template. Hapify template engine This syntax is optimized to play with the model object and its properties using short words. This allows you to handle complex ideas with simple sentences. This syntax has two variants: long : easy to read short : based on abbreviations Both variants can be used in the same template. Example This loop in JavaScript: for ( let f of model . fields . list . filter ( f => f . searchable && f . type === 'entity' )) { out += 'Field name: ' + f . names . camel ; } Will be written like this with the Hapify syntax: Long syntax <<for Fields searchable and entity f >> Field name: <<f camel>> <<endfor>> Short syntax <<@ F se * tE f >> Field name: <<f aA>> <<@>> Pros An easy-to-read meta-code A shorter meta-code, making the target code more readable Even shorter with the short variant Cons Another syntax to learn, although it is simple The syntax may not handle specific conditions EJS engine You can use EJS as a template engine. All EJS features are available, except the include feature. This feature is intentionally disabled so that templates do not have access to your file system. Example This loop in JavaScript: for ( let f of model . fields . list . filter ( f => f . searchable ) { out += 'Field name: ' + f . names . camel ; } Will be written like this with EJS: <% for ( let f of model . fields . list . filter ( f => f . searchable ) { %> Field name : <%= f . names . camel %> <% } %> Pros A well-known template engine Handles complex conditions and interpolation properly More flexibility Cons Long meta-code, making the target code less readable JavaScript engine You can write templates in pure JavaScript. This engine is very useful to generate JSON files. Example const output = models . map (( model ) => model . names . snake ); return JSON . stringify ( output , null , 2 ); const property = ( field ) => `private ${ field . names . camel } ;` ; return `class ${ model . names . pascal } { ${ model . fields . list . map ( property ). join ( '\\n ' ) } }` ; Pros Powerful when generating configuration files such as JSON Very flexible Cons It is hard to differentiate the meta-code from the target code","title":"Introduction"},{"location":"getting-started/create-boilerplate/introduction/#summary","text":"In this section you will learn how to create your own boilerplate with Hapify. You can start a boilerplate from scratch or use a pre-existing boilerplate. This section focuses on writing templates code. Since Hapify is an agnostic framework engine and is not limited to a specific framework, we will not focus on the boilerplate structure itself. We will look at some common template examples. Tip If your boilerplate uses npm or yarn as a package manager, you can add the CLI as a development dependency: npm install --save-dev @hapify/cli . Also add a script in package.json : \"hpf\": \"hpf\" . This way you can define a version of Hapify for your boilerplate and use it with npm run hpf .","title":"Summary"},{"location":"getting-started/create-boilerplate/introduction/#template-engines","text":"Hapify offers three template engines. A boilerplate can use several engines simultaneously. These engines have access to the model object . This object, injected into the templates, makes the data model and all its properties and relationships explicit, so that they are easily accessible within the template.","title":"Template engines"},{"location":"getting-started/create-boilerplate/introduction/#hapify-template-engine","text":"This syntax is optimized to play with the model object and its properties using short words. This allows you to handle complex ideas with simple sentences. This syntax has two variants: long : easy to read short : based on abbreviations Both variants can be used in the same template.","title":"Hapify template engine"},{"location":"getting-started/create-boilerplate/introduction/#example","text":"This loop in JavaScript: for ( let f of model . fields . list . filter ( f => f . searchable && f . type === 'entity' )) { out += 'Field name: ' + f . names . camel ; } Will be written like this with the Hapify syntax: Long syntax <<for Fields searchable and entity f >> Field name: <<f camel>> <<endfor>> Short syntax <<@ F se * tE f >> Field name: <<f aA>> <<@>> Pros An easy-to-read meta-code A shorter meta-code, making the target code more readable Even shorter with the short variant Cons Another syntax to learn, although it is simple The syntax may not handle specific conditions","title":"Example"},{"location":"getting-started/create-boilerplate/introduction/#ejs-engine","text":"You can use EJS as a template engine. All EJS features are available, except the include feature. This feature is intentionally disabled so that templates do not have access to your file system.","title":"EJS engine"},{"location":"getting-started/create-boilerplate/introduction/#example_1","text":"This loop in JavaScript: for ( let f of model . fields . list . filter ( f => f . searchable ) { out += 'Field name: ' + f . names . camel ; } Will be written like this with EJS: <% for ( let f of model . fields . list . filter ( f => f . searchable ) { %> Field name : <%= f . names . camel %> <% } %> Pros A well-known template engine Handles complex conditions and interpolation properly More flexibility Cons Long meta-code, making the target code less readable","title":"Example"},{"location":"getting-started/create-boilerplate/introduction/#javascript-engine","text":"You can write templates in pure JavaScript. This engine is very useful to generate JSON files.","title":"JavaScript engine"},{"location":"getting-started/create-boilerplate/introduction/#example_2","text":"const output = models . map (( model ) => model . names . snake ); return JSON . stringify ( output , null , 2 ); const property = ( field ) => `private ${ field . names . camel } ;` ; return `class ${ model . names . pascal } { ${ model . fields . list . map ( property ). join ( '\\n ' ) } }` ; Pros Powerful when generating configuration files such as JSON Very flexible Cons It is hard to differentiate the meta-code from the target code","title":"Example"},{"location":"getting-started/create-boilerplate/step-1-new-channel/","text":"Channel vs boilerplate ? A channel is a set of templates. Most boilerplates have only one channel. However, a full-stack boilerplate can contain two channels, one for front-end templates and one for back-end templates. Run the command init . Create a new folder for your project and go to that folder: mkdir my-project && cd my-project Tip You can also start a channel in a pre-existing boilerplate. Use the command init to initialize a channel in this folder. hpf init Create a project You must create a new project in order to create a new channel. When prompted, enter the name and description. ? Enter a project name First project ? Enter a project description My first project with Hapify Create the channel Once the project is defined, enter the channel details. ? Enter the channel name Typescript Backend ? Enter a description API for my app ? Enter a logo URL https://cdn.worldvectorlogo.com/logos/typescript.svg \u2713 Initialized a channel in /Users/edouard/workspace/hapify/my-project. Run hpf use to connect a remote project (optional) Here is the hierarchy of the created files: ~/my-project \u251c\u2500\u2500 .hapify | \u251c\u2500\u2500 models | | \u2514\u2500\u2500 __kebab__ | | \u2514\u2500\u2500 hello.js.hpf | \u2514\u2500\u2500 validator.js \u251c\u2500\u2500 hapify-models.json \u2514\u2500\u2500 hapify.json hapify.json is the configuration file. It contains the channel metadata and the list of templates. The hapify-models.json file contains the data models for your project. It is referenced by the configuration file ( hapify.json ). You can move or rename this file as long as you change the path in the configuration file. The .hapify folder (can also be named hapify ) contains all the channel templates.","title":"Step 1: New channel"},{"location":"getting-started/create-boilerplate/step-1-new-channel/#run-the-command-init","text":"Create a new folder for your project and go to that folder: mkdir my-project && cd my-project Tip You can also start a channel in a pre-existing boilerplate. Use the command init to initialize a channel in this folder. hpf init","title":"Run the command init."},{"location":"getting-started/create-boilerplate/step-1-new-channel/#create-a-project","text":"You must create a new project in order to create a new channel. When prompted, enter the name and description. ? Enter a project name First project ? Enter a project description My first project with Hapify","title":"Create a project"},{"location":"getting-started/create-boilerplate/step-1-new-channel/#create-the-channel","text":"Once the project is defined, enter the channel details. ? Enter the channel name Typescript Backend ? Enter a description API for my app ? Enter a logo URL https://cdn.worldvectorlogo.com/logos/typescript.svg \u2713 Initialized a channel in /Users/edouard/workspace/hapify/my-project. Run hpf use to connect a remote project (optional) Here is the hierarchy of the created files: ~/my-project \u251c\u2500\u2500 .hapify | \u251c\u2500\u2500 models | | \u2514\u2500\u2500 __kebab__ | | \u2514\u2500\u2500 hello.js.hpf | \u2514\u2500\u2500 validator.js \u251c\u2500\u2500 hapify-models.json \u2514\u2500\u2500 hapify.json hapify.json is the configuration file. It contains the channel metadata and the list of templates. The hapify-models.json file contains the data models for your project. It is referenced by the configuration file ( hapify.json ). You can move or rename this file as long as you change the path in the configuration file. The .hapify folder (can also be named hapify ) contains all the channel templates.","title":"Create the channel"},{"location":"getting-started/create-boilerplate/step-2-add-models/","text":"Run the serve command. At this point, you have an empty channel and no data models in your project. In order to create a new template, you must first create some data models. Run this command : hpf serve Add data models Create or import data models for your project. This step is mandatory for the following step in order to validate that your templates work. We recommend that you add the data models that will cover the use cases you want to handle. For example, if you plan to handle latitude and longitude in your templates, then add at least one data model that includes these fields. Another common case is relationships between data models. We recommend that you add several relationships between your data models, even a self-referencing relationship. See also To learn more about data model management, please refer to the section editing data models . Default fields You can define default fields that will be added to any new data model. These fields are not binding, the user can modify or delete them if he/she wants. This is useful to define the primary key of your data models for example. The default fields are defined in the hapify.json file: { \"defaultFields\" : [ { \"name\" : \"Id\" , \"type\" : \"string\" , \"properties\" : [ \"primary\" , \"internal\" ] } ] } To get these default fields, you can create a data model that contains only the desired default fields. Then open the hapify-models.json file, and copy the fields from that data model: { \"fields\" : [ { \"name\" : \"id\" , \"type\" : \"number\" , \"properties\" : [ \"primary\" , \"internal\" ] } ] } Finally, paste this into the hapify.json file at the defaultFields line. Warning Changes to the hapify.json file are not reflected on the fly. You must rerun the hpf serve command.","title":"Step 2: Add data models"},{"location":"getting-started/create-boilerplate/step-2-add-models/#run-the-serve-command","text":"At this point, you have an empty channel and no data models in your project. In order to create a new template, you must first create some data models. Run this command : hpf serve","title":"Run the serve command."},{"location":"getting-started/create-boilerplate/step-2-add-models/#add-data-models","text":"Create or import data models for your project. This step is mandatory for the following step in order to validate that your templates work. We recommend that you add the data models that will cover the use cases you want to handle. For example, if you plan to handle latitude and longitude in your templates, then add at least one data model that includes these fields. Another common case is relationships between data models. We recommend that you add several relationships between your data models, even a self-referencing relationship. See also To learn more about data model management, please refer to the section editing data models .","title":"Add data models"},{"location":"getting-started/create-boilerplate/step-2-add-models/#default-fields","text":"You can define default fields that will be added to any new data model. These fields are not binding, the user can modify or delete them if he/she wants. This is useful to define the primary key of your data models for example. The default fields are defined in the hapify.json file: { \"defaultFields\" : [ { \"name\" : \"Id\" , \"type\" : \"string\" , \"properties\" : [ \"primary\" , \"internal\" ] } ] } To get these default fields, you can create a data model that contains only the desired default fields. Then open the hapify-models.json file, and copy the fields from that data model: { \"fields\" : [ { \"name\" : \"id\" , \"type\" : \"number\" , \"properties\" : [ \"primary\" , \"internal\" ] } ] } Finally, paste this into the hapify.json file at the defaultFields line. Warning Changes to the hapify.json file are not reflected on the fly. You must rerun the hpf serve command.","title":"Default fields"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/","text":"Now that you have added some data models to drive template development, you can start writing templates. Selection of the boilerplate/channel Go to the graphical interface (command hpf serve ). Click on the Boilerplates tab and select the previously created boilerplate. Click on Edit boilerplate . List of templates You are now on this page: The left sidebar shows all the templates available in your channel by organizing them in folders. On the right, an overview of the templates available in the folder selected on the left. Adding a template Click New path below a folder and enter a file path to create a new template. Tip You can add / in the template name to create its parent folders: path/to/template.ts Dynamic template name You can create a dynamic template name based on the model name: path/to/{camel}.ts . If you have three models: user , user profile and listing , then this template will spawn three files: path/to/user.ts , path/to/userProfile.ts and path/to/listing.ts . The available cases are: {camel} example : userProfile {pascal} example : UserProfile {lower} example : user profile {capital} example : User Profile {kebab} example : user-profile {header} example : User-Profile {snake} example : user_profile {constant} example : USER_PROFILE {compact} example : userprofile {raw} example : User profile (for the original name) Warning Dynamic names only work for templates of type one model . Change the name of a template Click on the name in the left part and change it. Delete a template Hover over the name of the template in the left bar and click on the \"delete\" icon. Choose the template engine Several template engines are available. Choose the input type A template can receive as input one data model or all data models. During generation, if set to one model , the template will be called once for each data model. Therefore, it will generate one file for each data model. If it is set as all models , the template will be called once for all data models. It will then produce a single file. Template Editor To access the template editor, hover over a template in the list on the right and click on Open editor . On the left side is the template code, which you can edit. On the right, a preview of the rendering of the template for the selected data model. Also, in the navigation bar is the path to the template and the path to the generated file. Tip You can directly change the template path in the navigation bar. Tip It is possible to automatically generate the target files when you save your template by clicking on the hammer icon. Warning The selection of data models is only available for templates of type one model .","title":"Step 3: Add templates"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#selection-of-the-boilerplatechannel","text":"Go to the graphical interface (command hpf serve ). Click on the Boilerplates tab and select the previously created boilerplate. Click on Edit boilerplate .","title":"Selection of the boilerplate/channel"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#list-of-templates","text":"You are now on this page: The left sidebar shows all the templates available in your channel by organizing them in folders. On the right, an overview of the templates available in the folder selected on the left.","title":"List of templates"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#adding-a-template","text":"Click New path below a folder and enter a file path to create a new template. Tip You can add / in the template name to create its parent folders: path/to/template.ts","title":"Adding a template"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#dynamic-template-name","text":"You can create a dynamic template name based on the model name: path/to/{camel}.ts . If you have three models: user , user profile and listing , then this template will spawn three files: path/to/user.ts , path/to/userProfile.ts and path/to/listing.ts . The available cases are: {camel} example : userProfile {pascal} example : UserProfile {lower} example : user profile {capital} example : User Profile {kebab} example : user-profile {header} example : User-Profile {snake} example : user_profile {constant} example : USER_PROFILE {compact} example : userprofile {raw} example : User profile (for the original name) Warning Dynamic names only work for templates of type one model .","title":"Dynamic template name"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#change-the-name-of-a-template","text":"Click on the name in the left part and change it.","title":"Change the name of a template"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#delete-a-template","text":"Hover over the name of the template in the left bar and click on the \"delete\" icon.","title":"Delete a template"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#choose-the-template-engine","text":"Several template engines are available.","title":"Choose the template engine"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#choose-the-input-type","text":"A template can receive as input one data model or all data models. During generation, if set to one model , the template will be called once for each data model. Therefore, it will generate one file for each data model. If it is set as all models , the template will be called once for all data models. It will then produce a single file.","title":"Choose the input type"},{"location":"getting-started/create-boilerplate/step-3-boilerplate-and-templates/#template-editor","text":"To access the template editor, hover over a template in the list on the right and click on Open editor . On the left side is the template code, which you can edit. On the right, a preview of the rendering of the template for the selected data model. Also, in the navigation bar is the path to the template and the path to the generated file. Tip You can directly change the template path in the navigation bar. Tip It is possible to automatically generate the target files when you save your template by clicking on the hammer icon. Warning The selection of data models is only available for templates of type one model .","title":"Template Editor"},{"location":"getting-started/create-boilerplate/step-4-template-writing/","text":"Introduction This section presents typical use cases for templates. Each code example is provided with the following template engines: Hapify (long and short syntaxes) EJS JavaScript For full details of the Hapify syntax, please refer to this article . To learn about the EJS syntax, please refer to the official documentation . Warning All EJS features are available, except the include feature. This feature is intentionally disabled so that templates do not have access to your file system. Data model manipulation Templates receive as input the model object . This object, injected in the templates, describes the data model and all its properties and relations, so that they are easily accessible from the template. We recommend that you understand its structure before you start writing templates. Code examples Names Create a class for the current data model This block creates a class for the data model (in pascal case) and defines the primary key name, in snake case. Hapify (long) class <<Model pascal>> { private primaryKey = ' <<PrimaryField snake>> '; } Hapify (short) class <<M AA>> { private primaryKey = ' <<P a_a>> '; } EJS class <%= model . names . pascal %> { private primaryKey = '<%= model.fields.primary.names.snake %>' ; } JavaScript return `class ${ model . names . pascal } { private primaryKey = ' ${ model . fields . primary . names . snake } '; }` ; Output class Place { private primaryKey = '_id' ; } Conditions Include dependencies based on field attributes In a template of type one model , this block imports the MongoDB driver if the data model has a relationship with another. Hapify (long) <<if Fields entity >> const mongoDb = require('mongodb'); <<endif>> Hapify (short) <<? F tE >> const mongoDb = require('mongodb'); <<?>> EJS <% if ( model . fields . filter ( f => f . type === 'entity' ). length > 0 ) { -%> const mongoDb = require ( 'mongodb' ); <% } -%> JavaScript let output = '' ; if ( model . fields . filter ( f => f . type === 'entity' ). length > 0 ) { output += `const mongoDb = require('mongodb');` } return output ; Output const mongoDb = require ( 'mongodb' ); Validate the session if the operation requires authentication In a template of type one model , if the create action requires at most one authenticated user, this block retrieves the logged in user. Reminder guest is the most permissive access and admin the least permissive. Therefore admin < owner < authenticated < guest . Hapify (long) <<if CreateAccess lteAuth >> const user = Session.getCurrent(); <<endif>> Hapify (short) <<? Ac au] >> const user = Session.getCurrent(); <<?>> EJS <% if ( model . accesses . create . lteAuth ) { -%> const user = Session . getCurrent (); <% } -%> JavaScript let output = '' ; if ( model . accesses . create . lteAuth ) { output += `const user = Session.getCurrent();` } return output ; Output const user = Session . getCurrent (); Test if the data model is geolocated In a template of type one model , if the data model has the property isGeolocated (i.e. if the data model contains at least one latitude field and one longitude field) this block imports the map position selection component. Hapify (long) <<if Model isGeolocated >> <app-map-position-picker [model]=\" <<Model camel>> \"></app-map-position-picker> <<endif>> Hapify (short) <<? M pGeo >> <app-map-position-picker [model]=\" <<M aA>> \"></app-map-position-picker> <<?>> EJS <% if ( model . properties . isGeolocated ) { -%> < app - map - position - picker [ model ] = \"<%= model.names.camel %>\" >< /app-map-position-picker> <% } -%> JavaScript let output = '' ; if ( model . properties . isGeolocated ) { output += `<app-map-position-picker [model]=\" ${ model . names . camel } \"></app-map-position-picker>` } return output ; Output < app-map-position-picker [ model ]=\" place \" ></ app-map-position-picker > Getting relationships based on cardinality This example creates a method that retrieves entities from a store, depending on the type of relationship: one-to-one , one-to-many or many-to-many . Hapify (long) class <<Model pascal>> extends BaseModel { <<for Fields entity field >> get <<field pascal>> () { <<if field oneOne or oneMany >> return this. <<field.model camel>> Store.findOne(this.properties. <<field camel>> ); <<elseif field manyMany >> return this. <<field.model camel>> Store.findMany(this.properties. <<field camel>> ); <<endif>> } <<endfor>> } Hapify (short) class <<M AA>> extends BaseModel { <<@ F tE f >> get <<f AA>> () { <<? f tEoo + tEom >> return this. <<f.m aA>> Store.findOne(this.properties. <<f aA>> ); <<?? f tEmm >> return this. <<f.m aA>> Store.findMany(this.properties. <<f aA>> ); <<?>> } <<@>> } EJS class <%= model . names . pascal %> extends BaseModel { <% for ( let field of model . fields . filter ( f => f . type === 'entity' )) { -%> get <%= field . names . pascal %> () { <% if ( field . subtype === 'oneOne' || field . subtype === 'oneMany' ) { -%> return this . <%= field . model . names . camel %> Store . findOne ( this . properties . <%= field . names . camel %> ); <% } else if ( field . subtype === 'manyMany' ) { -%> return this . <%= field . model . names . camel %> Store . findMany ( this . properties . <%= field . names . camel %> ); <% } -%> } <% } -%> } JavaScript let output = '' ; output += `class ${ model . names . pascal } extends BaseModel { ${ getRelations () } }` ; function getRelations () { return model . fields . filter ( f => f . type === 'entity' ). reduce (( acc , field ) => { return acc + getRelation ( field ) + '\\n\\t' ; }, '' ); } function getRelation ( field ) { let method = '' ; if ( field . subtype === 'oneOne' || field . subtype === 'oneMany' ) { method = 'findOne' ; } else if ( field . subtype === 'manyMany' ) { method = 'findMany' ; } else { return '' ; } return `get ${ field . names . pascal } () { return this. ${ field . model . names . camel } Store. ${ method } (this.properties. ${ field . names . camel } ); }` ; } return output ; Output class User extends BaseModel { getAvatar() { return this . avatarStore . findOne ( this . properties . avatar ); } getBookmarks() { return this . placeStore . findMany ( this . properties . bookmarks ); } } Iterations Fill an array with all hidden field names In a template of type one model , this block creates an array (in JavaScript) that contains the names of hidden fields (in camel case). Hapify (long) const hiddenFields = [ <<for Fields hidden field >> ' <<field camel>> ', <<endfor>> ]; Hapify (short) const hiddenFields = [ <<@ F hd f >> ' <<f aA>> ', <<@>> ]; EJS const hiddenFields = [ <% for ( let field of model . fields . filter ( f => f . hidden )) { -%> '<%= field.names.camel %>' , <% } -%> ]; JavaScript let output = '' ; const hiddenFieldsNames = model . fields . filter ( f => f . hidden ) . map ( f => `' ${ f . names . camel } '` ); output += `const hiddenFields = [ ${ hiddenFieldsNames . join ( \",\\n\\t\" ) } ];` ; return output ; Output const hiddenFields = [ 'password' , 'token' , ]; Create an array containing all possible values of an enumeration In a template of type one model , this block defines enumeration values as arrays (in constant case). Hapify (long) <<for Fields enum field >> const <<field camel>> Values = [ <<for field . enum e >> ' <<e constant>> ', <<endfor>> ]; <<endfor>> Hapify (short) <<@ F tU f >> const <<f aA>> Values = [ <<@ f . e e >> ' <<e A_A>> ', <<@>> ]; <<@>> EJS <% for ( let field of model . fields . filter ( f => f . type === 'enum' )) { -%> const <%= field . names . camel %> Values = [ <% for ( let e of field . enum ) { -%> '<%= e.names.constant %>' , <% } -%> ]; <% } -%> JavaScript let output = '' ; for ( let field of model . fields . filter ( f => f . type === 'enum' )) { const enums = field . enum . map ( e => `' ${ e . names . constant } '` ); output += `const ${ field . names . camel } Values = [ ${ enums . join ( ',\\n\\t' ) } ];` ; } return output ; Output const roleValues = [ 'ADMIN' , 'USER' , 'CUSTOMER' , ]; const statusValues = [ 'BUSY' , 'AVAILABLE' , 'OUT_OF_OFFICE' , ]; Create an index file of all models In a template of type all models , this will call the files of all models. Hapify (long) <<for Models model >> require_once('./ <<model kebab>> .php'); <<endfor>> Hapify (short) <<@ M m >> require_once('./ <<m a-a>> .php'); <<@>> EJS <% for ( let model of models ) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models ) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Output require_once('./user.php'); require_once('./place.php'); require_once('./service.php'); require_once('./place-category.php'); Create an index file with models accessible only by administrators If you want to limit the previous loop for models that contain only admin operations : Hapify (long) <<for Models onlyAdmin model >> require_once('./ <<model kebab>> .php'); <<endfor>> Hapify (short) <<@ M pOAd m >> require_once('./ <<m a-a>> .php'); <<@>> EJS <% for ( let model of models . filter ( m => m . accesses . properties . onlyAdmin )) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models . filter ( m => m . accesses . properties . onlyAdmin )) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Output require_once('./menu.php'); require_once('./menu-part.php'); require_once('./menu-item.php'); require_once('./order.php'); Set default value based on data type In a template of type one model , this block assigns a value to the field based on its type for all internal fields. If the type of the field is boolean , it assigns the value false , if the type is string , it assigns the value '' , if the type is number , it assigns the value 0 , otherwise it assigns the value NULL . This template generates PHP. Hapify (long) <<for Fields internal field >> <<if field boolean >> $default <<field pascal>> = false; <<elseif field string >> $default <<field pascal>> = ''; <<elseif field number >> $default <<field pascal>> = 0; <<else>> $default <<field pascal>> = NULL; <<endif>> <<endfor>> Hapify (short) <<@ F in f >> <<? f tB >> $default <<f AA>> = false; <<?? f tS >> $default <<f AA>> = ''; <<?? f tN >> $default <<f AA>> = 0; <<??>> $default <<f AA>> = NULL; <<?>> <<@>> EJS <% for ( let field of model . fields . filter ( f => f . internal )) { -%> <% if ( field . type === 'boolean' ) { -%> $default <%= field . names . pascal %> = false ; <% } else if ( field . type === 'string' ) { -%> $default <%= field . names . pascal %> = '' ; <% } else if ( field . type === 'number' ) { -%> $default <%= field . names . pascal %> = 0 ; <% } else { -%> $default <%= field . names . pascal %> = NULL ; <% } -%> <% } -%> JavaScript let output = '' ; for ( let field of model . fields . filter ( f => f . internal )) { output += `$default ${ field . names . pascal } = ${ getDefaultValue ( field ) } ; \\ n` } return output ; function getDefaultValue ( field ) { switch ( field . type ) { case 'boolean' : return 'false' ; case 'string' : return \"''\" ; case 'number' : return '0' ; default : return 'NULL' ; } } Output $defaultId = ''; $defaultCreatedAt = NULL; $defaultStock = 0; Import all dependencies In a template of type one model , this block imports other data models linked by fields of type entity. If the data model has a self-dependency, it will not be included in the loop. Hapify (long) <<for Dependencies dep >> import { <<dep pascal>> } from '../ <<dep kebab>> '; <<endfor>> Hapify (short) <<@ D d >> import { <<d AA>> } from '../ <<d a-a>> '; <<@>> EJS <% for ( let dep of model . dependencies . list ) { -%> import { <%= dep . names . pascal %> } from '../<%= dep.names.kebab %>' ; <% } -%> JavaScript let output = '' ; for ( let dep of model . dependencies . list ) { output += `import { ${ dep . names . pascal } } from '../ ${ dep . names . kebab } '; \\ n` ; } return output ; Output import { Restaurant } from '../restaurant' ; import { User } from '../user' ; import { MenuPart } from '../menu-part' ; import { MenuItem } from '../menu-item' ; You can also filter by referent field attributes. This block excludes data models with hidden referent fields: Hapify (long) <<for Dependencies not hidden dep >> import { <<dep pascal>> } from '../ <<dep kebab>> '; <<endfor>> Hapify (short) <<@ D !hd d >> import { <<d AA>> } from '../ <<d a-a>> '; <<@>> EJS <% for ( let dep of model . dependencies . filter ( f => ! f . hidden )) { -%> import { <%= dep . names . pascal %> } from '../<%= dep.names.kebab %>' ; <% } -%> JavaScript let output = '' ; for ( let dep of model . dependencies . filter ( f => ! f . hidden )) { output += `import { ${ dep . names . pascal } } from '../ ${ dep . names . kebab } '; \\ n` ; } return output ; Output import { PlaceCategory } from '../place-category' ; import { Service } from '../service' ; import { User } from '../user' ; Cascading deletion In a template of type one model , this block enumerates all data models that refer to the current data model and deletes them. The first iteration loops over all the data models that have a dependency on it. The second iteration loops over all the entity relations contained in these dependent data models. Note The ReferencedIn array contains all data models that refer to the current data model through entity type fields. Only entity fields that are referencing are defined in these referencing data models. Therefore, if you loop over the fields in the referring data models, you will not be confused by other fields. Hapify (long) <<for ReferencedIn referrer >> <<for referrer . fields field >> await db.collection(' <<referrer pascal>> ').deleteMany({ <<field snake>> : id }); <<endfor>> <<endfor>> Hapify (short) <<@ R m >> <<@ m . f f >> await db.collection(' <<m AA>> ').deleteMany({ <<f a_a>> : id }); <<@>> <<@>> EJS <% for ( let referrer of model . referencedIn ) { -%> <% for ( let field of referrer . fields ) { -%> await db . collection ( '<%= referrer.names.pascal %>' ). deleteMany ({ <%= field . names . snake %>: id }); <% } -%> <% } -%> JavaScript let output = '' ; for ( let referrer of model . referencedIn ) { for ( let field of referrer . fields ) { output += `await db.collection(' ${ referrer . names . pascal } ').deleteMany({ ${ field . names . snake } : id }); \\ n` ; } } return output ; Output await db . collection ( 'Place' ). deleteMany ({ owner : id }); await db . collection ( 'Bookmark' ). deleteMany ({ owner : id }); await db . collection ( 'Message' ). deleteMany ({ sender : id }); await db . collection ( 'Message' ). deleteMany ({ recipient : id }); await db . collection ( 'Conversation' ). deleteMany ({ participants : id }); await db . collection ( 'Conversation' ). deleteMany ({ closed_by : id }); await db . collection ( 'ConversationReport' ). deleteMany ({ complainant : id }); await db . collection ( 'ConversationReport' ). deleteMany ({ defendant : id }); Notes It is possible to add notes to a field or a model. Here is how to find them in the templates: Hapify (long) <<if Model hasNotes >> // <<! Model >> <<endif >> export class <<Model pascal>> { <<for Fields field >> public <<field camel>> ; <<if field hasNotes >> // <<! field >> <<endif >> <<endfor>> } Hapify (short) <<? M hN >> // <<! M >> <<? >> export class <<M AA>> { <<@ F f >> public <<f aA>> ; <<? f hN >> // <<! f >> <<? >> <<@>> } EJS <% if ( model . hasNotes ) { %> // <%= model.notes %><% } %> export class <%= model . names . pascal %> { <% for ( const field of model . fields . list ) { -%> public <%= field . names . camel %> ; <% if ( field . hasNotes ) { %> // <%= field.notes %><% } %> <% } %> } JavaScript let output = '' ; if ( model . hasNotes ) { output += `// ${ model . notes } \\ n` ; } output += `export class ${ model . names . pascal } { ${ getFields () } }` ; function getFields () { let fields = '' ; for ( const field of model . fields . list ) { fields += ` public ${ field . names . camel } ;` ; if ( field . hasNotes ) { fields += ` // ${ field . notes } ` ; } fields += ` \\ n` ; } return fields ; } return output ; Output // A user can only list its own bookmarks export class Bookmark { public id ; public owner ; // Current user when creating the bookmark public place ; } Tip With the Hapify syntax it is also possible to display notes using interpolation: <<= root.notes >> or <<= model.notes >> for a model or <<= field.notes >> for a field. Exclusion of generated files It is possible to exclude some files from the generation. If the template returns an empty string or a string containing only spaces, then no file will be generated for this template/data model pair.","title":"Step 4: Write the templates"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#introduction","text":"This section presents typical use cases for templates. Each code example is provided with the following template engines: Hapify (long and short syntaxes) EJS JavaScript For full details of the Hapify syntax, please refer to this article . To learn about the EJS syntax, please refer to the official documentation . Warning All EJS features are available, except the include feature. This feature is intentionally disabled so that templates do not have access to your file system.","title":"Introduction"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#data-model-manipulation","text":"Templates receive as input the model object . This object, injected in the templates, describes the data model and all its properties and relations, so that they are easily accessible from the template. We recommend that you understand its structure before you start writing templates.","title":"Data model manipulation"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#code-examples","text":"","title":"Code examples"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#names","text":"","title":"Names"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#create-a-class-for-the-current-data-model","text":"This block creates a class for the data model (in pascal case) and defines the primary key name, in snake case. Hapify (long) class <<Model pascal>> { private primaryKey = ' <<PrimaryField snake>> '; } Hapify (short) class <<M AA>> { private primaryKey = ' <<P a_a>> '; } EJS class <%= model . names . pascal %> { private primaryKey = '<%= model.fields.primary.names.snake %>' ; } JavaScript return `class ${ model . names . pascal } { private primaryKey = ' ${ model . fields . primary . names . snake } '; }` ; Output class Place { private primaryKey = '_id' ; }","title":"Create a class for the current data model"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#conditions","text":"","title":"Conditions"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#include-dependencies-based-on-field-attributes","text":"In a template of type one model , this block imports the MongoDB driver if the data model has a relationship with another. Hapify (long) <<if Fields entity >> const mongoDb = require('mongodb'); <<endif>> Hapify (short) <<? F tE >> const mongoDb = require('mongodb'); <<?>> EJS <% if ( model . fields . filter ( f => f . type === 'entity' ). length > 0 ) { -%> const mongoDb = require ( 'mongodb' ); <% } -%> JavaScript let output = '' ; if ( model . fields . filter ( f => f . type === 'entity' ). length > 0 ) { output += `const mongoDb = require('mongodb');` } return output ; Output const mongoDb = require ( 'mongodb' );","title":"Include dependencies based on field attributes"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#validate-the-session-if-the-operation-requires-authentication","text":"In a template of type one model , if the create action requires at most one authenticated user, this block retrieves the logged in user. Reminder guest is the most permissive access and admin the least permissive. Therefore admin < owner < authenticated < guest . Hapify (long) <<if CreateAccess lteAuth >> const user = Session.getCurrent(); <<endif>> Hapify (short) <<? Ac au] >> const user = Session.getCurrent(); <<?>> EJS <% if ( model . accesses . create . lteAuth ) { -%> const user = Session . getCurrent (); <% } -%> JavaScript let output = '' ; if ( model . accesses . create . lteAuth ) { output += `const user = Session.getCurrent();` } return output ; Output const user = Session . getCurrent ();","title":"Validate the session if the operation requires authentication"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#test-if-the-data-model-is-geolocated","text":"In a template of type one model , if the data model has the property isGeolocated (i.e. if the data model contains at least one latitude field and one longitude field) this block imports the map position selection component. Hapify (long) <<if Model isGeolocated >> <app-map-position-picker [model]=\" <<Model camel>> \"></app-map-position-picker> <<endif>> Hapify (short) <<? M pGeo >> <app-map-position-picker [model]=\" <<M aA>> \"></app-map-position-picker> <<?>> EJS <% if ( model . properties . isGeolocated ) { -%> < app - map - position - picker [ model ] = \"<%= model.names.camel %>\" >< /app-map-position-picker> <% } -%> JavaScript let output = '' ; if ( model . properties . isGeolocated ) { output += `<app-map-position-picker [model]=\" ${ model . names . camel } \"></app-map-position-picker>` } return output ; Output < app-map-position-picker [ model ]=\" place \" ></ app-map-position-picker >","title":"Test if the data model is geolocated"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#getting-relationships-based-on-cardinality","text":"This example creates a method that retrieves entities from a store, depending on the type of relationship: one-to-one , one-to-many or many-to-many . Hapify (long) class <<Model pascal>> extends BaseModel { <<for Fields entity field >> get <<field pascal>> () { <<if field oneOne or oneMany >> return this. <<field.model camel>> Store.findOne(this.properties. <<field camel>> ); <<elseif field manyMany >> return this. <<field.model camel>> Store.findMany(this.properties. <<field camel>> ); <<endif>> } <<endfor>> } Hapify (short) class <<M AA>> extends BaseModel { <<@ F tE f >> get <<f AA>> () { <<? f tEoo + tEom >> return this. <<f.m aA>> Store.findOne(this.properties. <<f aA>> ); <<?? f tEmm >> return this. <<f.m aA>> Store.findMany(this.properties. <<f aA>> ); <<?>> } <<@>> } EJS class <%= model . names . pascal %> extends BaseModel { <% for ( let field of model . fields . filter ( f => f . type === 'entity' )) { -%> get <%= field . names . pascal %> () { <% if ( field . subtype === 'oneOne' || field . subtype === 'oneMany' ) { -%> return this . <%= field . model . names . camel %> Store . findOne ( this . properties . <%= field . names . camel %> ); <% } else if ( field . subtype === 'manyMany' ) { -%> return this . <%= field . model . names . camel %> Store . findMany ( this . properties . <%= field . names . camel %> ); <% } -%> } <% } -%> } JavaScript let output = '' ; output += `class ${ model . names . pascal } extends BaseModel { ${ getRelations () } }` ; function getRelations () { return model . fields . filter ( f => f . type === 'entity' ). reduce (( acc , field ) => { return acc + getRelation ( field ) + '\\n\\t' ; }, '' ); } function getRelation ( field ) { let method = '' ; if ( field . subtype === 'oneOne' || field . subtype === 'oneMany' ) { method = 'findOne' ; } else if ( field . subtype === 'manyMany' ) { method = 'findMany' ; } else { return '' ; } return `get ${ field . names . pascal } () { return this. ${ field . model . names . camel } Store. ${ method } (this.properties. ${ field . names . camel } ); }` ; } return output ; Output class User extends BaseModel { getAvatar() { return this . avatarStore . findOne ( this . properties . avatar ); } getBookmarks() { return this . placeStore . findMany ( this . properties . bookmarks ); } }","title":"Getting relationships based on cardinality"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#iterations","text":"","title":"Iterations"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#fill-an-array-with-all-hidden-field-names","text":"In a template of type one model , this block creates an array (in JavaScript) that contains the names of hidden fields (in camel case). Hapify (long) const hiddenFields = [ <<for Fields hidden field >> ' <<field camel>> ', <<endfor>> ]; Hapify (short) const hiddenFields = [ <<@ F hd f >> ' <<f aA>> ', <<@>> ]; EJS const hiddenFields = [ <% for ( let field of model . fields . filter ( f => f . hidden )) { -%> '<%= field.names.camel %>' , <% } -%> ]; JavaScript let output = '' ; const hiddenFieldsNames = model . fields . filter ( f => f . hidden ) . map ( f => `' ${ f . names . camel } '` ); output += `const hiddenFields = [ ${ hiddenFieldsNames . join ( \",\\n\\t\" ) } ];` ; return output ; Output const hiddenFields = [ 'password' , 'token' , ];","title":"Fill an array with all hidden field names"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#create-an-array-containing-all-possible-values-of-an-enumeration","text":"In a template of type one model , this block defines enumeration values as arrays (in constant case). Hapify (long) <<for Fields enum field >> const <<field camel>> Values = [ <<for field . enum e >> ' <<e constant>> ', <<endfor>> ]; <<endfor>> Hapify (short) <<@ F tU f >> const <<f aA>> Values = [ <<@ f . e e >> ' <<e A_A>> ', <<@>> ]; <<@>> EJS <% for ( let field of model . fields . filter ( f => f . type === 'enum' )) { -%> const <%= field . names . camel %> Values = [ <% for ( let e of field . enum ) { -%> '<%= e.names.constant %>' , <% } -%> ]; <% } -%> JavaScript let output = '' ; for ( let field of model . fields . filter ( f => f . type === 'enum' )) { const enums = field . enum . map ( e => `' ${ e . names . constant } '` ); output += `const ${ field . names . camel } Values = [ ${ enums . join ( ',\\n\\t' ) } ];` ; } return output ; Output const roleValues = [ 'ADMIN' , 'USER' , 'CUSTOMER' , ]; const statusValues = [ 'BUSY' , 'AVAILABLE' , 'OUT_OF_OFFICE' , ];","title":"Create an array containing all possible values of an enumeration"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#create-an-index-file-of-all-models","text":"In a template of type all models , this will call the files of all models. Hapify (long) <<for Models model >> require_once('./ <<model kebab>> .php'); <<endfor>> Hapify (short) <<@ M m >> require_once('./ <<m a-a>> .php'); <<@>> EJS <% for ( let model of models ) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models ) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Output require_once('./user.php'); require_once('./place.php'); require_once('./service.php'); require_once('./place-category.php');","title":"Create an index file of all models"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#create-an-index-file-with-models-accessible-only-by-administrators","text":"If you want to limit the previous loop for models that contain only admin operations : Hapify (long) <<for Models onlyAdmin model >> require_once('./ <<model kebab>> .php'); <<endfor>> Hapify (short) <<@ M pOAd m >> require_once('./ <<m a-a>> .php'); <<@>> EJS <% for ( let model of models . filter ( m => m . accesses . properties . onlyAdmin )) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models . filter ( m => m . accesses . properties . onlyAdmin )) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Output require_once('./menu.php'); require_once('./menu-part.php'); require_once('./menu-item.php'); require_once('./order.php');","title":"Create an index file with models accessible only by administrators"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#set-default-value-based-on-data-type","text":"In a template of type one model , this block assigns a value to the field based on its type for all internal fields. If the type of the field is boolean , it assigns the value false , if the type is string , it assigns the value '' , if the type is number , it assigns the value 0 , otherwise it assigns the value NULL . This template generates PHP. Hapify (long) <<for Fields internal field >> <<if field boolean >> $default <<field pascal>> = false; <<elseif field string >> $default <<field pascal>> = ''; <<elseif field number >> $default <<field pascal>> = 0; <<else>> $default <<field pascal>> = NULL; <<endif>> <<endfor>> Hapify (short) <<@ F in f >> <<? f tB >> $default <<f AA>> = false; <<?? f tS >> $default <<f AA>> = ''; <<?? f tN >> $default <<f AA>> = 0; <<??>> $default <<f AA>> = NULL; <<?>> <<@>> EJS <% for ( let field of model . fields . filter ( f => f . internal )) { -%> <% if ( field . type === 'boolean' ) { -%> $default <%= field . names . pascal %> = false ; <% } else if ( field . type === 'string' ) { -%> $default <%= field . names . pascal %> = '' ; <% } else if ( field . type === 'number' ) { -%> $default <%= field . names . pascal %> = 0 ; <% } else { -%> $default <%= field . names . pascal %> = NULL ; <% } -%> <% } -%> JavaScript let output = '' ; for ( let field of model . fields . filter ( f => f . internal )) { output += `$default ${ field . names . pascal } = ${ getDefaultValue ( field ) } ; \\ n` } return output ; function getDefaultValue ( field ) { switch ( field . type ) { case 'boolean' : return 'false' ; case 'string' : return \"''\" ; case 'number' : return '0' ; default : return 'NULL' ; } } Output $defaultId = ''; $defaultCreatedAt = NULL; $defaultStock = 0;","title":"Set default value based on data type"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#import-all-dependencies","text":"In a template of type one model , this block imports other data models linked by fields of type entity. If the data model has a self-dependency, it will not be included in the loop. Hapify (long) <<for Dependencies dep >> import { <<dep pascal>> } from '../ <<dep kebab>> '; <<endfor>> Hapify (short) <<@ D d >> import { <<d AA>> } from '../ <<d a-a>> '; <<@>> EJS <% for ( let dep of model . dependencies . list ) { -%> import { <%= dep . names . pascal %> } from '../<%= dep.names.kebab %>' ; <% } -%> JavaScript let output = '' ; for ( let dep of model . dependencies . list ) { output += `import { ${ dep . names . pascal } } from '../ ${ dep . names . kebab } '; \\ n` ; } return output ; Output import { Restaurant } from '../restaurant' ; import { User } from '../user' ; import { MenuPart } from '../menu-part' ; import { MenuItem } from '../menu-item' ; You can also filter by referent field attributes. This block excludes data models with hidden referent fields: Hapify (long) <<for Dependencies not hidden dep >> import { <<dep pascal>> } from '../ <<dep kebab>> '; <<endfor>> Hapify (short) <<@ D !hd d >> import { <<d AA>> } from '../ <<d a-a>> '; <<@>> EJS <% for ( let dep of model . dependencies . filter ( f => ! f . hidden )) { -%> import { <%= dep . names . pascal %> } from '../<%= dep.names.kebab %>' ; <% } -%> JavaScript let output = '' ; for ( let dep of model . dependencies . filter ( f => ! f . hidden )) { output += `import { ${ dep . names . pascal } } from '../ ${ dep . names . kebab } '; \\ n` ; } return output ; Output import { PlaceCategory } from '../place-category' ; import { Service } from '../service' ; import { User } from '../user' ;","title":"Import all dependencies"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#cascading-deletion","text":"In a template of type one model , this block enumerates all data models that refer to the current data model and deletes them. The first iteration loops over all the data models that have a dependency on it. The second iteration loops over all the entity relations contained in these dependent data models. Note The ReferencedIn array contains all data models that refer to the current data model through entity type fields. Only entity fields that are referencing are defined in these referencing data models. Therefore, if you loop over the fields in the referring data models, you will not be confused by other fields. Hapify (long) <<for ReferencedIn referrer >> <<for referrer . fields field >> await db.collection(' <<referrer pascal>> ').deleteMany({ <<field snake>> : id }); <<endfor>> <<endfor>> Hapify (short) <<@ R m >> <<@ m . f f >> await db.collection(' <<m AA>> ').deleteMany({ <<f a_a>> : id }); <<@>> <<@>> EJS <% for ( let referrer of model . referencedIn ) { -%> <% for ( let field of referrer . fields ) { -%> await db . collection ( '<%= referrer.names.pascal %>' ). deleteMany ({ <%= field . names . snake %>: id }); <% } -%> <% } -%> JavaScript let output = '' ; for ( let referrer of model . referencedIn ) { for ( let field of referrer . fields ) { output += `await db.collection(' ${ referrer . names . pascal } ').deleteMany({ ${ field . names . snake } : id }); \\ n` ; } } return output ; Output await db . collection ( 'Place' ). deleteMany ({ owner : id }); await db . collection ( 'Bookmark' ). deleteMany ({ owner : id }); await db . collection ( 'Message' ). deleteMany ({ sender : id }); await db . collection ( 'Message' ). deleteMany ({ recipient : id }); await db . collection ( 'Conversation' ). deleteMany ({ participants : id }); await db . collection ( 'Conversation' ). deleteMany ({ closed_by : id }); await db . collection ( 'ConversationReport' ). deleteMany ({ complainant : id }); await db . collection ( 'ConversationReport' ). deleteMany ({ defendant : id });","title":"Cascading deletion"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#notes","text":"It is possible to add notes to a field or a model. Here is how to find them in the templates: Hapify (long) <<if Model hasNotes >> // <<! Model >> <<endif >> export class <<Model pascal>> { <<for Fields field >> public <<field camel>> ; <<if field hasNotes >> // <<! field >> <<endif >> <<endfor>> } Hapify (short) <<? M hN >> // <<! M >> <<? >> export class <<M AA>> { <<@ F f >> public <<f aA>> ; <<? f hN >> // <<! f >> <<? >> <<@>> } EJS <% if ( model . hasNotes ) { %> // <%= model.notes %><% } %> export class <%= model . names . pascal %> { <% for ( const field of model . fields . list ) { -%> public <%= field . names . camel %> ; <% if ( field . hasNotes ) { %> // <%= field.notes %><% } %> <% } %> } JavaScript let output = '' ; if ( model . hasNotes ) { output += `// ${ model . notes } \\ n` ; } output += `export class ${ model . names . pascal } { ${ getFields () } }` ; function getFields () { let fields = '' ; for ( const field of model . fields . list ) { fields += ` public ${ field . names . camel } ;` ; if ( field . hasNotes ) { fields += ` // ${ field . notes } ` ; } fields += ` \\ n` ; } return fields ; } return output ; Output // A user can only list its own bookmarks export class Bookmark { public id ; public owner ; // Current user when creating the bookmark public place ; } Tip With the Hapify syntax it is also possible to display notes using interpolation: <<= root.notes >> or <<= model.notes >> for a model or <<= field.notes >> for a field.","title":"Notes"},{"location":"getting-started/create-boilerplate/step-4-template-writing/#exclusion-of-generated-files","text":"It is possible to exclude some files from the generation. If the template returns an empty string or a string containing only spaces, then no file will be generated for this template/data model pair.","title":"Exclusion of generated files"},{"location":"getting-started/create-boilerplate/step-5-models-validator/","text":"Your templates cannot handle any combination of fields and attributes. To prevent this, you can associate a data model validator to your templates. How does it work? This validator is written in pure JavaScript. It receives a single data model and returns warnings and errors . These warnings and errors will be displayed during data model management: Warnings Errors Write a validator When validating the data model, the JavaScript code is wrapped into a function. Therefore, the code you are writing is the body of that function. Your code must return an object like this: return { errors : [ 'Model has no primary key' ], warnings : [] } Accessing the data model properties In the validator script, the data model is available under the model variable. The model variable is structured like this: { \"id\" : \"bdc6c58e-ec49-9193-6b29-6c75518bc3ad\" , \"name\" : \"Bookmark\" , \"notes\" : \"A user can only list its own bookmarks\" , \"fields\" : [ { \"name\" : \"_id\" , \"notes\" : null , \"type\" : \"string\" , \"subtype\" : null , \"value\" : null , \"primary\" : true , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false } ], \"accesses\" : { \"create\" : \"auth\" , \"read\" : \"owner\" , \"update\" : \"admin\" , \"remove\" : \"owner\" , \"search\" : \"owner\" , \"count\" : \"owner\" } } Unlike the JavaScript template engine, the data model properties are not pre-computed and you do not have access to the data model dependencies. Example of validator Here is an example of a validator that sends a warning for an unsupported field type, and an error if the primary key is not compliant. // Model object is injected as \"model\" const errors = []; const warnings = []; // ----------------------------- // File fields if ( model . fields . filter (( f ) => f . type === 'file' ). length ) { errors . push ( 'File fields are not supported yet by this boilerplate' ); } // URL fields if ( model . fields . filter (( f ) => f . type === 'string' && f . subtype === 'url' ). length ) { warnings . push ( 'URL string is not supported yet and will be handle as default string' ); } // ----------------------------- // Primary key const primaries = model . fields . filter (( f ) => f . primary ); if ( primaries . length > 1 ) { errors . push ( 'Only one field can be primary' ); } const primary = primaries [ 0 ]; if ( primary ) { if ( primary . name !== '_id' ) { errors . push ( 'Primary key must be called \"_id\"' ); } if ( primary . type !== 'string' ) { errors . push ( 'Primary key must be a string' ); } if ( ! primary . internal ) { errors . push ( 'Primary key must be a internal' ); } } else { errors . push ( 'Primary key is required' ); } return { errors , warnings , };","title":"Step 5: Data Model Validator"},{"location":"getting-started/create-boilerplate/step-5-models-validator/#how-does-it-work","text":"This validator is written in pure JavaScript. It receives a single data model and returns warnings and errors . These warnings and errors will be displayed during data model management: Warnings Errors","title":"How does it work?"},{"location":"getting-started/create-boilerplate/step-5-models-validator/#write-a-validator","text":"When validating the data model, the JavaScript code is wrapped into a function. Therefore, the code you are writing is the body of that function. Your code must return an object like this: return { errors : [ 'Model has no primary key' ], warnings : [] }","title":"Write a validator"},{"location":"getting-started/create-boilerplate/step-5-models-validator/#accessing-the-data-model-properties","text":"In the validator script, the data model is available under the model variable. The model variable is structured like this: { \"id\" : \"bdc6c58e-ec49-9193-6b29-6c75518bc3ad\" , \"name\" : \"Bookmark\" , \"notes\" : \"A user can only list its own bookmarks\" , \"fields\" : [ { \"name\" : \"_id\" , \"notes\" : null , \"type\" : \"string\" , \"subtype\" : null , \"value\" : null , \"primary\" : true , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false } ], \"accesses\" : { \"create\" : \"auth\" , \"read\" : \"owner\" , \"update\" : \"admin\" , \"remove\" : \"owner\" , \"search\" : \"owner\" , \"count\" : \"owner\" } } Unlike the JavaScript template engine, the data model properties are not pre-computed and you do not have access to the data model dependencies.","title":"Accessing the data model properties"},{"location":"getting-started/create-boilerplate/step-5-models-validator/#example-of-validator","text":"Here is an example of a validator that sends a warning for an unsupported field type, and an error if the primary key is not compliant. // Model object is injected as \"model\" const errors = []; const warnings = []; // ----------------------------- // File fields if ( model . fields . filter (( f ) => f . type === 'file' ). length ) { errors . push ( 'File fields are not supported yet by this boilerplate' ); } // URL fields if ( model . fields . filter (( f ) => f . type === 'string' && f . subtype === 'url' ). length ) { warnings . push ( 'URL string is not supported yet and will be handle as default string' ); } // ----------------------------- // Primary key const primaries = model . fields . filter (( f ) => f . primary ); if ( primaries . length > 1 ) { errors . push ( 'Only one field can be primary' ); } const primary = primaries [ 0 ]; if ( primary ) { if ( primary . name !== '_id' ) { errors . push ( 'Primary key must be called \"_id\"' ); } if ( primary . type !== 'string' ) { errors . push ( 'Primary key must be a string' ); } if ( ! primary . internal ) { errors . push ( 'Primary key must be a internal' ); } } else { errors . push ( 'Primary key is required' ); } return { errors , warnings , };","title":"Example of validator"},{"location":"getting-started/existing-boilerplate/introduction/","text":"Summary In this section, you will learn how to start a project from an existing boilerplate and how to generate code from your data models. If you want to create code templates for your boilerplate, please refer to this tutorial . We assume that you have already installed the CLI before reading this tutorial. If not, please refer to the installation guide . Quick tutorial overview Let's generate !","title":"Introduction"},{"location":"getting-started/existing-boilerplate/introduction/#summary","text":"In this section, you will learn how to start a project from an existing boilerplate and how to generate code from your data models. If you want to create code templates for your boilerplate, please refer to this tutorial . We assume that you have already installed the CLI before reading this tutorial. If not, please refer to the installation guide .","title":"Summary"},{"location":"getting-started/existing-boilerplate/introduction/#quick-tutorial-overview","text":"Let's generate !","title":"Quick tutorial overview"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/","text":"Run the new command Create a new folder for your project and go to that folder: mkdir my-project && cd my-project Use the new command to clone a boilerplate and initialize your project: hpf new Choose one or more boilerplates Once you have selected a project, you can choose a public boilerplate (available on the Hapify Hub ) or enter a custom git URL. ? Choose a boilerplate Enter a Git URL \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u276f HapiJS Backend NG-ZORRO Components NG-ZORRO Dashboard PHP Slim Backend You can add another boilerplate: ? Choose a project New one ? Choose a boilerplate HapiJS ? Add another boilerplate? (y/N) For example, if you choose a back-end boilerplate, you can add one or more front-end boilerplates. If you only need one boilerplate or if you choose a full-stack boilerplate, just select No . Using a boilerplate from a git repository If you want to use a boilerplate that is not listed, choose the Enter a Git URL option and then type or paste the URL : ? Choose a boilerplate Enter a Git URL ? Enter boilerplate Git URL https://github.com/someone/somerepo.git You must enter a URL compatible with git clone . Importing predefined data models You can import collections of predefined data models ( presets ) from Hapify Cloud. To do so, select one or more presets when prompted: ? Choose some presets to preload in your project \u25c9 User \u25ef Listing \u25ef Messaging \u276f\u25c9 Food delivery \u25ef Shopping cart & wishlist Enter name and description ? Enter a project name Food delivery ? Enter a project description A food delivery app Output After a few seconds, the boilerplate will be cloned into your current folder: \u2713 Created 2 new dynamic boilerplates in ~/my-project. Run hpf use to connect a remote project (optional). Run hpf serve to edit models and templates. Run hpf generate to generate the source code. The folder structure looks like this: ~/my-project \u251c\u2500\u2500 boilerplate-hapijs | \u251c\u2500\u2500 .hapify | | \u251c\u2500\u2500 routes | | \u2514\u2500\u2500 validator.js | \u251c\u2500\u2500 Dockerfile | \u251c\u2500\u2500 hapify-models.json | \u251c\u2500\u2500 hapify.json | \u2514\u2500\u2500 ... \u2514\u2500\u2500 boilerplate-ngx-dashboard \u251c\u2500\u2500 .hapify | \u251c\u2500\u2500 src | \u2514\u2500\u2500 validator.js \u251c\u2500\u2500 src | \u251c\u2500\u2500 app | \u251c\u2500\u2500 assets | \u251c\u2500\u2500 index.html | \u2514\u2500\u2500 ... \u251c\u2500\u2500 hapify.json \u2514\u2500\u2500 ... hapify.json is the configuration file. It contains the boilerplate metadata and the list of templates. The hapify-models.json file contains the data models for your project. It is referenced by the configuration file ( hapify.json ). You can move or rename this file as long as you change the path in the configuration file. The .hapify folder (can also be named hapify ) is the templates folder. It contains all the templates for the boilerplate. Optional : Store your data models on Hapify Cloud By default, Hapify stores your data models locally. The path is defined in the configuration file. You can store your data models online, so you can share them across multiple repositories. To connect the CLI to Hapify Cloud, please follow these steps . Connect your boilerplate to a remote project Run this command to configure your boilerplate: hpf use Create a project You can create a project directly from the CLI by selecting Create a new project . Enter the name and description when prompted. ? Choose a project Create a new project ? Enter a project name First project ? Enter a project description My first project with Hapify Select an existing project From the list below, select a project from your account. ? Choose a project (Use arrow keys) Create a new project \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u276f First project Second project Tip You can create a project online from your Hapify account: https://www.hapify.io/my-projects The boilerplate will now store and read the models from Hapify Cloud. ? Choose a project First project \u2713 Did set project 5c893c0a74e4650010e6f683 for channel HapiJS \u2713 Did set project 5c893c0a74e4650010e6f683 for channel Angular Dashboard The project ID is stored in the configuration file ( hapify.json ).","title":"Step 1: Clone a boilerplate"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#run-the-new-command","text":"Create a new folder for your project and go to that folder: mkdir my-project && cd my-project Use the new command to clone a boilerplate and initialize your project: hpf new","title":"Run the new command"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#choose-one-or-more-boilerplates","text":"Once you have selected a project, you can choose a public boilerplate (available on the Hapify Hub ) or enter a custom git URL. ? Choose a boilerplate Enter a Git URL \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u276f HapiJS Backend NG-ZORRO Components NG-ZORRO Dashboard PHP Slim Backend You can add another boilerplate: ? Choose a project New one ? Choose a boilerplate HapiJS ? Add another boilerplate? (y/N) For example, if you choose a back-end boilerplate, you can add one or more front-end boilerplates. If you only need one boilerplate or if you choose a full-stack boilerplate, just select No .","title":"Choose one or more boilerplates"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#using-a-boilerplate-from-a-git-repository","text":"If you want to use a boilerplate that is not listed, choose the Enter a Git URL option and then type or paste the URL : ? Choose a boilerplate Enter a Git URL ? Enter boilerplate Git URL https://github.com/someone/somerepo.git You must enter a URL compatible with git clone .","title":"Using a boilerplate from a git repository"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#importing-predefined-data-models","text":"You can import collections of predefined data models ( presets ) from Hapify Cloud. To do so, select one or more presets when prompted: ? Choose some presets to preload in your project \u25c9 User \u25ef Listing \u25ef Messaging \u276f\u25c9 Food delivery \u25ef Shopping cart & wishlist","title":"Importing predefined data models"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#enter-name-and-description","text":"? Enter a project name Food delivery ? Enter a project description A food delivery app","title":"Enter name and description"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#output","text":"After a few seconds, the boilerplate will be cloned into your current folder: \u2713 Created 2 new dynamic boilerplates in ~/my-project. Run hpf use to connect a remote project (optional). Run hpf serve to edit models and templates. Run hpf generate to generate the source code. The folder structure looks like this: ~/my-project \u251c\u2500\u2500 boilerplate-hapijs | \u251c\u2500\u2500 .hapify | | \u251c\u2500\u2500 routes | | \u2514\u2500\u2500 validator.js | \u251c\u2500\u2500 Dockerfile | \u251c\u2500\u2500 hapify-models.json | \u251c\u2500\u2500 hapify.json | \u2514\u2500\u2500 ... \u2514\u2500\u2500 boilerplate-ngx-dashboard \u251c\u2500\u2500 .hapify | \u251c\u2500\u2500 src | \u2514\u2500\u2500 validator.js \u251c\u2500\u2500 src | \u251c\u2500\u2500 app | \u251c\u2500\u2500 assets | \u251c\u2500\u2500 index.html | \u2514\u2500\u2500 ... \u251c\u2500\u2500 hapify.json \u2514\u2500\u2500 ... hapify.json is the configuration file. It contains the boilerplate metadata and the list of templates. The hapify-models.json file contains the data models for your project. It is referenced by the configuration file ( hapify.json ). You can move or rename this file as long as you change the path in the configuration file. The .hapify folder (can also be named hapify ) is the templates folder. It contains all the templates for the boilerplate.","title":"Output"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#optional-store-your-data-models-on-hapify-cloud","text":"By default, Hapify stores your data models locally. The path is defined in the configuration file. You can store your data models online, so you can share them across multiple repositories. To connect the CLI to Hapify Cloud, please follow these steps .","title":"Optional: Store your data models on Hapify Cloud"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#connect-your-boilerplate-to-a-remote-project","text":"Run this command to configure your boilerplate: hpf use","title":"Connect your boilerplate to a remote project"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#create-a-project","text":"You can create a project directly from the CLI by selecting Create a new project . Enter the name and description when prompted. ? Choose a project Create a new project ? Enter a project name First project ? Enter a project description My first project with Hapify","title":"Create a project"},{"location":"getting-started/existing-boilerplate/step-1-clone-boilerplate/#select-an-existing-project","text":"From the list below, select a project from your account. ? Choose a project (Use arrow keys) Create a new project \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u276f First project Second project Tip You can create a project online from your Hapify account: https://www.hapify.io/my-projects The boilerplate will now store and read the models from Hapify Cloud. ? Choose a project First project \u2713 Did set project 5c893c0a74e4650010e6f683 for channel HapiJS \u2713 Did set project 5c893c0a74e4650010e6f683 for channel Angular Dashboard The project ID is stored in the configuration file ( hapify.json ).","title":"Select an existing project"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/","text":"Run the serve command. At this point, you have a boilerplate but no data models in your project, unless you have imported collections of predefined data models. In order to create and modify the data models in your project, run this command to launch the local GUI: hpf serve List of data models Once started, the GUI displays all the data models. Tip For projects with many data models, you can filter them by name, field name or reference. Use the top right bar. Press the escape key to reset these filters. Add and edit data models Click on the New model button, enter a name and press the \"Enter\" key. The new data model will be populated with the default fields. The default fields are defined in the boilerplate configuration file ( hapify.json ). Tip Once created, you can change the name of the data model by clicking on it. Importing predefined data models Click on the Import collections button, choose a collection ( preset ) and validate. The data models of the collection will be merged with the existing data models in case of conflict. Delete, clone and copy Click on the three dots to display this menu: Copy and paste When you copy a data model, it is added as JSON to your clipboard. To paste a data model, click Paste from clipboard at the end of the data model list. This is useful to transfer data models between multiple projects. Add and edit fields Click on Add field at the end of a data model and enter a name. You can choose its type and subtype: And also its attributes by clicking on the gear : Tip Once created, you can change the name of the field by clicking on it. See also To learn more about field management, please refer to the data model description . Delete a field Click on the \"trash\" icon and select the fields to be deleted: Edit data model accesses Expand the access management panel by clicking on the \"fingerprint\" icon at the top of a model: See also For more information about access management, please refer to the data model description . Add notes You can leave notes on the data models and their fields. Click on the \"speech\" icon and write a note. On a model: On a field: Errors and warnings A boilerplate can validate the data models you are writing. These errors or warnings will appear when editing the data models.","title":"Step 2: Edit the data models"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#run-the-serve-command","text":"At this point, you have a boilerplate but no data models in your project, unless you have imported collections of predefined data models. In order to create and modify the data models in your project, run this command to launch the local GUI: hpf serve","title":"Run the serve command."},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#list-of-data-models","text":"Once started, the GUI displays all the data models. Tip For projects with many data models, you can filter them by name, field name or reference. Use the top right bar. Press the escape key to reset these filters.","title":"List of data models"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#add-and-edit-data-models","text":"Click on the New model button, enter a name and press the \"Enter\" key. The new data model will be populated with the default fields. The default fields are defined in the boilerplate configuration file ( hapify.json ). Tip Once created, you can change the name of the data model by clicking on it.","title":"Add and edit data models"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#importing-predefined-data-models","text":"Click on the Import collections button, choose a collection ( preset ) and validate. The data models of the collection will be merged with the existing data models in case of conflict.","title":"Importing predefined data models"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#delete-clone-and-copy","text":"Click on the three dots to display this menu:","title":"Delete, clone and copy"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#copy-and-paste","text":"When you copy a data model, it is added as JSON to your clipboard. To paste a data model, click Paste from clipboard at the end of the data model list. This is useful to transfer data models between multiple projects.","title":"Copy and paste"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#add-and-edit-fields","text":"Click on Add field at the end of a data model and enter a name. You can choose its type and subtype: And also its attributes by clicking on the gear : Tip Once created, you can change the name of the field by clicking on it. See also To learn more about field management, please refer to the data model description .","title":"Add and edit fields"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#delete-a-field","text":"Click on the \"trash\" icon and select the fields to be deleted:","title":"Delete a field"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#edit-data-model-accesses","text":"Expand the access management panel by clicking on the \"fingerprint\" icon at the top of a model: See also For more information about access management, please refer to the data model description .","title":"Edit data model accesses"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#add-notes","text":"You can leave notes on the data models and their fields. Click on the \"speech\" icon and write a note. On a model: On a field:","title":"Add notes"},{"location":"getting-started/existing-boilerplate/step-2-edit-models/#errors-and-warnings","text":"A boilerplate can validate the data models you are writing. These errors or warnings will appear when editing the data models.","title":"Errors and warnings"},{"location":"getting-started/existing-boilerplate/step-3-generate/","text":"Run the generate command When your data models are ready, generate the code with this command : hpf generate This will launch the generator and copy the generated files to your boilerplate locally: \u2022 Found channel HapiJS in ~/my-project/boilerplate-hapijs \u2022 Found channel Angular Dashboard in ~/my-project/boilerplate-ngx-dashboard \u2713 Generated 60 files for channel HapiJS \u2713 Generated 189 files for channel Angular Dashboard You can now start customizing and using the generated code. Tip The generate command can handle multiple boilerplates or channels at once. To learn more about the generate command, please refer to this article . Format the code Hapify does not format the output code. This task is delegated to the boilerplate itself. We strongly recommend that you use the boilerplate's built-in linter, if available, or use the code formatter from your IDE.","title":"Step 3: Generate the code"},{"location":"getting-started/existing-boilerplate/step-3-generate/#run-the-generate-command","text":"When your data models are ready, generate the code with this command : hpf generate This will launch the generator and copy the generated files to your boilerplate locally: \u2022 Found channel HapiJS in ~/my-project/boilerplate-hapijs \u2022 Found channel Angular Dashboard in ~/my-project/boilerplate-ngx-dashboard \u2713 Generated 60 files for channel HapiJS \u2713 Generated 189 files for channel Angular Dashboard You can now start customizing and using the generated code. Tip The generate command can handle multiple boilerplates or channels at once. To learn more about the generate command, please refer to this article .","title":"Run the generate command"},{"location":"getting-started/existing-boilerplate/step-3-generate/#format-the-code","text":"Hapify does not format the output code. This task is delegated to the boilerplate itself. We strongly recommend that you use the boilerplate's built-in linter, if available, or use the code formatter from your IDE.","title":"Format the code"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/","text":"Hapify & Git patch Hapify allows you to regenerate the target code without overwriting any changes you may have made. This feature is based on the git format-patch and git am commands. This way you can use Hapify throughout your project, not just at startup. Preparing the repository To be able to use the command hpf patch properly, you must run the generation on a separate branch. For example, create a branch named hapify . First generation Go to this new hapify branch. Run your first generation using hpf generate . If you are using a code formatter, run it after each generation. Commit this. Let's call it Generation 1 . Merge the hapify branch into your working branch, let's say develop . Now you can start working on develop and customize the generated code. Second generation Oh no! You forgot something in your data models, the project specifications have changed, or you want to edit some lines in your templates. If you are using a code formatter, run it on your working branch ( develop for example). Switch to the hapify branch. Edit your data models and/or templates. Start the generation and run your code formatter (if any). Commit it. Let's call it Generation 2 . Apply the difference You can now run the hpf patch command to calculate the difference between the Generation 1 and Generation 2 commits and apply it to develop . $ hpf patch ? Choose a source branch hapify ? Choose the first commit [2018-10-19 17:56:40 -0400] Generation 1 ? Choose the second commit [2018-10-22 01:47:18 -0400] Generation 2 ? Choose a destination branch develop Before doing anything, it will display the git command that will be executed, and ask for confirmation. It should look like this: git format-patch --stdout e5d01ec559aa79b0af8f80839e22e15f3283c752..be93268f6d404c4c7c83c55a6dcb98f4930a0c1c | git am -3 -k If an error occurred during this git command, it is probably due to a merge conflict. If this is the case, open your code editor and resolve the conflict. Once that's done, run git am --continue to finalize or git am --abort to cancel the merge.","title":"Step 4: Life Cycle"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/#hapify-git-patch","text":"Hapify allows you to regenerate the target code without overwriting any changes you may have made. This feature is based on the git format-patch and git am commands. This way you can use Hapify throughout your project, not just at startup.","title":"Hapify &amp; Git patch"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/#preparing-the-repository","text":"To be able to use the command hpf patch properly, you must run the generation on a separate branch. For example, create a branch named hapify .","title":"Preparing the repository"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/#first-generation","text":"Go to this new hapify branch. Run your first generation using hpf generate . If you are using a code formatter, run it after each generation. Commit this. Let's call it Generation 1 . Merge the hapify branch into your working branch, let's say develop . Now you can start working on develop and customize the generated code.","title":"First generation"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/#second-generation","text":"Oh no! You forgot something in your data models, the project specifications have changed, or you want to edit some lines in your templates. If you are using a code formatter, run it on your working branch ( develop for example). Switch to the hapify branch. Edit your data models and/or templates. Start the generation and run your code formatter (if any). Commit it. Let's call it Generation 2 .","title":"Second generation"},{"location":"getting-started/existing-boilerplate/step-4-lifecycle/#apply-the-difference","text":"You can now run the hpf patch command to calculate the difference between the Generation 1 and Generation 2 commits and apply it to develop . $ hpf patch ? Choose a source branch hapify ? Choose the first commit [2018-10-19 17:56:40 -0400] Generation 1 ? Choose the second commit [2018-10-22 01:47:18 -0400] Generation 2 ? Choose a destination branch develop Before doing anything, it will display the git command that will be executed, and ask for confirmation. It should look like this: git format-patch --stdout e5d01ec559aa79b0af8f80839e22e15f3283c752..be93268f6d404c4c7c83c55a6dcb98f4930a0c1c | git am -3 -k If an error occurred during this git command, it is probably due to a merge conflict. If this is the case, open your code editor and resolve the conflict. Once that's done, run git am --continue to finalize or git am --abort to cancel the merge.","title":"Apply the difference"},{"location":"reference/cli/","text":"Description Hapify is a code generation tool based on relational data models. It uses a dedicated templating language. It displays a web console for managing models and writing templates. Usage Installation You must install this package globally to get the hpf command: npm install -g @hapify/cli To check the installed version, run hpf --version . Global options -V , --version : display the version number --debug : enable debug mode (default: false ) --silent : enable silent mode (default: false ) -d <path> , --dir <path> : changes the working directory. This path can be absolute or relative to the current path. -k <secret> , --key <secret> : forces the use of an API key rather than one defined in the global configuration. If you want to set your API key permanently, you should use the hpf key command. -h , --help : display the help Commands Define the global configuration hpf config [ options ] This command saves one or more global configurations in ~/.hapify/config.json . If the file does not exist, it will be automatically created. Available configuration hpf config --apiKey <secret> : sets the API key to use for each command. This is equivalent to hpf key <key> . hpf config --apiUrl <url> : overrides the default API URL. Define the global API key hpf key <key> This command is an alias for hpf config --apiKey <secret> . List the boilerplates (channels) hpf list Alias: hpf ls This command displays what is visible to the CLI from the current directory. It displays the list of channels and the list of data models used by those channels. The CLI searches for hapify.json files to automatically detect channels. It iterates on the subdirectories. The default depth is 2 . To change this value, use the depth option. hpf list --depth 3 Warning You are not supposed to run the CLI with different sets of data models. If you do, the first set found will be used. Generate the code hpf generate Alias: hpf g This command generates all the channels found from their templates and data models. To set the depth for searching channels, use this option: --depth <n> . The default value is 2 . hpf generate --depth 3 Tip Empty generated files will not be saved. Export the code hpf export Alias: hpf x This command generates a channel from its templates and data models and saves the generated files in a zip file. You need to run this command from the channel directory, next to the hapify.json file. By default, the zip file is named from the channel folder. Example: angular-admin/angular-admin.zip . You can define a custom path with this option: -o, --output <path> . hpf export -o /path/to/file.zip Tip Empty generated files will not be saved. Import data models hpf import Alias: hpf m Use this command to import predefined data models from Hapify Cloud (called presets ). Import presets from ID You can also import presets from their IDs (visible on Hapify Hub ) hpf import --preset ab123 --preset bd456 Clone a boilerplate and start a new project hpf new Alias: hpf n This command allows you to clone and configure a boilerplate. It will ask you to : select a boilerplate select or create the project to use select presets of data models to import Options -p <id> , --project <id> : The project to use (if it already exists) -b <slug> , --boilerplate <slug> : The slug of the boilerplate to clone --boilerplate-id <id> : The ID of the boilerplate to clone --boilerplate-url [url] : The git URLs of the boilerplates to clone --preset [id] : The ID of the presets to be preloaded into the project --no-presets : Do not request any presets --project-name <name> : The name of the project to create --project-desc <description> : The description of the project to create (the name must be defined) To view the available presets, visit hub.hapify.io . Create a new boilerplate/channel hpf init Alias: hpf i This command creates a new Hapify file structure in the current directory. It creates 2 files hapify.json , hapify-models.json and a folder .hapify containing a template models/__kebab__/hello.js.hpf . It will ask you to select or create a project. Options --channel-name <name> : The name of the channel to initialize --channel-desc <description> : The description of the channel to initialize --channel-logo <url> : The URL of the logo of the channel to initialize --project-name <name> : The name of the project to create --project-desc <description> : The description of the project to create Define the project to use in a boilerplate/channel hpf use Alias: hpf u Changes the project used by one or more existing channels . Changes the project ID in the hapify.json file for each channel found. It will ask you to select or create the project to use. Options -p <id> , --project <id> : The project to use (if already created) --project-name <name> : The name of the project to create --project-desc <description> : The description of the project to create Patch generated code with new data models During the development process, you may add, change or delete some models. To automatically merge the difference between two generations to your working branch, use this command. This command uses git format-patch and git am . hpf patch It will let you choose the source branch and the commit, then the destination branch. Start the console Run this command to manage data models and templates. hpf serve This will start a web console for editing data models and templates. Options -p <n> , --port <n> : The required port (default between 4800 and 4820 ). -H <hostname> , --hostname <hostname> : The required hostname (default: localhost ) --no-open : Do not open a new tab in the browser to display the console --depth <n> : The depth for searching channels (default: 2 )","title":"CLI"},{"location":"reference/cli/#description","text":"Hapify is a code generation tool based on relational data models. It uses a dedicated templating language. It displays a web console for managing models and writing templates.","title":"Description"},{"location":"reference/cli/#usage","text":"","title":"Usage"},{"location":"reference/cli/#installation","text":"You must install this package globally to get the hpf command: npm install -g @hapify/cli To check the installed version, run hpf --version .","title":"Installation"},{"location":"reference/cli/#global-options","text":"-V , --version : display the version number --debug : enable debug mode (default: false ) --silent : enable silent mode (default: false ) -d <path> , --dir <path> : changes the working directory. This path can be absolute or relative to the current path. -k <secret> , --key <secret> : forces the use of an API key rather than one defined in the global configuration. If you want to set your API key permanently, you should use the hpf key command. -h , --help : display the help","title":"Global options"},{"location":"reference/cli/#commands","text":"","title":"Commands"},{"location":"reference/cli/#define-the-global-configuration","text":"hpf config [ options ] This command saves one or more global configurations in ~/.hapify/config.json . If the file does not exist, it will be automatically created. Available configuration hpf config --apiKey <secret> : sets the API key to use for each command. This is equivalent to hpf key <key> . hpf config --apiUrl <url> : overrides the default API URL.","title":"Define the global configuration"},{"location":"reference/cli/#define-the-global-api-key","text":"hpf key <key> This command is an alias for hpf config --apiKey <secret> .","title":"Define the global API key"},{"location":"reference/cli/#list-the-boilerplates-channels","text":"hpf list Alias: hpf ls This command displays what is visible to the CLI from the current directory. It displays the list of channels and the list of data models used by those channels. The CLI searches for hapify.json files to automatically detect channels. It iterates on the subdirectories. The default depth is 2 . To change this value, use the depth option. hpf list --depth 3 Warning You are not supposed to run the CLI with different sets of data models. If you do, the first set found will be used.","title":"List the boilerplates (channels)"},{"location":"reference/cli/#generate-the-code","text":"hpf generate Alias: hpf g This command generates all the channels found from their templates and data models. To set the depth for searching channels, use this option: --depth <n> . The default value is 2 . hpf generate --depth 3 Tip Empty generated files will not be saved.","title":"Generate the code"},{"location":"reference/cli/#export-the-code","text":"hpf export Alias: hpf x This command generates a channel from its templates and data models and saves the generated files in a zip file. You need to run this command from the channel directory, next to the hapify.json file. By default, the zip file is named from the channel folder. Example: angular-admin/angular-admin.zip . You can define a custom path with this option: -o, --output <path> . hpf export -o /path/to/file.zip Tip Empty generated files will not be saved.","title":"Export the code"},{"location":"reference/cli/#import-data-models","text":"hpf import Alias: hpf m Use this command to import predefined data models from Hapify Cloud (called presets ). Import presets from ID You can also import presets from their IDs (visible on Hapify Hub ) hpf import --preset ab123 --preset bd456","title":"Import data models"},{"location":"reference/cli/#clone-a-boilerplate-and-start-a-new-project","text":"hpf new Alias: hpf n This command allows you to clone and configure a boilerplate. It will ask you to : select a boilerplate select or create the project to use select presets of data models to import Options -p <id> , --project <id> : The project to use (if it already exists) -b <slug> , --boilerplate <slug> : The slug of the boilerplate to clone --boilerplate-id <id> : The ID of the boilerplate to clone --boilerplate-url [url] : The git URLs of the boilerplates to clone --preset [id] : The ID of the presets to be preloaded into the project --no-presets : Do not request any presets --project-name <name> : The name of the project to create --project-desc <description> : The description of the project to create (the name must be defined) To view the available presets, visit hub.hapify.io .","title":"Clone a boilerplate and start a new project"},{"location":"reference/cli/#create-a-new-boilerplatechannel","text":"hpf init Alias: hpf i This command creates a new Hapify file structure in the current directory. It creates 2 files hapify.json , hapify-models.json and a folder .hapify containing a template models/__kebab__/hello.js.hpf . It will ask you to select or create a project. Options --channel-name <name> : The name of the channel to initialize --channel-desc <description> : The description of the channel to initialize --channel-logo <url> : The URL of the logo of the channel to initialize --project-name <name> : The name of the project to create --project-desc <description> : The description of the project to create","title":"Create a new boilerplate/channel"},{"location":"reference/cli/#define-the-project-to-use-in-a-boilerplatechannel","text":"hpf use Alias: hpf u Changes the project used by one or more existing channels . Changes the project ID in the hapify.json file for each channel found. It will ask you to select or create the project to use. Options -p <id> , --project <id> : The project to use (if already created) --project-name <name> : The name of the project to create --project-desc <description> : The description of the project to create","title":"Define the project to use in a boilerplate/channel"},{"location":"reference/cli/#patch-generated-code-with-new-data-models","text":"During the development process, you may add, change or delete some models. To automatically merge the difference between two generations to your working branch, use this command. This command uses git format-patch and git am . hpf patch It will let you choose the source branch and the commit, then the destination branch.","title":"Patch generated code with new data models"},{"location":"reference/cli/#start-the-console","text":"Run this command to manage data models and templates. hpf serve This will start a web console for editing data models and templates. Options -p <n> , --port <n> : The required port (default between 4800 and 4820 ). -H <hostname> , --hostname <hostname> : The required hostname (default: localhost ) --no-open : Do not open a new tab in the browser to display the console --depth <n> : The depth for searching channels (default: 2 )","title":"Start the console"},{"location":"reference/ejs-javascript/","text":"Hapify offers the possibility to write templates with the EJS syntax or in pure JavaScript. Both options are based on the same object described below. Model object Templates of type one model receive the model object via the model variable (alias m ). In the case of a template of type all models , an array of model objects will be available via the models variable (alias m ). The following block is a JSON representation of this model object for a very simple case. Here, the User profile model has 3 fields including a reference to an entity. To keep this JSON as short as possible, we have removed all aliases, many recurring properties and sub-model details. This JSON is a partial representation of the actual injected model object, but it gives you a good overview of its structure. See also If you want to know the complete structure of the model object, you can refer to the model object documentation , or to the TypeScript interface ExplicitModel in the source code of hapify/generator . { \"id\" : \"b0993d03-70d1-0448-1eef-25bde4818d15\" , \"name\" : \"User profile\" , \"names\" : { \"raw\" : \"User profile\" , \"kebab\" : \"user-profile\" , \"snake\" : \"user_profile\" , \"header\" : \"User-Profile\" , \"constant\" : \"USER_PROFILE\" , \"big\" : \"USER-PROFILE\" , \"capital\" : \"User Profile\" , \"lower\" : \"user profile\" , \"upper\" : \"USER PROFILE\" , \"compact\" : \"userprofile\" , \"pascal\" : \"UserProfile\" , \"camel\" : \"userProfile\" }, \"notes\" : \"The user's details\" , \"hasNotes\" : true , \"fields\" : { \"list\" : [ { \"names\" : { \"raw\" : \"_id\" , \"kebab\" : \"-id\" , \"snake\" : \"_id\" , \"header\" : \"-Id\" , \"constant\" : \"_ID\" , \"big\" : \"-ID\" , \"capital\" : \"_Id\" , \"lower\" : \"_id\" , \"upper\" : \"_ID\" , \"compact\" : \"id\" , \"pascal\" : \"Id\" , \"camel\" : \"id\" }, \"name\" : \"_id\" , \"notes\" : \"\" , \"hasNotes\" : false , \"type\" : \"string\" , \"subtype\" : null , \"value\" : null , \"primary\" : true , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false }, { \"names\" : { \"raw\" : \"created at\" , \"kebab\" : \"created-at\" , \"snake\" : \"created_at\" , \"header\" : \"Created-At\" , \"constant\" : \"CREATED_AT\" , \"big\" : \"CREATED-AT\" , \"capital\" : \"Created At\" , \"lower\" : \"created at\" , \"upper\" : \"CREATED AT\" , \"compact\" : \"createdat\" , \"pascal\" : \"CreatedAt\" , \"camel\" : \"createdAt\" }, \"name\" : \"created at\" , \"notes\" : \"\" , \"hasNotes\" : false , \"type\" : \"datetime\" , \"subtype\" : null , \"value\" : null , \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : true , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false }, { \"names\" : { \"raw\" : \"avatar\" , \"kebab\" : \"avatar\" , \"snake\" : \"avatar\" , \"header\" : \"Avatar\" , \"constant\" : \"AVATAR\" , \"big\" : \"AVATAR\" , \"capital\" : \"Avatar\" , \"lower\" : \"avatar\" , \"upper\" : \"AVATAR\" , \"compact\" : \"avatar\" , \"pascal\" : \"Avatar\" , \"camel\" : \"avatar\" }, \"name\" : \"avatar\" , \"notes\" : \"\" , \"hasNotes\" : false , \"type\" : \"entity\" , \"subtype\" : null , \"value\" : \"ac046aac-7a20-de65-2209-57e80a2bbea4\" , \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : false , \"restricted\" : false , \"ownership\" : false , \"model\" : \"// Avatar model details...\" }, { \"names\" : { \"raw\" : \"role\" , \"kebab\" : \"role\" , \"snake\" : \"role\" , \"header\" : \"Role\" , \"constant\" : \"ROLE\" , \"big\" : \"ROLE\" , \"capital\" : \"Role\" , \"lower\" : \"role\" , \"upper\" : \"ROLE\" , \"compact\" : \"role\" , \"pascal\" : \"Role\" , \"camel\" : \"role\" }, \"name\" : \"role\" , \"notes\" : \"restricted to admins\" , \"hasNotes\" : true , \"type\" : \"enum\" , \"subtype\" : null , \"value\" : [ \"admin\" , \"user\" , \"customer\" ], \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : true , \"sortable\" : false , \"hidden\" : false , \"internal\" : false , \"restricted\" : false , \"ownership\" : false , \"enum\" : [ { \"name\" : \"admin\" , \"names\" : { \"raw\" : \"admin\" , \"kebab\" : \"admin\" , \"snake\" : \"admin\" , \"header\" : \"Admin\" , \"constant\" : \"ADMIN\" , \"big\" : \"ADMIN\" , \"capital\" : \"Admin\" , \"lower\" : \"admin\" , \"upper\" : \"ADMIN\" , \"compact\" : \"admin\" , \"pascal\" : \"Admin\" , \"camel\" : \"admin\" } }, \"// Same structure for each enum\" ] } ], \"primary\" : \"// Primary field details...\" , \"unique\" : [ \"// unique fields details (if any)...\" ], \"label\" : [ \"// label fields details (if any)...\" ], \"nullable\" : [ \"// nullable fields details (if any)...\" ], \"multiple\" : [ \"// multiple fields details (if any)...\" ], \"embedded\" : [ \"// embedded fields details (if any)...\" ], \"searchable\" : [ \"// searchable fields details (if any)...\" ], \"sortable\" : [ \"// sortable fields details (if any)...\" ], \"hidden\" : [ \"// hidden fields details (if any)...\" ], \"internal\" : [ \"// internal fields details (if any)...\" ], \"restricted\" : [ \"// internal fields details (if any)...\" ], \"ownership\" : [ \"// ownership fields details (if any)...\" ], \"searchableLabel\" : [ \"// searchableLabel fields details (if any)...\" ], \"references\" : [ \"// references fields details (if any)...\" ] }, \"properties\" : { \"fieldsCount\" : 3 , \"hasPrimary\" : true , \"hasUnique\" : false , \"hasLabel\" : false , \"hasNullable\" : false , \"hasMultiple\" : false , \"hasEmbedded\" : false , \"hasSearchable\" : false , \"hasSortable\" : true , \"hasHidden\" : false , \"hasInternal\" : true , \"hasRestricted\" : false , \"hasOwnership\" : false , \"hasSearchableLabel\" : false , \"mainlyHidden\" : false , \"mainlyInternal\" : true , \"isGeolocated\" : false , \"isGeoSearchable\" : false , \"hasDependencies\" : true , \"isReferenced\" : false }, \"accesses\" : { \"list\" : [ { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true }, { \"action\" : \"read\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true } ], \"properties\" : { \"onlyAdmin\" : false , \"onlyOwner\" : false , \"onlyAuth\" : false , \"onlyGuest\" : true , \"maxAdmin\" : false , \"maxOwner\" : false , \"maxAuth\" : false , \"maxGuest\" : true , \"noAdmin\" : true , \"noOwner\" : true , \"noAuth\" : true , \"noGuest\" : false , \"hasAdmin\" : false , \"hasOwner\" : false , \"hasAuth\" : false , \"hasGuest\" : true }, \"admin\" : [], \"owner\" : [], \"auth\" : [], \"guest\" : [ { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true } ], \"create\" : { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true }, \"read\" : \"// Same structure as create\" , \"update\" : \"// Same structure as create\" , \"remove\" : \"// Same structure as create\" , \"search\" : \"// Same structure as create\" , \"count\" : \"// Same structure as create\" }, \"dependencies\" : { \"list\" : [ \"// Avatar model details...\" ], \"self\" : false }, \"referencedIn\" : [ \"// Referring models come here, populated with entity fields only.\" ] } Templating Here are examples of EJS and JavaScript templates using this model object. Template of type `one model EJS class <%= model . names . pascal %> { private primaryKey = '<%= model.fields.primary.names.snake %>' ; } JavaScript return `class ${ model . names . pascal } { private primaryKey = ' ${ model . fields . primary . names . snake } '; }` ; Output class Place { private primaryKey = '_id' ; } Warning A JavaScript template must return a string. Tip Empty generated files will not be saved. Template of type all models EJS <% for ( let model of models ) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models ) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Output require_once('./user.php'); require_once('./place.php'); require_once('./service.php'); require_once('./place-category.php'); See also For more examples, please read this article .","title":"EJS & JavaScript"},{"location":"reference/ejs-javascript/#model-object","text":"Templates of type one model receive the model object via the model variable (alias m ). In the case of a template of type all models , an array of model objects will be available via the models variable (alias m ). The following block is a JSON representation of this model object for a very simple case. Here, the User profile model has 3 fields including a reference to an entity. To keep this JSON as short as possible, we have removed all aliases, many recurring properties and sub-model details. This JSON is a partial representation of the actual injected model object, but it gives you a good overview of its structure. See also If you want to know the complete structure of the model object, you can refer to the model object documentation , or to the TypeScript interface ExplicitModel in the source code of hapify/generator . { \"id\" : \"b0993d03-70d1-0448-1eef-25bde4818d15\" , \"name\" : \"User profile\" , \"names\" : { \"raw\" : \"User profile\" , \"kebab\" : \"user-profile\" , \"snake\" : \"user_profile\" , \"header\" : \"User-Profile\" , \"constant\" : \"USER_PROFILE\" , \"big\" : \"USER-PROFILE\" , \"capital\" : \"User Profile\" , \"lower\" : \"user profile\" , \"upper\" : \"USER PROFILE\" , \"compact\" : \"userprofile\" , \"pascal\" : \"UserProfile\" , \"camel\" : \"userProfile\" }, \"notes\" : \"The user's details\" , \"hasNotes\" : true , \"fields\" : { \"list\" : [ { \"names\" : { \"raw\" : \"_id\" , \"kebab\" : \"-id\" , \"snake\" : \"_id\" , \"header\" : \"-Id\" , \"constant\" : \"_ID\" , \"big\" : \"-ID\" , \"capital\" : \"_Id\" , \"lower\" : \"_id\" , \"upper\" : \"_ID\" , \"compact\" : \"id\" , \"pascal\" : \"Id\" , \"camel\" : \"id\" }, \"name\" : \"_id\" , \"notes\" : \"\" , \"hasNotes\" : false , \"type\" : \"string\" , \"subtype\" : null , \"value\" : null , \"primary\" : true , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false }, { \"names\" : { \"raw\" : \"created at\" , \"kebab\" : \"created-at\" , \"snake\" : \"created_at\" , \"header\" : \"Created-At\" , \"constant\" : \"CREATED_AT\" , \"big\" : \"CREATED-AT\" , \"capital\" : \"Created At\" , \"lower\" : \"created at\" , \"upper\" : \"CREATED AT\" , \"compact\" : \"createdat\" , \"pascal\" : \"CreatedAt\" , \"camel\" : \"createdAt\" }, \"name\" : \"created at\" , \"notes\" : \"\" , \"hasNotes\" : false , \"type\" : \"datetime\" , \"subtype\" : null , \"value\" : null , \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : true , \"hidden\" : false , \"internal\" : true , \"restricted\" : false , \"ownership\" : false }, { \"names\" : { \"raw\" : \"avatar\" , \"kebab\" : \"avatar\" , \"snake\" : \"avatar\" , \"header\" : \"Avatar\" , \"constant\" : \"AVATAR\" , \"big\" : \"AVATAR\" , \"capital\" : \"Avatar\" , \"lower\" : \"avatar\" , \"upper\" : \"AVATAR\" , \"compact\" : \"avatar\" , \"pascal\" : \"Avatar\" , \"camel\" : \"avatar\" }, \"name\" : \"avatar\" , \"notes\" : \"\" , \"hasNotes\" : false , \"type\" : \"entity\" , \"subtype\" : null , \"value\" : \"ac046aac-7a20-de65-2209-57e80a2bbea4\" , \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : false , \"sortable\" : false , \"hidden\" : false , \"internal\" : false , \"restricted\" : false , \"ownership\" : false , \"model\" : \"// Avatar model details...\" }, { \"names\" : { \"raw\" : \"role\" , \"kebab\" : \"role\" , \"snake\" : \"role\" , \"header\" : \"Role\" , \"constant\" : \"ROLE\" , \"big\" : \"ROLE\" , \"capital\" : \"Role\" , \"lower\" : \"role\" , \"upper\" : \"ROLE\" , \"compact\" : \"role\" , \"pascal\" : \"Role\" , \"camel\" : \"role\" }, \"name\" : \"role\" , \"notes\" : \"restricted to admins\" , \"hasNotes\" : true , \"type\" : \"enum\" , \"subtype\" : null , \"value\" : [ \"admin\" , \"user\" , \"customer\" ], \"primary\" : false , \"unique\" : false , \"label\" : false , \"nullable\" : false , \"multiple\" : false , \"embedded\" : false , \"searchable\" : true , \"sortable\" : false , \"hidden\" : false , \"internal\" : false , \"restricted\" : false , \"ownership\" : false , \"enum\" : [ { \"name\" : \"admin\" , \"names\" : { \"raw\" : \"admin\" , \"kebab\" : \"admin\" , \"snake\" : \"admin\" , \"header\" : \"Admin\" , \"constant\" : \"ADMIN\" , \"big\" : \"ADMIN\" , \"capital\" : \"Admin\" , \"lower\" : \"admin\" , \"upper\" : \"ADMIN\" , \"compact\" : \"admin\" , \"pascal\" : \"Admin\" , \"camel\" : \"admin\" } }, \"// Same structure for each enum\" ] } ], \"primary\" : \"// Primary field details...\" , \"unique\" : [ \"// unique fields details (if any)...\" ], \"label\" : [ \"// label fields details (if any)...\" ], \"nullable\" : [ \"// nullable fields details (if any)...\" ], \"multiple\" : [ \"// multiple fields details (if any)...\" ], \"embedded\" : [ \"// embedded fields details (if any)...\" ], \"searchable\" : [ \"// searchable fields details (if any)...\" ], \"sortable\" : [ \"// sortable fields details (if any)...\" ], \"hidden\" : [ \"// hidden fields details (if any)...\" ], \"internal\" : [ \"// internal fields details (if any)...\" ], \"restricted\" : [ \"// internal fields details (if any)...\" ], \"ownership\" : [ \"// ownership fields details (if any)...\" ], \"searchableLabel\" : [ \"// searchableLabel fields details (if any)...\" ], \"references\" : [ \"// references fields details (if any)...\" ] }, \"properties\" : { \"fieldsCount\" : 3 , \"hasPrimary\" : true , \"hasUnique\" : false , \"hasLabel\" : false , \"hasNullable\" : false , \"hasMultiple\" : false , \"hasEmbedded\" : false , \"hasSearchable\" : false , \"hasSortable\" : true , \"hasHidden\" : false , \"hasInternal\" : true , \"hasRestricted\" : false , \"hasOwnership\" : false , \"hasSearchableLabel\" : false , \"mainlyHidden\" : false , \"mainlyInternal\" : true , \"isGeolocated\" : false , \"isGeoSearchable\" : false , \"hasDependencies\" : true , \"isReferenced\" : false }, \"accesses\" : { \"list\" : [ { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true }, { \"action\" : \"read\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true } ], \"properties\" : { \"onlyAdmin\" : false , \"onlyOwner\" : false , \"onlyAuth\" : false , \"onlyGuest\" : true , \"maxAdmin\" : false , \"maxOwner\" : false , \"maxAuth\" : false , \"maxGuest\" : true , \"noAdmin\" : true , \"noOwner\" : true , \"noAuth\" : true , \"noGuest\" : false , \"hasAdmin\" : false , \"hasOwner\" : false , \"hasAuth\" : false , \"hasGuest\" : true }, \"admin\" : [], \"owner\" : [], \"auth\" : [], \"guest\" : [ { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true } ], \"create\" : { \"action\" : \"create\" , \"admin\" : false , \"owner\" : false , \"auth\" : false , \"guest\" : true , \"gteAdmin\" : true , \"gteOwner\" : true , \"gteAuth\" : true , \"gteGuest\" : true , \"lteAdmin\" : false , \"lteOwner\" : false , \"lteAuth\" : false , \"lteGuest\" : true }, \"read\" : \"// Same structure as create\" , \"update\" : \"// Same structure as create\" , \"remove\" : \"// Same structure as create\" , \"search\" : \"// Same structure as create\" , \"count\" : \"// Same structure as create\" }, \"dependencies\" : { \"list\" : [ \"// Avatar model details...\" ], \"self\" : false }, \"referencedIn\" : [ \"// Referring models come here, populated with entity fields only.\" ] }","title":"Model object"},{"location":"reference/ejs-javascript/#templating","text":"Here are examples of EJS and JavaScript templates using this model object.","title":"Templating"},{"location":"reference/ejs-javascript/#template-of-type-one-model","text":"EJS class <%= model . names . pascal %> { private primaryKey = '<%= model.fields.primary.names.snake %>' ; } JavaScript return `class ${ model . names . pascal } { private primaryKey = ' ${ model . fields . primary . names . snake } '; }` ; Output class Place { private primaryKey = '_id' ; } Warning A JavaScript template must return a string. Tip Empty generated files will not be saved.","title":"Template of type `one model"},{"location":"reference/ejs-javascript/#template-of-type-all-models","text":"EJS <% for ( let model of models ) { -%> require_once ( './<%= model.names.kebab %>.php' ); <% } -%> JavaScript let output = '' ; for ( let model of models ) { output += `require_once('./ ${ model . names . kebab } .php'); \\ n` ; } return output ; Output require_once('./user.php'); require_once('./place.php'); require_once('./service.php'); require_once('./place-category.php'); See also For more examples, please read this article .","title":"Template of type all models"},{"location":"reference/hapify-syntax/","text":"Why use a specific syntax? We have designed a syntax able to manipulate the model object injected in the templates. This syntax is optimized to play with the properties of this model object using short words. This allows to handle complex ideas with simple sentences. For example, this loop in JavaScript : for ( let field of root . fields . filter ( f => f . searchable && f . type === 'entity' )) { out += ' Do something' ; } will be written like this with the Hapify syntax: Hapify (long) <<for Fields searchable and entity field >> Do something <<endfor>> Hapify (short) <<@ F se * tE f >> Do something <<@>> Long and short syntaxes Hapify templates can be written with a long or a short syntax. Both have their advantages: The short syntax does not interfere with the target code when reading the template, thanks to a shorter meta-code. The long syntax is explicit and can be read easily. In the same template, you can mix both syntaxes. Note All code examples below are translated into JavaScript equivalent for your information. During generation, the Hapify syntax is converted to similar JavaScript code. Tags Hapify syntax blocks are wrapped by two tags: opening: << . closing: >> . Escaping Generally used for binary operations, these tags can be escaped. The escaped tags <<` (and >> ) are replaced by << (and >>`) during generation. Names Data model names In a template of type one model : Hapify (long) // Create a new <<Model lower>> const <<Model camel>> = new <<Model pascal>> (); Hapify (short) // Create a new <<M a>> const <<M aA>> = new <<M AA>> (); JavaScript equivalent out += `// Create a new ${ root . names . lower } const ${ root . names . camel } = new ${ root . names . pascal } ();` ; For a data model named user group , the result will be as follows: // Create a new user group const userGroup = new UserGroup (); Field names List all fields of a data model: Hapify (long) <?php $fields = array( <<for Fields field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ F f >> ' <<f aA>> ', <<@>> ); JavaScript equivalent out += `<?php $fields = array( ${ root . fields . list . map ( f => \"'\" + f . names . camel + \"'\" ). join ( \",\\n\\t\" ) } );` ; For a data model with name , created at and role fields: <?php $fields = array ( 'name' , 'createdAt' , 'role' , ); Cases The available cases are: camel (alias : aA ) for camelCase pascal (alias : AA ) for PascalCase lower (alias : a ) for lower case capital (alias : A ) for Capital Case kebab (alias : a-a ) for kebab-case header (alias : A-A ) for Header-Case snake (alias : a_a ) for snake_case constant (alias : A_A ) for CONSTANT_CASE compact (alias : aa ) for compactcase raw (alias : R ) (raw) for the original name Conditions Simple condition Hapify (long) const utils = require('utils'); <<if Fields entity >> const mongoDb = require('mongodb'); <<endif>> Hapify (short) const utils = require('utils'); <<? F tE >> const mongoDb = require('mongodb'); <<?>> JavaScript equivalent out += `const utils = require('utils');` ; if ( root . fields . filter ( f => f . type === 'entity' ). length > 0 ) { out += ` \\ nconst mongoDb = require('mongodb');` ; } For a data model that contains at least one field of type entity , the result will be as follows: const utils = require ( 'utils' ); const mongoDb = require ( 'mongodb' ); For a data model that does not contain a field of type entity , the result will be as follows: const utils = require ( 'utils' ); Without filter Field filtering is optional. Hapify (long) <<if Fields >> // this model has at least one field <<endif>> Hapify (short) <<? F >> // this model has at least one field <<?>> JavaScript equivalent if ( root . fields . list . length > 0 ) { out += ' // this model has at least one field' ; } Alternative conditions Hapify (long) <<if Fields entity >> // At least one entity field <<elseif Fields hidden >> // No entity field and at least one hidden field <<else>> // No entity field and no hidden field <<endif>> Hapify (short) <<? F tE >> // At least one entity field <<?? F hd >> // No entity field and at least one hidden field <<??>> // No entity field and no hidden field <<?>> JavaScript equivalent if ( root . fields . filter ( f => f . type === 'entity' ). length > 0 ) { out += ' // At least one entity field' ; } else if ( root . fields . filter ( f => f . hidden ). length > 0 ) { out += ' // No entity field and at least one hidden field' ; } else { out += ' // No entity field and no hidden field' ; } Complex conditions Operators The operators available for conditions are : and - alias * or && or - alias + or || and not - alias andNot , / or && ! or not - alias orNot , - or || ! Example Hapify (long) <<if Fields ( entity and hidden ) or ( unique and not multiple ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<endif>> Hapify (short) <<? F ( tE * hd ) + ( un / ml ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<?>> JavaScript equivalent for ( let field of root . fields . filter ( f => ( f . type === 'entity' && f . hidden ) || ( f . unique && ! f . multiple ))) { out += ' // ...' ; } Conditions can also be written with native operators. Let's rewrite this last condition: Hapify (long) <<if Fields ( entity && hidden ) || ( unique && !multiple ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<endif>> Hapify (short) <<? F ( tE && hd ) || ( un && !ml ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<?>> JavaScript equivalent for ( let field of root . fields . filter ( f => ( f . type === 'entity' && f . hidden ) || ( f . unique && ! f . multiple ))) { out += ' // ...' ; } Conditions on the number of occurrences By specifying a number after the if , we can add a condition on the minimum number of required elements. In this case, the fields : Hapify (long) <<if 4 Fields hidden >> // This model has at least 4 hidden fields <<elseif 2 Fields label or boolean >> // This model has at least 2 label or boolean fields <<else>> // Something else <<endif>> Hapify (short) <<? 4 F hd >> // This model has at least 4 hidden fields <<?? 2 F lb + tB >> // This model has at least 2 label or boolean fields <<??>> // Something else <<?>> JavaScript equivalent if ( root . fields . filter ( f => f . hidden ). length >= 4 ) { out += ' // This model has at least 4 hidden fields' ; } else if ( root . fields . filter ( f => f . label || f . type === 'boolean' ). length >= 2 ) { out += ' // This model has at least 2 label or boolean fields' ; } else { out += ' // Something else' ; } Conditions on the data models Test a single data model In a template of type one model : Hapify (long) <<if Model isGeolocated >> // This block is reached if the model is geolocated. // that's means it has at least one latitude field and one longitude field <<endif>> Hapify (short) <<? M pGeo >> // This block is reached if the model is geolocated. // that's means it has at least one latitude field and one longitude field <<?>> JavaScript equivalent if ( root . properties . isGeolocated ) { out += ' // ...' ; } Test a list of data models In a template of type all models : Hapify (long) <<if Models not onlyGuest >> // This block is reached if at least one model has not only guest actions import 'session-service'; <<endif>> Hapify (short) <<? M !pOGs >> // This block is reached if at least one model has not only guest actions import 'session-service'; <<?>> JavaScript equivalent if ( root . filter ( m => ! m . accesses . properties . onlyGuest ). length > 0 ) { out += \" import 'session-service';\" ; } Available objects and filters Root object Model or Models ( short: M ) refer to the main object: the data model in a template of type one model the array of data models in a template of type all models . Filterable and testable objects In the case of a template of type one model : Fields (alias: F ) is the list of fields Dependencies (alias: D ) is the list of dependencies (list of data models) ReferencedIn (alias: RefModels , R ) is the list of data models that depend on it PrimaryField (alias: P ) is the primary field of the model Accesses (alias: A ) is the list of accesses CreateAccess (alias: Ac ) is the access to the create action ReadAccess (alias: Ar ) is the access to the read action UpdateAccess (alias: Au ) is the access to the update action RemoveAccess (alias: Ad ) is the access to the delete action SearchAccess (alias: As ) is the access to the search action CountAccess (alias: An ) is the access to the count action Filtering on field attributes Available attributes for a field: primary (short: pr ) for boolean primary unique (short: un ) for boolean unique label (short: lb ) for boolean label nullable (short: nu ) for boolean nullable multiple (short: ml ) for boolean multiple embedded (short: em ) for boolean embedded searchable (short: se ) for boolean searchable sortable (short: so ) for boolean sortable hidden (short: hd ) for boolean hidden internal (short: in ) for boolean internal restricted (short: rs ) for boolean restricted ownership (short: os ) for boolean ownership string (short: tS ) for type string email (short: tSe ) for type string and subtype email password (short: tSp ) for type string and subtype password url (short: tSu ) for type string and subtype url text (short: tSt ) for type string and subtype text richText (alias: rich , short: tSr ) for type string and subtype rich number (short: tN ) for type number integer (short: tNi ) for type number and subtype integer float (short: tNf ) for type number and subtype float latitude (short: tNt ) for type number and subtype latitude longitude (short: tNg ) for type number and subtype longitude boolean (short: tB ) for type boolean datetime (short: tD ) for type datetime date (short: tDd ) for type datetime and subtype date time (short: tDt ) for type datetime and subtype time enum (short: tU ) for type enum entity (short: tE ) for type entity oneOne (short: tEoo ) for type entity and subtype oneOne oneMany (short: tEom ) for type entity and subtype oneMany manyOne (short: tEmo ) for type entity and subtype manyOne manyMany (short: tEmm ) for type entity and subtype manyMany object (short: tO ) for type object file (short: tF ) for type file image (short: tFi ) for type file and subtype image video (short: tFv ) for type file and subtype video audio (short: tFa ) for type file and subtype audio document (short: tFd ) for type file and subtype document Example Hapify (long) <<if Fields ( restricted or internal ) and not number >> // Current model has at least one field matching to the condition <<endif>> Hapify (short) <<? F ( rs + in ) / tN >> // Current model has at least one field matching to the condition <<?>> JavaScript equivalent if ( root . fields . filter ( f => ( f . restricted || f . internal ) && ! f . number ). length > 0 ) { out += \" // ...\" ; } Filtering on data model properties Properties available for a data model: mainlyHidden (short: pMHd ) most of the fields are hidden (strictly) mainlyInternal (short: pMIn ) most of the fields are internal (strictly) isGeolocated (short: pGeo ) the model contains at least one latitude field and one longitude field isGeoSearchable (short: pGSe ) the model contains at least one searchable latitude field and one searchable longitude field Example Hapify (long) <<if Model isGeolocated >> // This model contains at least one latitude field and one longitude field. <<endif>> Hapify (short) <<? M pGeo >> // This model contains at least one latitude field and one longitude field. <<?>> JavaScript equivalent if ( root . properties . isGeolocated ) { out += \" // ...\" ; } Access properties available for a data model: onlyAdmin (short: pOAd ) the model only contains actions restricted to admin onlyOwner (short: pOOw ) the model only contains actions restricted to owner onlyAuth (short: pOAu ) the model only contains actions restricted to authenticated onlyGuest (short: pOGs ) the model only contains actions restricted to guest maxAdmin (short: pMAd ) the most permissive access is admin maxOwner (short: pMOw ) the most permissive access is owner maxAuth (short: pMAu ) the most permissive access is authenticated maxGuest (short: pMGs ) the most permissive access is guest noAdmin (short: pNAd ) there is no action restricted to admin noOwner (short: pNOw ) there is no action restricted to owner noAuth (short: pNAu ) there is no action restricted to authenticated noGuest (short: pNGs ) there is no action restricted to guest Example Hapify (long) <<if Model onlyAdmin >> // All actions on this model are restricted to admins <<endif>> Hapify (short) <<? M pOAd >> // All actions on this model are restricted to admins <<?>> JavaScript equivalent if ( root . accesses . properties . onlyAdmin ) { out += \" // ...\" ; } Filtering on data model access Reminder guest is the most permissive access and admin the least permissive. Therefore admin < owner < authenticated < guest . Filters available for action access: admin (short: ad ) the access is admin owner (short: ow ) the access is owner auth (short: au ) the access is auth guest (short: gs ) the access is guest gteAdmin (short: [ad ) the access is greater or equal than admin gteOwner (short: [ow ) the access is greater or equal than owner gteAuth (short: [au ) the access is greater or equal than auth gteGuest (short: [gs ) the access is greater or equal than guest lteAdmin (short: ad] ) the access is less or equal than admin lteOwner (short: ow] ) the access is less or equal than owner lteAuth (short: au] ) the access is less or equal than auth lteGuest (short: gs] ) the access is less or equal than guest Exemples Tests access for a specific action: Hapify (long) <<if ReadAccess guest >> // Anyone can read this model <<endif>> Hapify (short) <<? Ar gs >> // Anyone can read this model <<?>> JavaScript equivalent if ( root . accesses . read . guest ) { out += ' // ...' ; } Checks if the update action is restricted to either the administrators or the owner: Hapify (long) <<if UpdateAccess admin or owner >> // ... <<endif>> Hapify (short) <<? Au ad + ow >> // ... <<?>> JavaScript equivalent if ( root . accesses . update . admin || root . accesses . update . owner ) { out += ' // ...' ; } Tests whether at least one action is restricted to one or fewer authenticated users: Hapify (long) <<if Accesses lteAuth >> // ... <<endif>> Hapify (short) <<? A au] >> // ... <<?>> JavaScript equivalent if ( root . accesses . filter ( a => a . lteAuth ). length > 0 ) { out += ' // ...' ; } Tip Conditions can be applied to an object or an array of objects. If applied to an array, it will test the length of the array filtered by the provided condition. It can be used on any object containing a filter method that receives a callback returning a boolean. For example, in the data model structure, root.dependencies is an object that contains a filter method. Thus, this operator can test whether a model has dependencies that have fields with a specific condition. Iterations Iterations use the same filters and operators as conditions. Simple iteration Loops over all the fields in a data model that are not hidden and assigns them to the field variable: Hapify (long) <?php $fields = array( <<for Fields not hidden field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ F !hd f >> ' <<f aA>> ', <<@>> ); JavaScript equivalent out += `<?php $fields = array( ${ root . fields . filter ( f => ! f . hidden ) . map ( f => \"'\" + f . names . camel + \"'\" ) . join ( \",\\n\\t\" ) } );` ; Example for a data model with fields name , created at and role , where role is hidden: <?php $fields = array ( 'name' , 'createdAt' , ); Loops over the entity and searchable fields of the data model: Hapify (long) <<for Fields searchable and entity field >> // ... <<endfor>> Hapify (short) <<@ F se * tE f >> // ... <<@>> JavaScript equivalent for ( let field of root . fields . filter ( f => f . searchable && f . type === 'entity' )) { out += ' // ...' ; } Loop without filtering This operation allows you to loop through all the fields: Hapify (long) <<for Fields field >> // ... <<endfor>> Hapify (short) <<@ F f >> // ... <<@>> JavaScript equivalent for ( let field of root . fields . list ) { out += ' // ...' ; } Loop through data models In a template of type all models , this loops through all the data models that are geo-located: Hapify (long) <<for Models isGeolocated model >> // ... <<endfor>> Hapify (short) <<@ M pGeo m >> // ... <<@>> JavaScript equivalent for ( let model of root . filter ( i => i . properties . isGeolocated )) { out += ' // ...' ; } Loop through dependencies. In a template of type one model , this loops through the dependencies whose referent field is searchable: Hapify (long) <<for Dependencies searchable dep >> // ... <<endfor>> Hapify (short) <<@ D se d >> // ... <<@>> JavaScript equivalent for ( let dep of root . dependencies . filter ( f => f . searchable )) { out += ' // ...' ; } Tip In the case of a self-referencing data model, Dependencies excludes this self-dependency. To include it use the following code: <<< for (let dep of root.dependencies.filter(f => f, false)) { >>> // ... <<< } >>> Warning Filtering of Dependencies is performed only on the fields of the current data model that carry the reference. Filtering is not performed on the fields of the target data model. Loop through referring data models In a template of type one model , this loops through the data models that have a dependency on it and that are geo-located: Hapify (long) <<for ReferencedIn isGeolocated referrer >> // ... <<endfor>> Hapify (short) <<@ R pGeo r >> // ... <<@>> JavaScript equivalent for ( let referrer of root . referencedIn . filter ( m => m . properties . isGeolocated )) { out += ' // ...' ; } Tip The filter is optional. You can get all the referring data models like this: <<for ReferencedIn referrer >> // ... <<endfor>> Warning Only referenced entity fields are defined in these referring data models. Loop through the accesses of the data model Loops through all accesses restricted to an administrator or owner and displays the name of the action: Hapify (long) <<for Accesses admin or owner access >> <<=access.action>> <<endfor>> Hapify (short) <<@ A ad + ow a >> <<=a.action>> <<@>> JavaScript equivalent for ( let access of root . accesses . filter ( a => a . admin || a . owner )) { out += ` ${ access . action } \\ n` ; } Shortened iteration Loop through the first 2 fields of a data model : Hapify (long) <?php $fields = array( <<for 2 Fields field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ 2 F f >> ' <<f aA>> ', <<@>> ); JavaScript equivalent out += `<?php $fields = array( ${ root . fields . list . slice ( 0 , 2 ) . map ( f => \"'\" + f . names . camel + \"'\" ) . join ( \",\\n\\t\" ) } );` ; For a data model with fields name , email and role : <?php $fields = array ( 'name' , 'email' , ); Nested iterations Loop through the enums In a template of type one model , this block defines a TypeScript type containing the enums of a field: Hapify (long) <<for Fields enum field >> type <<field pascal>> = <<for field . enum e >> | '<<e snake >> '<<endfor >> ; <<endfor>> Hapify (short) <<@ F tU f >> type <<f AA>> = <<@ f . e e >> | '<<e a_a >> '<<@ >> ; <<@>> JavaScript equivalent for ( let field of root . fields . filter ( f => f . type === 'enum' )) { out += `type ${ field . names . pascal } = ${ field . enum . map ( e => \"'\" + e . names . snake + \"'\" ). join ( ' | ' ) } ;` ; } Output type Role = | 'admin' | 'user' | 'customer' ; Loop through the fields of all data models In a template of type all models , this block loops through all the fields of all the data models: Hapify (long) const models = { <<for Models model >> <<m camel>> : [ <<for model . fields field >> ' <<field camel>> ', <<endfor>> ], <<endfor>> } Hapify (short) const models = { <<@ M m >> <<m aA>> : [ <<@ m . f f >> ' <<f aA>> ', <<@>> ], <<@>> } Output const models = { user : [ 'id' , 'createdAt' , 'email' , 'name' , ], place : [ 'id' , 'name' , 'category' , ], placeCategory : [ 'id' , 'createdAt' , 'email' , 'name' , ], } Raw input and interpolation This operator allows you to write pure JavaScript. Custom variable Defines a custom variable and adds it to the output: <<< const length = root.fields.length; >>> // This model has <<=length>> fields Custom function Defines a custom function and calls it: Hapify (long) <<< function fieldName(field) { return field.names.snake.replace('_', ':'); } >>> <<for Fields field >> <<=fieldName(field)>> <<endfor>> Hapify (short) <<< function fieldName(f) { return f.names.snake.replace('_', ':'); } >>> <<@ F f >> <<=fieldName(f)>> <<@>> Output id created:at place:category Custom condition or iteration This block allows you to write a condition that is not handled by the Hapify syntax: <<< if (root.fields.hidden.length < 3 || root.properties.mainlyInternal) { >>> // ... <<< } >>> Tip In a Hapify template of type one model , the root variable refers to the data model. In a Hapify template of type all models , the root variable refers to the array of data models. See also For detailed information on the structure of the data model, see the model object . Notes You can retrieve notes left by the user on a field or model: Hapify (long) <<if Model hasNotes >> // <<! Model >> <<endif >> export class <<Model pascal>> { <<for Fields field >> public <<field camel>> ; <<if field hasNotes >> // <<! field >> <<endif >> <<endfor>> } Hapify (short) <<? M hN >> // <<! M >> <<? >> export class <<M AA>> { <<@ F f >> public <<f aA>> ; <<? f hN >> // <<! f >> <<? >> <<@>> } Output // A user can only list its own bookmarks export class Bookmark { public id ; public owner ; // Current user when creating the bookmark public place ; } It is also possible to use interpolation to display the notes: Hapify (long) <<if Model hasNotes >> // <<=root . notes >> <<endif >> export class <<Model pascal>> { <<for Fields field >> public <<field camel>> ; <<if field hasNotes >> // <<=field . notes >> <<endif >> <<endfor>> } Hapify (short) <<? M hN >> // <<=root . notes >> <<? >> export class <<M AA>> { <<@ F f >> public <<f aA>> ; <<? f hN >> // <<=field . notes >> <<? >> <<@>> } Error Do not write this: <<= JSON.stringify(root) >> . The root object has recursive properties. Therefore, this command will lead to an infinite loop. Comments This syntax writes a comment to the template without any output to the generated file. <<# This is just a comment>> Escaping It is possible to escape the tags of the Hapify syntax with the character \\ : Hapify $val = 4; $res = $val \\<\\< 3; $res = 4 \\>\\> $val; Output $val = 4; $res = $val << 3; $res = 4 >> $val; Formatting Empty lines and lines containing only condition or iteration meta-code are automatically deleted after generation. To force the generator to keep an empty line, insert one or more spaces at the beginning of it. Warning Hapify does not format the generated code, since the formatting rules are specific to each language or framework. We strongly recommend you to use a code formatter after the generation. Reserved words The following list of words cannot be used to name variables. A , Ac , Accesses , ad , Ad , admin , An , and , andNot , Ar , As , au , Au , audio , auth , boolean , CountAccess , CreateAccess , D , date , datetime , Dependencies , document , else , elseif , em , email , embedded , endfor , endif , entity , enum , F , Fields , file , float , for , gs , gteAdmin , gteAuth , gteGuest , gteOwner , guest , hasNotes , hd , hidden , hN , if , image , in , integer , internal , isGeolocated , isGeoSearchable , label , latitude , lb , longitude , lteAdmin , lteAuth , lteGuest , lteOwner , M , mainlyHidden , mainlyInternal , manyMany , manyOne , maxAdmin , maxAuth , maxGuest , maxOwner , ml , Model , Models , multiple , noAdmin , noAuth , noGuest , noOwner , not , nu , nullable , number , object , oneMany , oneOne , onlyAdmin , onlyAuth , onlyGuest , onlyOwner , or , orNot , os , out , ow , owner , ownership , P , password , pGeo , pGSe , pMAd , pMAu , pMGs , pMHd , pMIn , pMOw , pNAd , pNAu , pNGs , pNOw , pOAd , pOAu , pOGs , pOOw , pr , primary , PrimaryField , R , ReadAccess , ReferencedIn , RefModels , RemoveAccess , restricted , rich , richText , root , rs , se , searchable , SearchAccess , so , sortable , string , tB , tD , tDd , tDt , tE , tEmm , tEmo , tEom , tEoo , text , tF , tFa , tFd , tFi , tFv , time , tN , tNf , tNg , tNi , tNt , tO , tS , tSe , tSp , tSr , tSt , tSu , tU , un , unique , UpdateAccess , url , video .","title":"Hapify Syntax"},{"location":"reference/hapify-syntax/#why-use-a-specific-syntax","text":"We have designed a syntax able to manipulate the model object injected in the templates. This syntax is optimized to play with the properties of this model object using short words. This allows to handle complex ideas with simple sentences. For example, this loop in JavaScript : for ( let field of root . fields . filter ( f => f . searchable && f . type === 'entity' )) { out += ' Do something' ; } will be written like this with the Hapify syntax: Hapify (long) <<for Fields searchable and entity field >> Do something <<endfor>> Hapify (short) <<@ F se * tE f >> Do something <<@>>","title":"Why use a specific syntax?"},{"location":"reference/hapify-syntax/#long-and-short-syntaxes","text":"Hapify templates can be written with a long or a short syntax. Both have their advantages: The short syntax does not interfere with the target code when reading the template, thanks to a shorter meta-code. The long syntax is explicit and can be read easily. In the same template, you can mix both syntaxes. Note All code examples below are translated into JavaScript equivalent for your information. During generation, the Hapify syntax is converted to similar JavaScript code.","title":"Long and short syntaxes"},{"location":"reference/hapify-syntax/#tags","text":"Hapify syntax blocks are wrapped by two tags: opening: << . closing: >> .","title":"Tags"},{"location":"reference/hapify-syntax/#escaping","text":"Generally used for binary operations, these tags can be escaped. The escaped tags <<` (and >> ) are replaced by << (and >>`) during generation.","title":"Escaping"},{"location":"reference/hapify-syntax/#names","text":"","title":"Names"},{"location":"reference/hapify-syntax/#data-model-names","text":"In a template of type one model : Hapify (long) // Create a new <<Model lower>> const <<Model camel>> = new <<Model pascal>> (); Hapify (short) // Create a new <<M a>> const <<M aA>> = new <<M AA>> (); JavaScript equivalent out += `// Create a new ${ root . names . lower } const ${ root . names . camel } = new ${ root . names . pascal } ();` ; For a data model named user group , the result will be as follows: // Create a new user group const userGroup = new UserGroup ();","title":"Data model names"},{"location":"reference/hapify-syntax/#field-names","text":"List all fields of a data model: Hapify (long) <?php $fields = array( <<for Fields field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ F f >> ' <<f aA>> ', <<@>> ); JavaScript equivalent out += `<?php $fields = array( ${ root . fields . list . map ( f => \"'\" + f . names . camel + \"'\" ). join ( \",\\n\\t\" ) } );` ; For a data model with name , created at and role fields: <?php $fields = array ( 'name' , 'createdAt' , 'role' , );","title":"Field names"},{"location":"reference/hapify-syntax/#cases","text":"The available cases are: camel (alias : aA ) for camelCase pascal (alias : AA ) for PascalCase lower (alias : a ) for lower case capital (alias : A ) for Capital Case kebab (alias : a-a ) for kebab-case header (alias : A-A ) for Header-Case snake (alias : a_a ) for snake_case constant (alias : A_A ) for CONSTANT_CASE compact (alias : aa ) for compactcase raw (alias : R ) (raw) for the original name","title":"Cases"},{"location":"reference/hapify-syntax/#conditions","text":"","title":"Conditions"},{"location":"reference/hapify-syntax/#simple-condition","text":"Hapify (long) const utils = require('utils'); <<if Fields entity >> const mongoDb = require('mongodb'); <<endif>> Hapify (short) const utils = require('utils'); <<? F tE >> const mongoDb = require('mongodb'); <<?>> JavaScript equivalent out += `const utils = require('utils');` ; if ( root . fields . filter ( f => f . type === 'entity' ). length > 0 ) { out += ` \\ nconst mongoDb = require('mongodb');` ; } For a data model that contains at least one field of type entity , the result will be as follows: const utils = require ( 'utils' ); const mongoDb = require ( 'mongodb' ); For a data model that does not contain a field of type entity , the result will be as follows: const utils = require ( 'utils' );","title":"Simple condition"},{"location":"reference/hapify-syntax/#without-filter","text":"Field filtering is optional. Hapify (long) <<if Fields >> // this model has at least one field <<endif>> Hapify (short) <<? F >> // this model has at least one field <<?>> JavaScript equivalent if ( root . fields . list . length > 0 ) { out += ' // this model has at least one field' ; }","title":"Without filter"},{"location":"reference/hapify-syntax/#alternative-conditions","text":"Hapify (long) <<if Fields entity >> // At least one entity field <<elseif Fields hidden >> // No entity field and at least one hidden field <<else>> // No entity field and no hidden field <<endif>> Hapify (short) <<? F tE >> // At least one entity field <<?? F hd >> // No entity field and at least one hidden field <<??>> // No entity field and no hidden field <<?>> JavaScript equivalent if ( root . fields . filter ( f => f . type === 'entity' ). length > 0 ) { out += ' // At least one entity field' ; } else if ( root . fields . filter ( f => f . hidden ). length > 0 ) { out += ' // No entity field and at least one hidden field' ; } else { out += ' // No entity field and no hidden field' ; }","title":"Alternative conditions"},{"location":"reference/hapify-syntax/#complex-conditions","text":"","title":"Complex conditions"},{"location":"reference/hapify-syntax/#operators","text":"The operators available for conditions are : and - alias * or && or - alias + or || and not - alias andNot , / or && ! or not - alias orNot , - or || ! Example Hapify (long) <<if Fields ( entity and hidden ) or ( unique and not multiple ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<endif>> Hapify (short) <<? F ( tE * hd ) + ( un / ml ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<?>> JavaScript equivalent for ( let field of root . fields . filter ( f => ( f . type === 'entity' && f . hidden ) || ( f . unique && ! f . multiple ))) { out += ' // ...' ; } Conditions can also be written with native operators. Let's rewrite this last condition: Hapify (long) <<if Fields ( entity && hidden ) || ( unique && !multiple ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<endif>> Hapify (short) <<? F ( tE && hd ) || ( un && !ml ) >> // This code block is reached if the model has at least one field that validates this conditions: // (type entity AND hidden) OR (unique AND NOT multiple) <<?>> JavaScript equivalent for ( let field of root . fields . filter ( f => ( f . type === 'entity' && f . hidden ) || ( f . unique && ! f . multiple ))) { out += ' // ...' ; }","title":"Operators"},{"location":"reference/hapify-syntax/#conditions-on-the-number-of-occurrences","text":"By specifying a number after the if , we can add a condition on the minimum number of required elements. In this case, the fields : Hapify (long) <<if 4 Fields hidden >> // This model has at least 4 hidden fields <<elseif 2 Fields label or boolean >> // This model has at least 2 label or boolean fields <<else>> // Something else <<endif>> Hapify (short) <<? 4 F hd >> // This model has at least 4 hidden fields <<?? 2 F lb + tB >> // This model has at least 2 label or boolean fields <<??>> // Something else <<?>> JavaScript equivalent if ( root . fields . filter ( f => f . hidden ). length >= 4 ) { out += ' // This model has at least 4 hidden fields' ; } else if ( root . fields . filter ( f => f . label || f . type === 'boolean' ). length >= 2 ) { out += ' // This model has at least 2 label or boolean fields' ; } else { out += ' // Something else' ; }","title":"Conditions on the number of occurrences"},{"location":"reference/hapify-syntax/#conditions-on-the-data-models","text":"","title":"Conditions on the data models"},{"location":"reference/hapify-syntax/#test-a-single-data-model","text":"In a template of type one model : Hapify (long) <<if Model isGeolocated >> // This block is reached if the model is geolocated. // that's means it has at least one latitude field and one longitude field <<endif>> Hapify (short) <<? M pGeo >> // This block is reached if the model is geolocated. // that's means it has at least one latitude field and one longitude field <<?>> JavaScript equivalent if ( root . properties . isGeolocated ) { out += ' // ...' ; }","title":"Test a single data model"},{"location":"reference/hapify-syntax/#test-a-list-of-data-models","text":"In a template of type all models : Hapify (long) <<if Models not onlyGuest >> // This block is reached if at least one model has not only guest actions import 'session-service'; <<endif>> Hapify (short) <<? M !pOGs >> // This block is reached if at least one model has not only guest actions import 'session-service'; <<?>> JavaScript equivalent if ( root . filter ( m => ! m . accesses . properties . onlyGuest ). length > 0 ) { out += \" import 'session-service';\" ; }","title":"Test a list of data models"},{"location":"reference/hapify-syntax/#available-objects-and-filters","text":"","title":"Available objects and filters"},{"location":"reference/hapify-syntax/#root-object","text":"Model or Models ( short: M ) refer to the main object: the data model in a template of type one model the array of data models in a template of type all models .","title":"Root object"},{"location":"reference/hapify-syntax/#filterable-and-testable-objects","text":"In the case of a template of type one model : Fields (alias: F ) is the list of fields Dependencies (alias: D ) is the list of dependencies (list of data models) ReferencedIn (alias: RefModels , R ) is the list of data models that depend on it PrimaryField (alias: P ) is the primary field of the model Accesses (alias: A ) is the list of accesses CreateAccess (alias: Ac ) is the access to the create action ReadAccess (alias: Ar ) is the access to the read action UpdateAccess (alias: Au ) is the access to the update action RemoveAccess (alias: Ad ) is the access to the delete action SearchAccess (alias: As ) is the access to the search action CountAccess (alias: An ) is the access to the count action","title":"Filterable and testable objects"},{"location":"reference/hapify-syntax/#filtering-on-field-attributes","text":"Available attributes for a field: primary (short: pr ) for boolean primary unique (short: un ) for boolean unique label (short: lb ) for boolean label nullable (short: nu ) for boolean nullable multiple (short: ml ) for boolean multiple embedded (short: em ) for boolean embedded searchable (short: se ) for boolean searchable sortable (short: so ) for boolean sortable hidden (short: hd ) for boolean hidden internal (short: in ) for boolean internal restricted (short: rs ) for boolean restricted ownership (short: os ) for boolean ownership string (short: tS ) for type string email (short: tSe ) for type string and subtype email password (short: tSp ) for type string and subtype password url (short: tSu ) for type string and subtype url text (short: tSt ) for type string and subtype text richText (alias: rich , short: tSr ) for type string and subtype rich number (short: tN ) for type number integer (short: tNi ) for type number and subtype integer float (short: tNf ) for type number and subtype float latitude (short: tNt ) for type number and subtype latitude longitude (short: tNg ) for type number and subtype longitude boolean (short: tB ) for type boolean datetime (short: tD ) for type datetime date (short: tDd ) for type datetime and subtype date time (short: tDt ) for type datetime and subtype time enum (short: tU ) for type enum entity (short: tE ) for type entity oneOne (short: tEoo ) for type entity and subtype oneOne oneMany (short: tEom ) for type entity and subtype oneMany manyOne (short: tEmo ) for type entity and subtype manyOne manyMany (short: tEmm ) for type entity and subtype manyMany object (short: tO ) for type object file (short: tF ) for type file image (short: tFi ) for type file and subtype image video (short: tFv ) for type file and subtype video audio (short: tFa ) for type file and subtype audio document (short: tFd ) for type file and subtype document Example Hapify (long) <<if Fields ( restricted or internal ) and not number >> // Current model has at least one field matching to the condition <<endif>> Hapify (short) <<? F ( rs + in ) / tN >> // Current model has at least one field matching to the condition <<?>> JavaScript equivalent if ( root . fields . filter ( f => ( f . restricted || f . internal ) && ! f . number ). length > 0 ) { out += \" // ...\" ; }","title":"Filtering on field attributes"},{"location":"reference/hapify-syntax/#filtering-on-data-model-properties","text":"Properties available for a data model: mainlyHidden (short: pMHd ) most of the fields are hidden (strictly) mainlyInternal (short: pMIn ) most of the fields are internal (strictly) isGeolocated (short: pGeo ) the model contains at least one latitude field and one longitude field isGeoSearchable (short: pGSe ) the model contains at least one searchable latitude field and one searchable longitude field Example Hapify (long) <<if Model isGeolocated >> // This model contains at least one latitude field and one longitude field. <<endif>> Hapify (short) <<? M pGeo >> // This model contains at least one latitude field and one longitude field. <<?>> JavaScript equivalent if ( root . properties . isGeolocated ) { out += \" // ...\" ; } Access properties available for a data model: onlyAdmin (short: pOAd ) the model only contains actions restricted to admin onlyOwner (short: pOOw ) the model only contains actions restricted to owner onlyAuth (short: pOAu ) the model only contains actions restricted to authenticated onlyGuest (short: pOGs ) the model only contains actions restricted to guest maxAdmin (short: pMAd ) the most permissive access is admin maxOwner (short: pMOw ) the most permissive access is owner maxAuth (short: pMAu ) the most permissive access is authenticated maxGuest (short: pMGs ) the most permissive access is guest noAdmin (short: pNAd ) there is no action restricted to admin noOwner (short: pNOw ) there is no action restricted to owner noAuth (short: pNAu ) there is no action restricted to authenticated noGuest (short: pNGs ) there is no action restricted to guest Example Hapify (long) <<if Model onlyAdmin >> // All actions on this model are restricted to admins <<endif>> Hapify (short) <<? M pOAd >> // All actions on this model are restricted to admins <<?>> JavaScript equivalent if ( root . accesses . properties . onlyAdmin ) { out += \" // ...\" ; }","title":"Filtering on data model properties"},{"location":"reference/hapify-syntax/#filtering-on-data-model-access","text":"Reminder guest is the most permissive access and admin the least permissive. Therefore admin < owner < authenticated < guest . Filters available for action access: admin (short: ad ) the access is admin owner (short: ow ) the access is owner auth (short: au ) the access is auth guest (short: gs ) the access is guest gteAdmin (short: [ad ) the access is greater or equal than admin gteOwner (short: [ow ) the access is greater or equal than owner gteAuth (short: [au ) the access is greater or equal than auth gteGuest (short: [gs ) the access is greater or equal than guest lteAdmin (short: ad] ) the access is less or equal than admin lteOwner (short: ow] ) the access is less or equal than owner lteAuth (short: au] ) the access is less or equal than auth lteGuest (short: gs] ) the access is less or equal than guest Exemples Tests access for a specific action: Hapify (long) <<if ReadAccess guest >> // Anyone can read this model <<endif>> Hapify (short) <<? Ar gs >> // Anyone can read this model <<?>> JavaScript equivalent if ( root . accesses . read . guest ) { out += ' // ...' ; } Checks if the update action is restricted to either the administrators or the owner: Hapify (long) <<if UpdateAccess admin or owner >> // ... <<endif>> Hapify (short) <<? Au ad + ow >> // ... <<?>> JavaScript equivalent if ( root . accesses . update . admin || root . accesses . update . owner ) { out += ' // ...' ; } Tests whether at least one action is restricted to one or fewer authenticated users: Hapify (long) <<if Accesses lteAuth >> // ... <<endif>> Hapify (short) <<? A au] >> // ... <<?>> JavaScript equivalent if ( root . accesses . filter ( a => a . lteAuth ). length > 0 ) { out += ' // ...' ; } Tip Conditions can be applied to an object or an array of objects. If applied to an array, it will test the length of the array filtered by the provided condition. It can be used on any object containing a filter method that receives a callback returning a boolean. For example, in the data model structure, root.dependencies is an object that contains a filter method. Thus, this operator can test whether a model has dependencies that have fields with a specific condition.","title":"Filtering on data model access"},{"location":"reference/hapify-syntax/#iterations","text":"Iterations use the same filters and operators as conditions.","title":"Iterations"},{"location":"reference/hapify-syntax/#simple-iteration","text":"Loops over all the fields in a data model that are not hidden and assigns them to the field variable: Hapify (long) <?php $fields = array( <<for Fields not hidden field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ F !hd f >> ' <<f aA>> ', <<@>> ); JavaScript equivalent out += `<?php $fields = array( ${ root . fields . filter ( f => ! f . hidden ) . map ( f => \"'\" + f . names . camel + \"'\" ) . join ( \",\\n\\t\" ) } );` ; Example for a data model with fields name , created at and role , where role is hidden: <?php $fields = array ( 'name' , 'createdAt' , ); Loops over the entity and searchable fields of the data model: Hapify (long) <<for Fields searchable and entity field >> // ... <<endfor>> Hapify (short) <<@ F se * tE f >> // ... <<@>> JavaScript equivalent for ( let field of root . fields . filter ( f => f . searchable && f . type === 'entity' )) { out += ' // ...' ; }","title":"Simple iteration"},{"location":"reference/hapify-syntax/#loop-without-filtering","text":"This operation allows you to loop through all the fields: Hapify (long) <<for Fields field >> // ... <<endfor>> Hapify (short) <<@ F f >> // ... <<@>> JavaScript equivalent for ( let field of root . fields . list ) { out += ' // ...' ; }","title":"Loop without filtering"},{"location":"reference/hapify-syntax/#loop-through-data-models","text":"In a template of type all models , this loops through all the data models that are geo-located: Hapify (long) <<for Models isGeolocated model >> // ... <<endfor>> Hapify (short) <<@ M pGeo m >> // ... <<@>> JavaScript equivalent for ( let model of root . filter ( i => i . properties . isGeolocated )) { out += ' // ...' ; }","title":"Loop through data models"},{"location":"reference/hapify-syntax/#loop-through-dependencies","text":"In a template of type one model , this loops through the dependencies whose referent field is searchable: Hapify (long) <<for Dependencies searchable dep >> // ... <<endfor>> Hapify (short) <<@ D se d >> // ... <<@>> JavaScript equivalent for ( let dep of root . dependencies . filter ( f => f . searchable )) { out += ' // ...' ; } Tip In the case of a self-referencing data model, Dependencies excludes this self-dependency. To include it use the following code: <<< for (let dep of root.dependencies.filter(f => f, false)) { >>> // ... <<< } >>> Warning Filtering of Dependencies is performed only on the fields of the current data model that carry the reference. Filtering is not performed on the fields of the target data model.","title":"Loop through dependencies."},{"location":"reference/hapify-syntax/#loop-through-referring-data-models","text":"In a template of type one model , this loops through the data models that have a dependency on it and that are geo-located: Hapify (long) <<for ReferencedIn isGeolocated referrer >> // ... <<endfor>> Hapify (short) <<@ R pGeo r >> // ... <<@>> JavaScript equivalent for ( let referrer of root . referencedIn . filter ( m => m . properties . isGeolocated )) { out += ' // ...' ; } Tip The filter is optional. You can get all the referring data models like this: <<for ReferencedIn referrer >> // ... <<endfor>> Warning Only referenced entity fields are defined in these referring data models.","title":"Loop through referring data models"},{"location":"reference/hapify-syntax/#loop-through-the-accesses-of-the-data-model","text":"Loops through all accesses restricted to an administrator or owner and displays the name of the action: Hapify (long) <<for Accesses admin or owner access >> <<=access.action>> <<endfor>> Hapify (short) <<@ A ad + ow a >> <<=a.action>> <<@>> JavaScript equivalent for ( let access of root . accesses . filter ( a => a . admin || a . owner )) { out += ` ${ access . action } \\ n` ; }","title":"Loop through the accesses of the data model"},{"location":"reference/hapify-syntax/#shortened-iteration","text":"Loop through the first 2 fields of a data model : Hapify (long) <?php $fields = array( <<for 2 Fields field >> ' <<field camel>> ', <<endfor>> ); Hapify (short) <?php $fields = array( <<@ 2 F f >> ' <<f aA>> ', <<@>> ); JavaScript equivalent out += `<?php $fields = array( ${ root . fields . list . slice ( 0 , 2 ) . map ( f => \"'\" + f . names . camel + \"'\" ) . join ( \",\\n\\t\" ) } );` ; For a data model with fields name , email and role : <?php $fields = array ( 'name' , 'email' , );","title":"Shortened iteration"},{"location":"reference/hapify-syntax/#nested-iterations","text":"","title":"Nested iterations"},{"location":"reference/hapify-syntax/#loop-through-the-enums","text":"In a template of type one model , this block defines a TypeScript type containing the enums of a field: Hapify (long) <<for Fields enum field >> type <<field pascal>> = <<for field . enum e >> | '<<e snake >> '<<endfor >> ; <<endfor>> Hapify (short) <<@ F tU f >> type <<f AA>> = <<@ f . e e >> | '<<e a_a >> '<<@ >> ; <<@>> JavaScript equivalent for ( let field of root . fields . filter ( f => f . type === 'enum' )) { out += `type ${ field . names . pascal } = ${ field . enum . map ( e => \"'\" + e . names . snake + \"'\" ). join ( ' | ' ) } ;` ; } Output type Role = | 'admin' | 'user' | 'customer' ;","title":"Loop through the enums"},{"location":"reference/hapify-syntax/#loop-through-the-fields-of-all-data-models","text":"In a template of type all models , this block loops through all the fields of all the data models: Hapify (long) const models = { <<for Models model >> <<m camel>> : [ <<for model . fields field >> ' <<field camel>> ', <<endfor>> ], <<endfor>> } Hapify (short) const models = { <<@ M m >> <<m aA>> : [ <<@ m . f f >> ' <<f aA>> ', <<@>> ], <<@>> } Output const models = { user : [ 'id' , 'createdAt' , 'email' , 'name' , ], place : [ 'id' , 'name' , 'category' , ], placeCategory : [ 'id' , 'createdAt' , 'email' , 'name' , ], }","title":"Loop through the fields of all data models"},{"location":"reference/hapify-syntax/#raw-input-and-interpolation","text":"This operator allows you to write pure JavaScript.","title":"Raw input and interpolation"},{"location":"reference/hapify-syntax/#custom-variable","text":"Defines a custom variable and adds it to the output: <<< const length = root.fields.length; >>> // This model has <<=length>> fields","title":"Custom variable"},{"location":"reference/hapify-syntax/#custom-function","text":"Defines a custom function and calls it: Hapify (long) <<< function fieldName(field) { return field.names.snake.replace('_', ':'); } >>> <<for Fields field >> <<=fieldName(field)>> <<endfor>> Hapify (short) <<< function fieldName(f) { return f.names.snake.replace('_', ':'); } >>> <<@ F f >> <<=fieldName(f)>> <<@>> Output id created:at place:category","title":"Custom function"},{"location":"reference/hapify-syntax/#custom-condition-or-iteration","text":"This block allows you to write a condition that is not handled by the Hapify syntax: <<< if (root.fields.hidden.length < 3 || root.properties.mainlyInternal) { >>> // ... <<< } >>> Tip In a Hapify template of type one model , the root variable refers to the data model. In a Hapify template of type all models , the root variable refers to the array of data models. See also For detailed information on the structure of the data model, see the model object .","title":"Custom condition or iteration"},{"location":"reference/hapify-syntax/#notes","text":"You can retrieve notes left by the user on a field or model: Hapify (long) <<if Model hasNotes >> // <<! Model >> <<endif >> export class <<Model pascal>> { <<for Fields field >> public <<field camel>> ; <<if field hasNotes >> // <<! field >> <<endif >> <<endfor>> } Hapify (short) <<? M hN >> // <<! M >> <<? >> export class <<M AA>> { <<@ F f >> public <<f aA>> ; <<? f hN >> // <<! f >> <<? >> <<@>> } Output // A user can only list its own bookmarks export class Bookmark { public id ; public owner ; // Current user when creating the bookmark public place ; } It is also possible to use interpolation to display the notes: Hapify (long) <<if Model hasNotes >> // <<=root . notes >> <<endif >> export class <<Model pascal>> { <<for Fields field >> public <<field camel>> ; <<if field hasNotes >> // <<=field . notes >> <<endif >> <<endfor>> } Hapify (short) <<? M hN >> // <<=root . notes >> <<? >> export class <<M AA>> { <<@ F f >> public <<f aA>> ; <<? f hN >> // <<=field . notes >> <<? >> <<@>> }","title":"Notes"},{"location":"reference/hapify-syntax/#error","text":"Do not write this: <<= JSON.stringify(root) >> . The root object has recursive properties. Therefore, this command will lead to an infinite loop.","title":"Error"},{"location":"reference/hapify-syntax/#comments","text":"This syntax writes a comment to the template without any output to the generated file. <<# This is just a comment>>","title":"Comments"},{"location":"reference/hapify-syntax/#escaping_1","text":"It is possible to escape the tags of the Hapify syntax with the character \\ : Hapify $val = 4; $res = $val \\<\\< 3; $res = 4 \\>\\> $val; Output $val = 4; $res = $val << 3; $res = 4 >> $val;","title":"Escaping"},{"location":"reference/hapify-syntax/#formatting","text":"Empty lines and lines containing only condition or iteration meta-code are automatically deleted after generation. To force the generator to keep an empty line, insert one or more spaces at the beginning of it. Warning Hapify does not format the generated code, since the formatting rules are specific to each language or framework. We strongly recommend you to use a code formatter after the generation.","title":"Formatting"},{"location":"reference/hapify-syntax/#reserved-words","text":"The following list of words cannot be used to name variables. A , Ac , Accesses , ad , Ad , admin , An , and , andNot , Ar , As , au , Au , audio , auth , boolean , CountAccess , CreateAccess , D , date , datetime , Dependencies , document , else , elseif , em , email , embedded , endfor , endif , entity , enum , F , Fields , file , float , for , gs , gteAdmin , gteAuth , gteGuest , gteOwner , guest , hasNotes , hd , hidden , hN , if , image , in , integer , internal , isGeolocated , isGeoSearchable , label , latitude , lb , longitude , lteAdmin , lteAuth , lteGuest , lteOwner , M , mainlyHidden , mainlyInternal , manyMany , manyOne , maxAdmin , maxAuth , maxGuest , maxOwner , ml , Model , Models , multiple , noAdmin , noAuth , noGuest , noOwner , not , nu , nullable , number , object , oneMany , oneOne , onlyAdmin , onlyAuth , onlyGuest , onlyOwner , or , orNot , os , out , ow , owner , ownership , P , password , pGeo , pGSe , pMAd , pMAu , pMGs , pMHd , pMIn , pMOw , pNAd , pNAu , pNGs , pNOw , pOAd , pOAu , pOGs , pOOw , pr , primary , PrimaryField , R , ReadAccess , ReferencedIn , RefModels , RemoveAccess , restricted , rich , richText , root , rs , se , searchable , SearchAccess , so , sortable , string , tB , tD , tDd , tDt , tE , tEmm , tEmo , tEom , tEoo , text , tF , tFa , tFd , tFi , tFv , time , tN , tNf , tNg , tNi , tNt , tO , tS , tSe , tSp , tSr , tSt , tSu , tU , un , unique , UpdateAccess , url , video .","title":"Reserved words"},{"location":"reference/model-object/","text":"This document describes the structure of the object that represents a data model when writing a template. Before reading this document, you should take a look at the concepts section . Within the templates Injecting the data model The template input can be defined as one model or all models . During generation, if it is defined as one model , the template will be called once for each data model. Therefore, it will generate one file for each data model. If it is defined as all models , the template will be called once for all data models. It will then generate a single file. Single model If the template requires only one model, then an object model ( alias m ) will be available as a global variable in the template. In a Hapify template, it will be available as Model , M or root . In an EJS or JavaScript template, it will be available as model or m . Multiple models If the template requires all models, an array models ( alias m ) will be available as a global variable in the template. This array contains all available models. In a Hapify template, it will be available as Models , M or root . In an EJS or JavaScript template, it will be available as models or m . Structure of the model object The following objects will be available in the template. Model object id (string): an unique ID name (string): name of the model, as the user entered it. names (object): name variants computed from the name property. raw (string): as the user entered it. Example Online item . kebab (string): example online-item . big (string): example ONLINE-ITEM . header (string): example Online-Item . snake (string): example online_item . constant (string): example ONLINE_ITEM . compact (string): example onlineitem . camel (string): example onlineItem . pascal (string): example OnlineItem . lower (string): example online item . capital (string): example Online Item . notes (string): the notes of the model, as entered by the user. hasNotes (boolean): the model has notes. fields - alias f (object): an object containing all fields, grouped in different arrays. See Field object section to learn more about field's structure. list - alias l (array): containing all fields of the model. primary - alias pr (Field): primary field of the model. null if no primary field is defined. unique - alias un (array): fields flagged as unique . label - alias lb (array): fields flagged as label . nullable - alias nu (array): fields flagged as nullable . multiple - alias ml (array): fields flagged as multiple . embedded - alias em (array): fields flagged as embedded . searchable - alias se (array): fields flagged as searchable . sortable - alias so (array): fields flagged as sortable . hidden - alias hd (array): fields flagged as hidden . internal - alias in (array): fields flagged as internal . restricted - alias rs (array): fields flagged as restricted . ownership - alias os (array): fields flagged as ownership . searchableLabel - alias sl (array): fields flagged as label and searchable . Useful for quick-search by label. filter - alias f (Function): filter fields with a custom rule. Equivalent of model.fields.list.filter . references - alias r - non-deep model only (array): fields of type entity . filter - alias f (function): filter the array. dependencies - alias d - non-deep model only (object): dependencies (to other models) of this model. A model has a dependency if one of this field is of type entity . list - alias l (array): dependency models, but self. These models are added as \"deep models\". self - alias s (boolean): this model has a self-dependency. filter - alias f (function): filter dependencies. First argument (function - default (f) => f ): filter function receiving the referencer field (the entity field). Second argument (boolean - default true ): boolean indicating if we should filter the self dependency. referencedIn - alias ri - non-deep model only (array): models that refer to this one. These models are added as \"deep models\". These models only contains fields of type entity referring to the current model. filter - alias f (function): filter the array. properties - alias p (object): pre-computed properties from fields. fieldsCount (number): the number of fields contained in the model. hasPrimary (boolean): model has a primary field. hasUnique (boolean): model has at least one unique field. hasLabel (boolean): model has at least one label field. hasNullable (boolean): model has at least one nullable field. hasMultiple (boolean): model has at least one multiple field. hasEmbedded (boolean): model has at least one embedded field. hasSearchable (boolean): model has at least one searchable field. hasSortable (boolean): model has at least one sortable field. hasHidden (boolean): model has at least one hidden field. hasInternal (boolean): model has at least one internal field. hasRestricted (boolean): model has at least one restricted field. hasOwnership (boolean): model has at least one ownership field. hasSearchableLabel (boolean): model has at least one field marked as label and also searchable. hasDependencies - non-deep model only (boolean): model has dependencies to other models or itself (through an entity field). isReferenced - non-deep model only (boolean): model is referenced by other models. mainlyHidden (boolean): most of the fields are hidden (strictly). mainlyInternal (boolean): most of the fields are internal (strictly). isGeolocated (boolean): model contains at least one latitude field and one longitude field. isGeoSearchable (boolean): model contains at least one searchable latitude field and one searchable longitude field. accesses - alias a (object): action's accesses grouped by action or restriction. See Access object section to learn more about access' structure. list - alias l (array): action's accesses of the model. admin - alias ad (array): action's accesses restricted to admin . owner - alias ow (array): action's accesses restricted to owner . auth - alias au (array): action's accesses restricted to authenticated . guest - alias gs (array): action's accesses restricted to guest . create - alias c (object): the create action's access. read - alias r (object): the read action's access. update - alias u (object): the update action's access. remove - alias d (object): the delete action's access. search - alias s (object): the search action's access. count - alias n (object): the count action's access. filter - alias f (Function): filter action's accesses with a custom rule. Equivalent of model.accesses.list.filter . properties - alias p (object): pre-computed properties from action's accesses. onlyAdmin (boolean): model only contains actions restricted to admin . onlyOwner (boolean): model only contains actions restricted to owner . onlyAuth (boolean): model only contains actions restricted to authenticated . onlyGuest (boolean): model only contains actions restricted to guest . maxAdmin (boolean): most permissive access is admin . maxOwner (boolean): most permissive access is owner . maxAuth (boolean): most permissive access is authenticated . maxGuest (boolean): most permissive access is guest . noAdmin (boolean): there is no action restricted to admin . noOwner (boolean): there is no action restricted to owner . noAuth (boolean): there is no action restricted to authenticated . noGuest (boolean): there is no action restricted to guest . hasAdmin (boolean): there is at least one action restricted to admin . hasOwner (boolean): there is at least one action restricted to owner . hasAuth (boolean): there is at least one action restricted to authenticated . hasGuest (boolean): there is at least one action restricted to guest . Field object name (string): name of the field, as the user entered it. names (object): name variants computed the name property. As for the model object. raw (string): as the user entered it. Example first_name . kebab (string): example first-name . big (string): example FIRST-NAME . header (string): example First-Name . snake (string): example first_name . constant (string): example FIRST_NAME . compact (string): example firstname . camel (string): example firstName . pascal (string): example FirstName . lower (string): example first name . upper (string): example FIRST NAME . capital (string): example First Name . notes (string): the notes of the field, as entered by the user. hasNotes (boolean): the field has notes. primary (boolean): field is flagged as primary . unique (boolean): field is flagged as unique . label (boolean): field is flagged as label . nullable (boolean): field is flagged as nullable . multiple (boolean): field is flagged as multiple . embedded (boolean): field is flagged as embedded . searchable (boolean): field is flagged as searchable . sortable (boolean): field is flagged as sortable . hidden (boolean): field is flagged as hidden . internal (boolean): field is flagged as internal . restricted (boolean): field is flagged as restricted . ownership (boolean): field is flagged as ownership . type (string): type of the field. Can be string , number , boolean , datetime , entity , object or file . subtype (string): subtype of the field. The available values depend on the type : string : Can be null , email , password , url , text or rich . number : Can be null , integer , float , latitude or longitude . boolean : Is null . datetime : Can be null , date or time . entity : Is null . object : Is null . file : Can be null , image , video , audio or document . model - alias m (object): target model object if the field is of type entity . null otherwise. enum - alias e (array): an array containing all enum if the field is of type enum . null otherwise. See Enum object section to learn more about enum's structure. value (string|string[]): If type is entity : raw ID of the target model (string). If type is enum : raw enum list (string[]). Otherwise null . Enum object name (string): name of the enum, as the user entered it. names (object): name variants computed the name property. As for the field and model object. raw (string): as the user entered it. Example first_name . kebab (string): example first-name . big (string): example FIRST-NAME . header (string): example First-Name . snake (string): example first_name . constant (string): example FIRST_NAME . compact (string): example firstname . camel (string): example firstName . pascal (string): example FirstName . lower (string): example first name . upper (string): example FIRST NAME . capital (string): example First Name . Access object action (string): name of the action. Can be create , read , update , remove , search or count . admin (boolean): access is admin . owner (boolean): access is owner . auth (boolean): access is authenticated . guest (boolean): access is guest . gteAdmin (boolean): access is greater or equal than admin (should always be true ). gteOwner (boolean): access is greater or equal than owner . gteAuth (boolean): access is greater or equal than authenticated . gteGuest (boolean): access is greater or equal than guest . lteAdmin (boolean): access is less or equal than admin . lteOwner (boolean): access is less or equal than owner . lteAuth (boolean): access is less or equal than authenticated . lteGuest (boolean): access is less or equal than guest (should always be true ).","title":"Model object"},{"location":"reference/model-object/#within-the-templates","text":"","title":"Within the templates"},{"location":"reference/model-object/#injecting-the-data-model","text":"The template input can be defined as one model or all models . During generation, if it is defined as one model , the template will be called once for each data model. Therefore, it will generate one file for each data model. If it is defined as all models , the template will be called once for all data models. It will then generate a single file.","title":"Injecting the data model"},{"location":"reference/model-object/#single-model","text":"If the template requires only one model, then an object model ( alias m ) will be available as a global variable in the template. In a Hapify template, it will be available as Model , M or root . In an EJS or JavaScript template, it will be available as model or m .","title":"Single model"},{"location":"reference/model-object/#multiple-models","text":"If the template requires all models, an array models ( alias m ) will be available as a global variable in the template. This array contains all available models. In a Hapify template, it will be available as Models , M or root . In an EJS or JavaScript template, it will be available as models or m .","title":"Multiple models"},{"location":"reference/model-object/#structure-of-the-model-object","text":"The following objects will be available in the template.","title":"Structure of the model object"},{"location":"reference/model-object/#model-object","text":"id (string): an unique ID name (string): name of the model, as the user entered it. names (object): name variants computed from the name property. raw (string): as the user entered it. Example Online item . kebab (string): example online-item . big (string): example ONLINE-ITEM . header (string): example Online-Item . snake (string): example online_item . constant (string): example ONLINE_ITEM . compact (string): example onlineitem . camel (string): example onlineItem . pascal (string): example OnlineItem . lower (string): example online item . capital (string): example Online Item . notes (string): the notes of the model, as entered by the user. hasNotes (boolean): the model has notes. fields - alias f (object): an object containing all fields, grouped in different arrays. See Field object section to learn more about field's structure. list - alias l (array): containing all fields of the model. primary - alias pr (Field): primary field of the model. null if no primary field is defined. unique - alias un (array): fields flagged as unique . label - alias lb (array): fields flagged as label . nullable - alias nu (array): fields flagged as nullable . multiple - alias ml (array): fields flagged as multiple . embedded - alias em (array): fields flagged as embedded . searchable - alias se (array): fields flagged as searchable . sortable - alias so (array): fields flagged as sortable . hidden - alias hd (array): fields flagged as hidden . internal - alias in (array): fields flagged as internal . restricted - alias rs (array): fields flagged as restricted . ownership - alias os (array): fields flagged as ownership . searchableLabel - alias sl (array): fields flagged as label and searchable . Useful for quick-search by label. filter - alias f (Function): filter fields with a custom rule. Equivalent of model.fields.list.filter . references - alias r - non-deep model only (array): fields of type entity . filter - alias f (function): filter the array. dependencies - alias d - non-deep model only (object): dependencies (to other models) of this model. A model has a dependency if one of this field is of type entity . list - alias l (array): dependency models, but self. These models are added as \"deep models\". self - alias s (boolean): this model has a self-dependency. filter - alias f (function): filter dependencies. First argument (function - default (f) => f ): filter function receiving the referencer field (the entity field). Second argument (boolean - default true ): boolean indicating if we should filter the self dependency. referencedIn - alias ri - non-deep model only (array): models that refer to this one. These models are added as \"deep models\". These models only contains fields of type entity referring to the current model. filter - alias f (function): filter the array. properties - alias p (object): pre-computed properties from fields. fieldsCount (number): the number of fields contained in the model. hasPrimary (boolean): model has a primary field. hasUnique (boolean): model has at least one unique field. hasLabel (boolean): model has at least one label field. hasNullable (boolean): model has at least one nullable field. hasMultiple (boolean): model has at least one multiple field. hasEmbedded (boolean): model has at least one embedded field. hasSearchable (boolean): model has at least one searchable field. hasSortable (boolean): model has at least one sortable field. hasHidden (boolean): model has at least one hidden field. hasInternal (boolean): model has at least one internal field. hasRestricted (boolean): model has at least one restricted field. hasOwnership (boolean): model has at least one ownership field. hasSearchableLabel (boolean): model has at least one field marked as label and also searchable. hasDependencies - non-deep model only (boolean): model has dependencies to other models or itself (through an entity field). isReferenced - non-deep model only (boolean): model is referenced by other models. mainlyHidden (boolean): most of the fields are hidden (strictly). mainlyInternal (boolean): most of the fields are internal (strictly). isGeolocated (boolean): model contains at least one latitude field and one longitude field. isGeoSearchable (boolean): model contains at least one searchable latitude field and one searchable longitude field. accesses - alias a (object): action's accesses grouped by action or restriction. See Access object section to learn more about access' structure. list - alias l (array): action's accesses of the model. admin - alias ad (array): action's accesses restricted to admin . owner - alias ow (array): action's accesses restricted to owner . auth - alias au (array): action's accesses restricted to authenticated . guest - alias gs (array): action's accesses restricted to guest . create - alias c (object): the create action's access. read - alias r (object): the read action's access. update - alias u (object): the update action's access. remove - alias d (object): the delete action's access. search - alias s (object): the search action's access. count - alias n (object): the count action's access. filter - alias f (Function): filter action's accesses with a custom rule. Equivalent of model.accesses.list.filter . properties - alias p (object): pre-computed properties from action's accesses. onlyAdmin (boolean): model only contains actions restricted to admin . onlyOwner (boolean): model only contains actions restricted to owner . onlyAuth (boolean): model only contains actions restricted to authenticated . onlyGuest (boolean): model only contains actions restricted to guest . maxAdmin (boolean): most permissive access is admin . maxOwner (boolean): most permissive access is owner . maxAuth (boolean): most permissive access is authenticated . maxGuest (boolean): most permissive access is guest . noAdmin (boolean): there is no action restricted to admin . noOwner (boolean): there is no action restricted to owner . noAuth (boolean): there is no action restricted to authenticated . noGuest (boolean): there is no action restricted to guest . hasAdmin (boolean): there is at least one action restricted to admin . hasOwner (boolean): there is at least one action restricted to owner . hasAuth (boolean): there is at least one action restricted to authenticated . hasGuest (boolean): there is at least one action restricted to guest .","title":"Model object"},{"location":"reference/model-object/#field-object","text":"name (string): name of the field, as the user entered it. names (object): name variants computed the name property. As for the model object. raw (string): as the user entered it. Example first_name . kebab (string): example first-name . big (string): example FIRST-NAME . header (string): example First-Name . snake (string): example first_name . constant (string): example FIRST_NAME . compact (string): example firstname . camel (string): example firstName . pascal (string): example FirstName . lower (string): example first name . upper (string): example FIRST NAME . capital (string): example First Name . notes (string): the notes of the field, as entered by the user. hasNotes (boolean): the field has notes. primary (boolean): field is flagged as primary . unique (boolean): field is flagged as unique . label (boolean): field is flagged as label . nullable (boolean): field is flagged as nullable . multiple (boolean): field is flagged as multiple . embedded (boolean): field is flagged as embedded . searchable (boolean): field is flagged as searchable . sortable (boolean): field is flagged as sortable . hidden (boolean): field is flagged as hidden . internal (boolean): field is flagged as internal . restricted (boolean): field is flagged as restricted . ownership (boolean): field is flagged as ownership . type (string): type of the field. Can be string , number , boolean , datetime , entity , object or file . subtype (string): subtype of the field. The available values depend on the type : string : Can be null , email , password , url , text or rich . number : Can be null , integer , float , latitude or longitude . boolean : Is null . datetime : Can be null , date or time . entity : Is null . object : Is null . file : Can be null , image , video , audio or document . model - alias m (object): target model object if the field is of type entity . null otherwise. enum - alias e (array): an array containing all enum if the field is of type enum . null otherwise. See Enum object section to learn more about enum's structure. value (string|string[]): If type is entity : raw ID of the target model (string). If type is enum : raw enum list (string[]). Otherwise null .","title":"Field object"},{"location":"reference/model-object/#enum-object","text":"name (string): name of the enum, as the user entered it. names (object): name variants computed the name property. As for the field and model object. raw (string): as the user entered it. Example first_name . kebab (string): example first-name . big (string): example FIRST-NAME . header (string): example First-Name . snake (string): example first_name . constant (string): example FIRST_NAME . compact (string): example firstname . camel (string): example firstName . pascal (string): example FirstName . lower (string): example first name . upper (string): example FIRST NAME . capital (string): example First Name .","title":"Enum object"},{"location":"reference/model-object/#access-object","text":"action (string): name of the action. Can be create , read , update , remove , search or count . admin (boolean): access is admin . owner (boolean): access is owner . auth (boolean): access is authenticated . guest (boolean): access is guest . gteAdmin (boolean): access is greater or equal than admin (should always be true ). gteOwner (boolean): access is greater or equal than owner . gteAuth (boolean): access is greater or equal than authenticated . gteGuest (boolean): access is greater or equal than guest . lteAdmin (boolean): access is less or equal than admin . lteOwner (boolean): access is less or equal than owner . lteAuth (boolean): access is less or equal than authenticated . lteGuest (boolean): access is less or equal than guest (should always be true ).","title":"Access object"}]}